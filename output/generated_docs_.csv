filename,repo,file_url,func_name,language,input_code,model,prompt,generated_doc,origin_doc
sample.csv,gem/oq-engine,https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L81-L106,export_ruptures_csv,python,"def export_ruptures_csv(ekey, dstore):
    """"""
    :param ekey: export key, i.e. a pair (datastore key, fmt)
    :param dstore: datastore object
    """"""
    oq = dstore['oqparam']
    if 'scenario' in oq.calculation_mode:
        return []
    dest = dstore.export_path('ruptures.csv')
    header = ('rupid multiplicity mag centroid_lon centroid_lat '
              'centroid_depth trt strike dip rake boundary').split()
    rows = []
    for rgetter in gen_rupture_getters(dstore):
        rups = rgetter.get_ruptures()
        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)
        for r in rup_data.to_array(rups):
            rows.append(
                (r['rup_id'], r['multiplicity'], r['mag'],
                 r['lon'], r['lat'], r['depth'],
                 rgetter.trt, r['strike'], r['dip'], r['rake'],
                 r['boundary']))
    rows.sort()  # by rupture serial
    comment = 'investigation_time=%s, ses_per_logic_tree_path=%s' % (
        oq.investigation_time, oq.ses_per_logic_tree_path)
    writers.write_csv(dest, rows, header=header, sep='\t', comment=comment)
    return [dest]",llama3.2:1b,"[{'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L81-L106', 'func_name': 'export_ruptures_csv', 'language': 'python', 'input_code': 'def export_ruptures_csv(ekey, dstore):\r\n    """"""\r\n    :param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object\r\n    """"""\r\n    oq = dstore[\'oqparam\']\r\n    if \'scenario\' in oq.calculation_mode:\r\n        return []\r\n    dest = dstore.export_path(\'ruptures.csv\')\r\n    header = (\'rupid multiplicity mag centroid_lon centroid_lat \'\r\n              \'centroid_depth trt strike dip rake boundary\').split()\r\n    rows = []\r\n    for rgetter in gen_rupture_getters(dstore):\r\n        rups = rgetter.get_ruptures()\r\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\r\n        for r in rup_data.to_array(rups):\r\n            rows.append(\r\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\r\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\r\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\r\n                 r[\'boundary\']))\r\n    rows.sort()  # by rupture serial\r\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\r\n        oq.investigation_time, oq.ses_per_logic_tree_path)\r\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_ruptures_csv(ekey: tuple[int, str], dstore: \'DatastoreObjectStore\') -> list:\n    """"""\n    Generates a CSV file containing rupture data for the specified export key.\n\n    :param ekey: A pair (datastore key, fmt) representing the export key.\n    :param dstore: The datastore object to use for exporting ruptures.\n    :return: A list containing the destination filename and path of the exported CSV file.\n    """"""\n    # Get the oqparam calculation mode from the datastore\n    oq = dstore[\'oqparam\']\n\n    # If the calculation mode is in \'scenario\' mode, return an empty list\n    if \'scenario\' in oq.calculation_mode:\n        return []\n\n    # Set the export path for the CSV file\n    dest = dstore.export_path(\'ruptures.csv\')\n\n    # Define the header row for the CSV file\n    header = (\n        \'rupid multiplicity mag centroid_lon centroid_lat \'\n        \'centroid_depth trt strike dip rake boundary\').split()\n\n    # Initialize an empty list to store the rupture rows\n    rows = []\n\n    # Iterate over each rupture getter object (gen_rupture_getters)\n    for rgetter in gen_rupture_getters(dstore):\n        # Get the ruptures from the generator\n        rups = rgetter.get_ruptures()\n\n        # Create a RuptureData object with the relevant parameters\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\n\n        # Iterate over each rupture in the data\n        for r in rup_data.to_array(rups):\n            # Append the row to the list of rows\n            rows.append(\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\n                 r[\'boundary\']))\n\n    # Sort the rows by rupture serial\n    rows.sort()\n\n    # Define a comment to include in the CSV file header\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\n        oq.investigation_time, oq.ses_per_logic_tree_path)\n\n    # Write the CSV file using the writers module\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\n    \n    # Return a list containing the destination filename and path\n    return [dest]\n```', 'origin_doc': ':param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L223-L235', 'func_name': 'export_hmaps_csv', 'language': 'python', 'input_code': 'def export_hmaps_csv(key, dest, sitemesh, array, comment):\r\n    """"""\r\n    Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file\r\n    """"""\r\n    curves = util.compose_arrays(sitemesh, array)\r\n    writers.write_csv(dest, curves, comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hmaps_csv(\n    key: str,\n    dest: str,\n    sitemesh: str,\n    array: ""composite_array"",\n    comment: str = """"\n) -> list:\n    """"""\n    Export the hazard maps of the given realization into CSV.\n\n    This function generates a CSV file containing the hazard maps for the specified\n    realization, written by the HMP library. The hazard maps are composed from a given\n    composite array and exported to a specific destination file with an optional comment.\n\n    :param key: Output type and export type (string)\n    :param dest: Name of the exported CSV file (string)\n    :param sitemesh: Site collection (string)\n    :param array: Composite array of dtype hmap_dt\n    :param comment: Comment to use as header of the exported CSV file (string, optional)\n    :return: List containing the name of the exported CSV file\n    """"""\n\n    # Curves are generated from the site collection and composite array using util.compose_arrays\n    curves = util.compose_arrays(sitemesh, array)\n\n    # The hazard maps are written to a CSV file using writers.write_csv\n    writers.write_csv(dest, curves, comment=comment)\n\n    # Return a list containing the name of the exported CSV file\n    return [dest]\n```', 'origin_doc': 'Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L238-L245', 'func_name': 'add_imt', 'language': 'python', 'input_code': 'def add_imt(fname, imt):\r\n    """"""\r\n    >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\r\n    \'/path/to/hcurve-SA(0.1)_23.csv\'\r\n    """"""\r\n    name = os.path.basename(fname)\r\n    newname = re.sub(r\'(_\\d+\\.)\', \'-%s\\\\1\' % imt, name)\r\n    return os.path.join(os.path.dirname(fname), newname)', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef add_imt(fname: str, imt: str) -> str:\n    """"""\n    Adds a suffix to the given file name in the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Args:\n        fname (str): The base filename with extension.\n        imt (str): The IMT suffix to be appended.\n\n    Returns:\n        str: The new filename with the appended suffix.\n\n    Raises:\n        ValueError: If the file name does not match the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Example:\n        >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\n        \'/path/to/hcurve-SA(0.1)_23.csv\'\n    """"""\n```\n\nNote: I\'ve added type hints for `fname` and `imt`, followed by a brief description of what each parameter represents, as well as the return value. The docstring also includes an example use case to help illustrate how to call the function.', 'origin_doc': "">>> add_imt('/path/to/hcurve_23.csv', 'SA(0.1)')\r\n    '/path/to/hcurve-SA(0.1)_23.csv'""}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L248-L277', 'func_name': 'export_hcurves_by_imt_csv', 'language': 'python', 'input_code': 'def export_hcurves_by_imt_csv(\r\n        key, kind, rlzs_assoc, fname, sitecol, array, oq, checksum):\r\n    """"""\r\n    Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters\r\n    """"""\r\n    nsites = len(sitecol)\r\n    fnames = []\r\n    for imt, imls in oq.imtls.items():\r\n        slc = oq.imtls(imt)\r\n        dest = add_imt(fname, imt)\r\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\r\n        for iml in imls:\r\n            lst.append((\'poe-%s\' % iml, F32))\r\n        hcurves = numpy.zeros(nsites, lst)\r\n        for sid, lon, lat, dep in zip(\r\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\r\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\r\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\r\n            rlzs_assoc, kind, oq.investigation_time) + (\r\n                \', imt=""%s"", checksum=%d\' % (imt, checksum)\r\n            ), header=[name for (name, dt) in lst]))\r\n    return fnames', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hcurves_by_imt_csv(\n        key: str, kind: str, rlzs_assoc: object, fname: str, sitecol: object, array: numpy.ndarray,\n        oq: dict) -> list:\n    """"""\n    Export the curves of the given realization into CSV.\n\n    Parameters\n    ----------\n    key : str\n        output_type and export type\n\n    kind : str\n        a string with the kind of output (realization or statistics)\n\n    rlzs_assoc : object\n        an instance of openquake.commonlib.source.RlzsAssoc, containing associated realizations\n\n    fname : str\n        name of the exported file\n\n    sitecol : object\n        site collection\n\n    array : numpy.ndarray, shape (N, L) and dtype numpy.float32\n        an array representing the depths of the given realization\n\n    oq : dict\n        job.ini parameters\n\n    Returns\n    -------\n    list\n        a list of filenames for each exported curve CSV file\n\n    Raises\n    ------\n    TypeError\n        if rlzs_assoc is not an instance of openquake.commonlib.source.RlzsAssoc, or if oq.imtls is empty\n    ValueError\n        if any(imt not in oq.imtls for imt in rlzs_assoc.get(\'imts\', []))\n    """"""\n\n    # Calculate the number of sites and filenames needed for each exported curve CSV file\n    nsites = len(sitecol)\n    fnames = []\n    for imt, imls in oq.imtls.items():\n        # Get the associated realizations\n        slc = oq.imtls(imt)\n        dest = add_imt(fname, imt)\n\n        # Prepare a list of columns for the CSV file\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\n\n        # Add information about each point on the curve to the CSV file\n        for iml in imls:\n            lst.append((\'poe-%s\' % iml, F32))\n\n        # Create an array of shape (nsites, 3) containing the coordinates and depths of each point on the curve\n        hcurves = numpy.zeros(nsites, lst)\n\n        # Add information about each point on the curve to the CSV file\n        for sid, lon, lat, dep in zip(\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\n\n        # Write each CSV file with the exported data\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\n            rlzs_assoc, kind, oq.investigation_time) + ("" imt=""%s"", checksum=%d"" % (imt, checksum)), header=[name for (name, dt) in lst])))\n\n    return fnames\n```', 'origin_doc': 'Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L280-L294', 'func_name': 'hazard_curve_name', 'language': 'python', 'input_code': 'def hazard_curve_name(dstore, ekey, kind, rlzs_assoc):\r\n    """"""\r\n    :param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance\r\n    """"""\r\n    key, fmt = ekey\r\n    prefix = {\'hcurves\': \'hazard_curve\', \'hmaps\': \'hazard_map\',\r\n              \'uhs\': \'hazard_uhs\'}[key]\r\n    if kind.startswith(\'quantile-\'):  # strip the 7 characters \'hazard_\'\r\n        fname = dstore.build_fname(\'quantile_\' + prefix[7:], kind[9:], fmt)\r\n    else:\r\n        fname = dstore.build_fname(prefix, kind, fmt)\r\n    return fname', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef hazard_curve_name(dstore: object, ekey: str, kind: str, rlzs_assoc: object) -> str:\n    """"""\n    Generates the name of a hazard curve based on the export key and kind.\n\n    This function takes in three arguments: `calc_id`, `ekey`, `kind`, and `rlzs_assoc`.\n    It returns the formatted file name for the hazard curve.\n\n    Args:\n        dstore (object): The database store instance to use for building file names.\n        ekey (str): The export key associated with the hazard curve.\n        kind (str): The type of key that corresponds to the hazard curve.\n        rlzs_assoc (object): A RlzsAssoc instance representing the association.\n\n    Returns:\n        str: The formatted file name for the hazard curve.\n\n    Raises:\n        None\n\n    Example:\n        >>> import numpy as np\n        >>> from rlm.utils import hazard_curve_name\n        >>> dstore = ...  # Initialize database store instance\n        >>> ekey = \'hcurves/quantile/hazard_7\'\n        >>> kind = \'quantile\'\n        >>> rlzs_assoc = ...  # Initialize RlzsAssoc instance\n        >>> hazard_curve_name(dstore, ekey, kind, rlzs_assoc)\n        \'/path/to/file_name.hazard_curve\'\n    """"""\n```\n\nThis docstring uses Google-style formatting for consistency and readability. It includes a one-line summary of what the function does, as well as clear and concise information about each argument, return value, and any applicable exceptions. The example demonstrates how to use the function with sample arguments.', 'origin_doc': ':param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance'}]","```python
def export_ruptures_csv(ekey: tuple[int, str], dstore: 'DatastoreObjectStore') -> list:
    """"""
    Generates a CSV file containing rupture data for the specified export key.

    :param ekey: A pair (datastore key, fmt) representing the export key.
    :param dstore: The datastore object to use for exporting ruptures.
    :return: A list containing the destination filename and path of the exported CSV file.
    """"""
    # Get the oqparam calculation mode from the datastore
    oq = dstore['oqparam']

    # If the calculation mode is in 'scenario' mode, return an empty list
    if 'scenario' in oq.calculation_mode:
        return []

    # Set the export path for the CSV file
    dest = dstore.export_path('ruptures.csv')

    # Define the header row for the CSV file
    header = (
        'rupid multiplicity mag centroid_lon centroid_lat '
        'centroid_depth trt strike dip rake boundary').split()

    # Initialize an empty list to store the rupture rows
    rows = []

    # Iterate over each rupture getter object (gen_rupture_getters)
    for rgetter in gen_rupture_getters(dstore):
        # Get the ruptures from the generator
        rups = rgetter.get_ruptures()

        # Create a RuptureData object with the relevant parameters
        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)

        # Iterate over each rupture in the data
        for r in rup_data.to_array(rups):
            # Append the row to the list of rows
            rows.append(
                (r['rup_id'], r['multiplicity'], r['mag'],
                 r['lon'], r['lat'], r['depth'],
                 rgetter.trt, r['strike'], r['dip'], r['rake'],
                 r['boundary']))

    # Sort the rows by rupture serial
    rows.sort()

    # Define a comment to include in the CSV file header
    comment = 'investigation_time=%s, ses_per_logic_tree_path=%s' % (
        oq.investigation_time, oq.ses_per_logic_tree_path)

    # Write the CSV file using the writers module
    writers.write_csv(dest, rows, header=header, sep='\t', comment=comment)
    
    # Return a list containing the destination filename and path
    return [dest]
```",":param ekey: export key, i.e. a pair (datastore key, fmt)
    :param dstore: datastore object"
sample.csv,gem/oq-engine,https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L223-L235,export_hmaps_csv,python,"def export_hmaps_csv(key, dest, sitemesh, array, comment):
    """"""
    Export the hazard maps of the given realization into CSV.

    :param key: output_type and export_type
    :param dest: name of the exported file
    :param sitemesh: site collection
    :param array: a composite array of dtype hmap_dt
    :param comment: comment to use as header of the exported CSV file
    """"""
    curves = util.compose_arrays(sitemesh, array)
    writers.write_csv(dest, curves, comment=comment)
    return [dest]",llama3.2:1b,"[{'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L81-L106', 'func_name': 'export_ruptures_csv', 'language': 'python', 'input_code': 'def export_ruptures_csv(ekey, dstore):\r\n    """"""\r\n    :param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object\r\n    """"""\r\n    oq = dstore[\'oqparam\']\r\n    if \'scenario\' in oq.calculation_mode:\r\n        return []\r\n    dest = dstore.export_path(\'ruptures.csv\')\r\n    header = (\'rupid multiplicity mag centroid_lon centroid_lat \'\r\n              \'centroid_depth trt strike dip rake boundary\').split()\r\n    rows = []\r\n    for rgetter in gen_rupture_getters(dstore):\r\n        rups = rgetter.get_ruptures()\r\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\r\n        for r in rup_data.to_array(rups):\r\n            rows.append(\r\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\r\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\r\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\r\n                 r[\'boundary\']))\r\n    rows.sort()  # by rupture serial\r\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\r\n        oq.investigation_time, oq.ses_per_logic_tree_path)\r\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_ruptures_csv(ekey: tuple[int, str], dstore: \'DatastoreObjectStore\') -> list:\n    """"""\n    Generates a CSV file containing rupture data for the specified export key.\n\n    :param ekey: A pair (datastore key, fmt) representing the export key.\n    :param dstore: The datastore object to use for exporting ruptures.\n    :return: A list containing the destination filename and path of the exported CSV file.\n    """"""\n    # Get the oqparam calculation mode from the datastore\n    oq = dstore[\'oqparam\']\n\n    # If the calculation mode is in \'scenario\' mode, return an empty list\n    if \'scenario\' in oq.calculation_mode:\n        return []\n\n    # Set the export path for the CSV file\n    dest = dstore.export_path(\'ruptures.csv\')\n\n    # Define the header row for the CSV file\n    header = (\n        \'rupid multiplicity mag centroid_lon centroid_lat \'\n        \'centroid_depth trt strike dip rake boundary\').split()\n\n    # Initialize an empty list to store the rupture rows\n    rows = []\n\n    # Iterate over each rupture getter object (gen_rupture_getters)\n    for rgetter in gen_rupture_getters(dstore):\n        # Get the ruptures from the generator\n        rups = rgetter.get_ruptures()\n\n        # Create a RuptureData object with the relevant parameters\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\n\n        # Iterate over each rupture in the data\n        for r in rup_data.to_array(rups):\n            # Append the row to the list of rows\n            rows.append(\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\n                 r[\'boundary\']))\n\n    # Sort the rows by rupture serial\n    rows.sort()\n\n    # Define a comment to include in the CSV file header\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\n        oq.investigation_time, oq.ses_per_logic_tree_path)\n\n    # Write the CSV file using the writers module\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\n    \n    # Return a list containing the destination filename and path\n    return [dest]\n```', 'origin_doc': ':param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L223-L235', 'func_name': 'export_hmaps_csv', 'language': 'python', 'input_code': 'def export_hmaps_csv(key, dest, sitemesh, array, comment):\r\n    """"""\r\n    Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file\r\n    """"""\r\n    curves = util.compose_arrays(sitemesh, array)\r\n    writers.write_csv(dest, curves, comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hmaps_csv(\n    key: str,\n    dest: str,\n    sitemesh: str,\n    array: ""composite_array"",\n    comment: str = """"\n) -> list:\n    """"""\n    Export the hazard maps of the given realization into CSV.\n\n    This function generates a CSV file containing the hazard maps for the specified\n    realization, written by the HMP library. The hazard maps are composed from a given\n    composite array and exported to a specific destination file with an optional comment.\n\n    :param key: Output type and export type (string)\n    :param dest: Name of the exported CSV file (string)\n    :param sitemesh: Site collection (string)\n    :param array: Composite array of dtype hmap_dt\n    :param comment: Comment to use as header of the exported CSV file (string, optional)\n    :return: List containing the name of the exported CSV file\n    """"""\n\n    # Curves are generated from the site collection and composite array using util.compose_arrays\n    curves = util.compose_arrays(sitemesh, array)\n\n    # The hazard maps are written to a CSV file using writers.write_csv\n    writers.write_csv(dest, curves, comment=comment)\n\n    # Return a list containing the name of the exported CSV file\n    return [dest]\n```', 'origin_doc': 'Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L238-L245', 'func_name': 'add_imt', 'language': 'python', 'input_code': 'def add_imt(fname, imt):\r\n    """"""\r\n    >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\r\n    \'/path/to/hcurve-SA(0.1)_23.csv\'\r\n    """"""\r\n    name = os.path.basename(fname)\r\n    newname = re.sub(r\'(_\\d+\\.)\', \'-%s\\\\1\' % imt, name)\r\n    return os.path.join(os.path.dirname(fname), newname)', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef add_imt(fname: str, imt: str) -> str:\n    """"""\n    Adds a suffix to the given file name in the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Args:\n        fname (str): The base filename with extension.\n        imt (str): The IMT suffix to be appended.\n\n    Returns:\n        str: The new filename with the appended suffix.\n\n    Raises:\n        ValueError: If the file name does not match the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Example:\n        >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\n        \'/path/to/hcurve-SA(0.1)_23.csv\'\n    """"""\n```\n\nNote: I\'ve added type hints for `fname` and `imt`, followed by a brief description of what each parameter represents, as well as the return value. The docstring also includes an example use case to help illustrate how to call the function.', 'origin_doc': "">>> add_imt('/path/to/hcurve_23.csv', 'SA(0.1)')\r\n    '/path/to/hcurve-SA(0.1)_23.csv'""}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L248-L277', 'func_name': 'export_hcurves_by_imt_csv', 'language': 'python', 'input_code': 'def export_hcurves_by_imt_csv(\r\n        key, kind, rlzs_assoc, fname, sitecol, array, oq, checksum):\r\n    """"""\r\n    Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters\r\n    """"""\r\n    nsites = len(sitecol)\r\n    fnames = []\r\n    for imt, imls in oq.imtls.items():\r\n        slc = oq.imtls(imt)\r\n        dest = add_imt(fname, imt)\r\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\r\n        for iml in imls:\r\n            lst.append((\'poe-%s\' % iml, F32))\r\n        hcurves = numpy.zeros(nsites, lst)\r\n        for sid, lon, lat, dep in zip(\r\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\r\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\r\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\r\n            rlzs_assoc, kind, oq.investigation_time) + (\r\n                \', imt=""%s"", checksum=%d\' % (imt, checksum)\r\n            ), header=[name for (name, dt) in lst]))\r\n    return fnames', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hcurves_by_imt_csv(\n        key: str, kind: str, rlzs_assoc: object, fname: str, sitecol: object, array: numpy.ndarray,\n        oq: dict) -> list:\n    """"""\n    Export the curves of the given realization into CSV.\n\n    Parameters\n    ----------\n    key : str\n        output_type and export type\n\n    kind : str\n        a string with the kind of output (realization or statistics)\n\n    rlzs_assoc : object\n        an instance of openquake.commonlib.source.RlzsAssoc, containing associated realizations\n\n    fname : str\n        name of the exported file\n\n    sitecol : object\n        site collection\n\n    array : numpy.ndarray, shape (N, L) and dtype numpy.float32\n        an array representing the depths of the given realization\n\n    oq : dict\n        job.ini parameters\n\n    Returns\n    -------\n    list\n        a list of filenames for each exported curve CSV file\n\n    Raises\n    ------\n    TypeError\n        if rlzs_assoc is not an instance of openquake.commonlib.source.RlzsAssoc, or if oq.imtls is empty\n    ValueError\n        if any(imt not in oq.imtls for imt in rlzs_assoc.get(\'imts\', []))\n    """"""\n\n    # Calculate the number of sites and filenames needed for each exported curve CSV file\n    nsites = len(sitecol)\n    fnames = []\n    for imt, imls in oq.imtls.items():\n        # Get the associated realizations\n        slc = oq.imtls(imt)\n        dest = add_imt(fname, imt)\n\n        # Prepare a list of columns for the CSV file\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\n\n        # Add information about each point on the curve to the CSV file\n        for iml in imls:\n            lst.append((\'poe-%s\' % iml, F32))\n\n        # Create an array of shape (nsites, 3) containing the coordinates and depths of each point on the curve\n        hcurves = numpy.zeros(nsites, lst)\n\n        # Add information about each point on the curve to the CSV file\n        for sid, lon, lat, dep in zip(\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\n\n        # Write each CSV file with the exported data\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\n            rlzs_assoc, kind, oq.investigation_time) + ("" imt=""%s"", checksum=%d"" % (imt, checksum)), header=[name for (name, dt) in lst])))\n\n    return fnames\n```', 'origin_doc': 'Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L280-L294', 'func_name': 'hazard_curve_name', 'language': 'python', 'input_code': 'def hazard_curve_name(dstore, ekey, kind, rlzs_assoc):\r\n    """"""\r\n    :param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance\r\n    """"""\r\n    key, fmt = ekey\r\n    prefix = {\'hcurves\': \'hazard_curve\', \'hmaps\': \'hazard_map\',\r\n              \'uhs\': \'hazard_uhs\'}[key]\r\n    if kind.startswith(\'quantile-\'):  # strip the 7 characters \'hazard_\'\r\n        fname = dstore.build_fname(\'quantile_\' + prefix[7:], kind[9:], fmt)\r\n    else:\r\n        fname = dstore.build_fname(prefix, kind, fmt)\r\n    return fname', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef hazard_curve_name(dstore: object, ekey: str, kind: str, rlzs_assoc: object) -> str:\n    """"""\n    Generates the name of a hazard curve based on the export key and kind.\n\n    This function takes in three arguments: `calc_id`, `ekey`, `kind`, and `rlzs_assoc`.\n    It returns the formatted file name for the hazard curve.\n\n    Args:\n        dstore (object): The database store instance to use for building file names.\n        ekey (str): The export key associated with the hazard curve.\n        kind (str): The type of key that corresponds to the hazard curve.\n        rlzs_assoc (object): A RlzsAssoc instance representing the association.\n\n    Returns:\n        str: The formatted file name for the hazard curve.\n\n    Raises:\n        None\n\n    Example:\n        >>> import numpy as np\n        >>> from rlm.utils import hazard_curve_name\n        >>> dstore = ...  # Initialize database store instance\n        >>> ekey = \'hcurves/quantile/hazard_7\'\n        >>> kind = \'quantile\'\n        >>> rlzs_assoc = ...  # Initialize RlzsAssoc instance\n        >>> hazard_curve_name(dstore, ekey, kind, rlzs_assoc)\n        \'/path/to/file_name.hazard_curve\'\n    """"""\n```\n\nThis docstring uses Google-style formatting for consistency and readability. It includes a one-line summary of what the function does, as well as clear and concise information about each argument, return value, and any applicable exceptions. The example demonstrates how to use the function with sample arguments.', 'origin_doc': ':param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance'}]","```python
def export_hmaps_csv(
    key: str,
    dest: str,
    sitemesh: str,
    array: ""composite_array"",
    comment: str = """"
) -> list:
    """"""
    Export the hazard maps of the given realization into CSV.

    This function generates a CSV file containing the hazard maps for the specified
    realization, written by the HMP library. The hazard maps are composed from a given
    composite array and exported to a specific destination file with an optional comment.

    :param key: Output type and export type (string)
    :param dest: Name of the exported CSV file (string)
    :param sitemesh: Site collection (string)
    :param array: Composite array of dtype hmap_dt
    :param comment: Comment to use as header of the exported CSV file (string, optional)
    :return: List containing the name of the exported CSV file
    """"""

    # Curves are generated from the site collection and composite array using util.compose_arrays
    curves = util.compose_arrays(sitemesh, array)

    # The hazard maps are written to a CSV file using writers.write_csv
    writers.write_csv(dest, curves, comment=comment)

    # Return a list containing the name of the exported CSV file
    return [dest]
```","Export the hazard maps of the given realization into CSV.

    :param key: output_type and export_type
    :param dest: name of the exported file
    :param sitemesh: site collection
    :param array: a composite array of dtype hmap_dt
    :param comment: comment to use as header of the exported CSV file"
sample.csv,gem/oq-engine,https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L238-L245,add_imt,python,"def add_imt(fname, imt):
    """"""
    >>> add_imt('/path/to/hcurve_23.csv', 'SA(0.1)')
    '/path/to/hcurve-SA(0.1)_23.csv'
    """"""
    name = os.path.basename(fname)
    newname = re.sub(r'(_\d+\.)', '-%s\\1' % imt, name)
    return os.path.join(os.path.dirname(fname), newname)",llama3.2:1b,"[{'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L81-L106', 'func_name': 'export_ruptures_csv', 'language': 'python', 'input_code': 'def export_ruptures_csv(ekey, dstore):\r\n    """"""\r\n    :param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object\r\n    """"""\r\n    oq = dstore[\'oqparam\']\r\n    if \'scenario\' in oq.calculation_mode:\r\n        return []\r\n    dest = dstore.export_path(\'ruptures.csv\')\r\n    header = (\'rupid multiplicity mag centroid_lon centroid_lat \'\r\n              \'centroid_depth trt strike dip rake boundary\').split()\r\n    rows = []\r\n    for rgetter in gen_rupture_getters(dstore):\r\n        rups = rgetter.get_ruptures()\r\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\r\n        for r in rup_data.to_array(rups):\r\n            rows.append(\r\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\r\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\r\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\r\n                 r[\'boundary\']))\r\n    rows.sort()  # by rupture serial\r\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\r\n        oq.investigation_time, oq.ses_per_logic_tree_path)\r\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_ruptures_csv(ekey: tuple[int, str], dstore: \'DatastoreObjectStore\') -> list:\n    """"""\n    Generates a CSV file containing rupture data for the specified export key.\n\n    :param ekey: A pair (datastore key, fmt) representing the export key.\n    :param dstore: The datastore object to use for exporting ruptures.\n    :return: A list containing the destination filename and path of the exported CSV file.\n    """"""\n    # Get the oqparam calculation mode from the datastore\n    oq = dstore[\'oqparam\']\n\n    # If the calculation mode is in \'scenario\' mode, return an empty list\n    if \'scenario\' in oq.calculation_mode:\n        return []\n\n    # Set the export path for the CSV file\n    dest = dstore.export_path(\'ruptures.csv\')\n\n    # Define the header row for the CSV file\n    header = (\n        \'rupid multiplicity mag centroid_lon centroid_lat \'\n        \'centroid_depth trt strike dip rake boundary\').split()\n\n    # Initialize an empty list to store the rupture rows\n    rows = []\n\n    # Iterate over each rupture getter object (gen_rupture_getters)\n    for rgetter in gen_rupture_getters(dstore):\n        # Get the ruptures from the generator\n        rups = rgetter.get_ruptures()\n\n        # Create a RuptureData object with the relevant parameters\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\n\n        # Iterate over each rupture in the data\n        for r in rup_data.to_array(rups):\n            # Append the row to the list of rows\n            rows.append(\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\n                 r[\'boundary\']))\n\n    # Sort the rows by rupture serial\n    rows.sort()\n\n    # Define a comment to include in the CSV file header\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\n        oq.investigation_time, oq.ses_per_logic_tree_path)\n\n    # Write the CSV file using the writers module\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\n    \n    # Return a list containing the destination filename and path\n    return [dest]\n```', 'origin_doc': ':param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L223-L235', 'func_name': 'export_hmaps_csv', 'language': 'python', 'input_code': 'def export_hmaps_csv(key, dest, sitemesh, array, comment):\r\n    """"""\r\n    Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file\r\n    """"""\r\n    curves = util.compose_arrays(sitemesh, array)\r\n    writers.write_csv(dest, curves, comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hmaps_csv(\n    key: str,\n    dest: str,\n    sitemesh: str,\n    array: ""composite_array"",\n    comment: str = """"\n) -> list:\n    """"""\n    Export the hazard maps of the given realization into CSV.\n\n    This function generates a CSV file containing the hazard maps for the specified\n    realization, written by the HMP library. The hazard maps are composed from a given\n    composite array and exported to a specific destination file with an optional comment.\n\n    :param key: Output type and export type (string)\n    :param dest: Name of the exported CSV file (string)\n    :param sitemesh: Site collection (string)\n    :param array: Composite array of dtype hmap_dt\n    :param comment: Comment to use as header of the exported CSV file (string, optional)\n    :return: List containing the name of the exported CSV file\n    """"""\n\n    # Curves are generated from the site collection and composite array using util.compose_arrays\n    curves = util.compose_arrays(sitemesh, array)\n\n    # The hazard maps are written to a CSV file using writers.write_csv\n    writers.write_csv(dest, curves, comment=comment)\n\n    # Return a list containing the name of the exported CSV file\n    return [dest]\n```', 'origin_doc': 'Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L238-L245', 'func_name': 'add_imt', 'language': 'python', 'input_code': 'def add_imt(fname, imt):\r\n    """"""\r\n    >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\r\n    \'/path/to/hcurve-SA(0.1)_23.csv\'\r\n    """"""\r\n    name = os.path.basename(fname)\r\n    newname = re.sub(r\'(_\\d+\\.)\', \'-%s\\\\1\' % imt, name)\r\n    return os.path.join(os.path.dirname(fname), newname)', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef add_imt(fname: str, imt: str) -> str:\n    """"""\n    Adds a suffix to the given file name in the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Args:\n        fname (str): The base filename with extension.\n        imt (str): The IMT suffix to be appended.\n\n    Returns:\n        str: The new filename with the appended suffix.\n\n    Raises:\n        ValueError: If the file name does not match the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Example:\n        >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\n        \'/path/to/hcurve-SA(0.1)_23.csv\'\n    """"""\n```\n\nNote: I\'ve added type hints for `fname` and `imt`, followed by a brief description of what each parameter represents, as well as the return value. The docstring also includes an example use case to help illustrate how to call the function.', 'origin_doc': "">>> add_imt('/path/to/hcurve_23.csv', 'SA(0.1)')\r\n    '/path/to/hcurve-SA(0.1)_23.csv'""}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L248-L277', 'func_name': 'export_hcurves_by_imt_csv', 'language': 'python', 'input_code': 'def export_hcurves_by_imt_csv(\r\n        key, kind, rlzs_assoc, fname, sitecol, array, oq, checksum):\r\n    """"""\r\n    Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters\r\n    """"""\r\n    nsites = len(sitecol)\r\n    fnames = []\r\n    for imt, imls in oq.imtls.items():\r\n        slc = oq.imtls(imt)\r\n        dest = add_imt(fname, imt)\r\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\r\n        for iml in imls:\r\n            lst.append((\'poe-%s\' % iml, F32))\r\n        hcurves = numpy.zeros(nsites, lst)\r\n        for sid, lon, lat, dep in zip(\r\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\r\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\r\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\r\n            rlzs_assoc, kind, oq.investigation_time) + (\r\n                \', imt=""%s"", checksum=%d\' % (imt, checksum)\r\n            ), header=[name for (name, dt) in lst]))\r\n    return fnames', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hcurves_by_imt_csv(\n        key: str, kind: str, rlzs_assoc: object, fname: str, sitecol: object, array: numpy.ndarray,\n        oq: dict) -> list:\n    """"""\n    Export the curves of the given realization into CSV.\n\n    Parameters\n    ----------\n    key : str\n        output_type and export type\n\n    kind : str\n        a string with the kind of output (realization or statistics)\n\n    rlzs_assoc : object\n        an instance of openquake.commonlib.source.RlzsAssoc, containing associated realizations\n\n    fname : str\n        name of the exported file\n\n    sitecol : object\n        site collection\n\n    array : numpy.ndarray, shape (N, L) and dtype numpy.float32\n        an array representing the depths of the given realization\n\n    oq : dict\n        job.ini parameters\n\n    Returns\n    -------\n    list\n        a list of filenames for each exported curve CSV file\n\n    Raises\n    ------\n    TypeError\n        if rlzs_assoc is not an instance of openquake.commonlib.source.RlzsAssoc, or if oq.imtls is empty\n    ValueError\n        if any(imt not in oq.imtls for imt in rlzs_assoc.get(\'imts\', []))\n    """"""\n\n    # Calculate the number of sites and filenames needed for each exported curve CSV file\n    nsites = len(sitecol)\n    fnames = []\n    for imt, imls in oq.imtls.items():\n        # Get the associated realizations\n        slc = oq.imtls(imt)\n        dest = add_imt(fname, imt)\n\n        # Prepare a list of columns for the CSV file\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\n\n        # Add information about each point on the curve to the CSV file\n        for iml in imls:\n            lst.append((\'poe-%s\' % iml, F32))\n\n        # Create an array of shape (nsites, 3) containing the coordinates and depths of each point on the curve\n        hcurves = numpy.zeros(nsites, lst)\n\n        # Add information about each point on the curve to the CSV file\n        for sid, lon, lat, dep in zip(\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\n\n        # Write each CSV file with the exported data\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\n            rlzs_assoc, kind, oq.investigation_time) + ("" imt=""%s"", checksum=%d"" % (imt, checksum)), header=[name for (name, dt) in lst])))\n\n    return fnames\n```', 'origin_doc': 'Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L280-L294', 'func_name': 'hazard_curve_name', 'language': 'python', 'input_code': 'def hazard_curve_name(dstore, ekey, kind, rlzs_assoc):\r\n    """"""\r\n    :param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance\r\n    """"""\r\n    key, fmt = ekey\r\n    prefix = {\'hcurves\': \'hazard_curve\', \'hmaps\': \'hazard_map\',\r\n              \'uhs\': \'hazard_uhs\'}[key]\r\n    if kind.startswith(\'quantile-\'):  # strip the 7 characters \'hazard_\'\r\n        fname = dstore.build_fname(\'quantile_\' + prefix[7:], kind[9:], fmt)\r\n    else:\r\n        fname = dstore.build_fname(prefix, kind, fmt)\r\n    return fname', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef hazard_curve_name(dstore: object, ekey: str, kind: str, rlzs_assoc: object) -> str:\n    """"""\n    Generates the name of a hazard curve based on the export key and kind.\n\n    This function takes in three arguments: `calc_id`, `ekey`, `kind`, and `rlzs_assoc`.\n    It returns the formatted file name for the hazard curve.\n\n    Args:\n        dstore (object): The database store instance to use for building file names.\n        ekey (str): The export key associated with the hazard curve.\n        kind (str): The type of key that corresponds to the hazard curve.\n        rlzs_assoc (object): A RlzsAssoc instance representing the association.\n\n    Returns:\n        str: The formatted file name for the hazard curve.\n\n    Raises:\n        None\n\n    Example:\n        >>> import numpy as np\n        >>> from rlm.utils import hazard_curve_name\n        >>> dstore = ...  # Initialize database store instance\n        >>> ekey = \'hcurves/quantile/hazard_7\'\n        >>> kind = \'quantile\'\n        >>> rlzs_assoc = ...  # Initialize RlzsAssoc instance\n        >>> hazard_curve_name(dstore, ekey, kind, rlzs_assoc)\n        \'/path/to/file_name.hazard_curve\'\n    """"""\n```\n\nThis docstring uses Google-style formatting for consistency and readability. It includes a one-line summary of what the function does, as well as clear and concise information about each argument, return value, and any applicable exceptions. The example demonstrates how to use the function with sample arguments.', 'origin_doc': ':param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance'}]","```python
def add_imt(fname: str, imt: str) -> str:
    """"""
    Adds a suffix to the given file name in the format 'YYYYMMDD_Hcurve_XXX.csv'.

    Args:
        fname (str): The base filename with extension.
        imt (str): The IMT suffix to be appended.

    Returns:
        str: The new filename with the appended suffix.

    Raises:
        ValueError: If the file name does not match the format 'YYYYMMDD_Hcurve_XXX.csv'.

    Example:
        >>> add_imt('/path/to/hcurve_23.csv', 'SA(0.1)')
        '/path/to/hcurve-SA(0.1)_23.csv'
    """"""
```

Note: I've added type hints for `fname` and `imt`, followed by a brief description of what each parameter represents, as well as the return value. The docstring also includes an example use case to help illustrate how to call the function.",">>> add_imt('/path/to/hcurve_23.csv', 'SA(0.1)')
    '/path/to/hcurve-SA(0.1)_23.csv'"
sample.csv,gem/oq-engine,https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L248-L277,export_hcurves_by_imt_csv,python,"def export_hcurves_by_imt_csv(
        key, kind, rlzs_assoc, fname, sitecol, array, oq, checksum):
    """"""
    Export the curves of the given realization into CSV.

    :param key: output_type and export_type
    :param kind: a string with the kind of output (realization or statistics)
    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance
    :param fname: name of the exported file
    :param sitecol: site collection
    :param array: an array of shape (N, L) and dtype numpy.float32
    :param oq: job.ini parameters
    """"""
    nsites = len(sitecol)
    fnames = []
    for imt, imls in oq.imtls.items():
        slc = oq.imtls(imt)
        dest = add_imt(fname, imt)
        lst = [('lon', F32), ('lat', F32), ('depth', F32)]
        for iml in imls:
            lst.append(('poe-%s' % iml, F32))
        hcurves = numpy.zeros(nsites, lst)
        for sid, lon, lat, dep in zip(
                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):
            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])
        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(
            rlzs_assoc, kind, oq.investigation_time) + (
                ', imt=""%s"", checksum=%d' % (imt, checksum)
            ), header=[name for (name, dt) in lst]))
    return fnames",llama3.2:1b,"[{'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L81-L106', 'func_name': 'export_ruptures_csv', 'language': 'python', 'input_code': 'def export_ruptures_csv(ekey, dstore):\r\n    """"""\r\n    :param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object\r\n    """"""\r\n    oq = dstore[\'oqparam\']\r\n    if \'scenario\' in oq.calculation_mode:\r\n        return []\r\n    dest = dstore.export_path(\'ruptures.csv\')\r\n    header = (\'rupid multiplicity mag centroid_lon centroid_lat \'\r\n              \'centroid_depth trt strike dip rake boundary\').split()\r\n    rows = []\r\n    for rgetter in gen_rupture_getters(dstore):\r\n        rups = rgetter.get_ruptures()\r\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\r\n        for r in rup_data.to_array(rups):\r\n            rows.append(\r\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\r\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\r\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\r\n                 r[\'boundary\']))\r\n    rows.sort()  # by rupture serial\r\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\r\n        oq.investigation_time, oq.ses_per_logic_tree_path)\r\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_ruptures_csv(ekey: tuple[int, str], dstore: \'DatastoreObjectStore\') -> list:\n    """"""\n    Generates a CSV file containing rupture data for the specified export key.\n\n    :param ekey: A pair (datastore key, fmt) representing the export key.\n    :param dstore: The datastore object to use for exporting ruptures.\n    :return: A list containing the destination filename and path of the exported CSV file.\n    """"""\n    # Get the oqparam calculation mode from the datastore\n    oq = dstore[\'oqparam\']\n\n    # If the calculation mode is in \'scenario\' mode, return an empty list\n    if \'scenario\' in oq.calculation_mode:\n        return []\n\n    # Set the export path for the CSV file\n    dest = dstore.export_path(\'ruptures.csv\')\n\n    # Define the header row for the CSV file\n    header = (\n        \'rupid multiplicity mag centroid_lon centroid_lat \'\n        \'centroid_depth trt strike dip rake boundary\').split()\n\n    # Initialize an empty list to store the rupture rows\n    rows = []\n\n    # Iterate over each rupture getter object (gen_rupture_getters)\n    for rgetter in gen_rupture_getters(dstore):\n        # Get the ruptures from the generator\n        rups = rgetter.get_ruptures()\n\n        # Create a RuptureData object with the relevant parameters\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\n\n        # Iterate over each rupture in the data\n        for r in rup_data.to_array(rups):\n            # Append the row to the list of rows\n            rows.append(\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\n                 r[\'boundary\']))\n\n    # Sort the rows by rupture serial\n    rows.sort()\n\n    # Define a comment to include in the CSV file header\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\n        oq.investigation_time, oq.ses_per_logic_tree_path)\n\n    # Write the CSV file using the writers module\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\n    \n    # Return a list containing the destination filename and path\n    return [dest]\n```', 'origin_doc': ':param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L223-L235', 'func_name': 'export_hmaps_csv', 'language': 'python', 'input_code': 'def export_hmaps_csv(key, dest, sitemesh, array, comment):\r\n    """"""\r\n    Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file\r\n    """"""\r\n    curves = util.compose_arrays(sitemesh, array)\r\n    writers.write_csv(dest, curves, comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hmaps_csv(\n    key: str,\n    dest: str,\n    sitemesh: str,\n    array: ""composite_array"",\n    comment: str = """"\n) -> list:\n    """"""\n    Export the hazard maps of the given realization into CSV.\n\n    This function generates a CSV file containing the hazard maps for the specified\n    realization, written by the HMP library. The hazard maps are composed from a given\n    composite array and exported to a specific destination file with an optional comment.\n\n    :param key: Output type and export type (string)\n    :param dest: Name of the exported CSV file (string)\n    :param sitemesh: Site collection (string)\n    :param array: Composite array of dtype hmap_dt\n    :param comment: Comment to use as header of the exported CSV file (string, optional)\n    :return: List containing the name of the exported CSV file\n    """"""\n\n    # Curves are generated from the site collection and composite array using util.compose_arrays\n    curves = util.compose_arrays(sitemesh, array)\n\n    # The hazard maps are written to a CSV file using writers.write_csv\n    writers.write_csv(dest, curves, comment=comment)\n\n    # Return a list containing the name of the exported CSV file\n    return [dest]\n```', 'origin_doc': 'Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L238-L245', 'func_name': 'add_imt', 'language': 'python', 'input_code': 'def add_imt(fname, imt):\r\n    """"""\r\n    >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\r\n    \'/path/to/hcurve-SA(0.1)_23.csv\'\r\n    """"""\r\n    name = os.path.basename(fname)\r\n    newname = re.sub(r\'(_\\d+\\.)\', \'-%s\\\\1\' % imt, name)\r\n    return os.path.join(os.path.dirname(fname), newname)', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef add_imt(fname: str, imt: str) -> str:\n    """"""\n    Adds a suffix to the given file name in the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Args:\n        fname (str): The base filename with extension.\n        imt (str): The IMT suffix to be appended.\n\n    Returns:\n        str: The new filename with the appended suffix.\n\n    Raises:\n        ValueError: If the file name does not match the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Example:\n        >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\n        \'/path/to/hcurve-SA(0.1)_23.csv\'\n    """"""\n```\n\nNote: I\'ve added type hints for `fname` and `imt`, followed by a brief description of what each parameter represents, as well as the return value. The docstring also includes an example use case to help illustrate how to call the function.', 'origin_doc': "">>> add_imt('/path/to/hcurve_23.csv', 'SA(0.1)')\r\n    '/path/to/hcurve-SA(0.1)_23.csv'""}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L248-L277', 'func_name': 'export_hcurves_by_imt_csv', 'language': 'python', 'input_code': 'def export_hcurves_by_imt_csv(\r\n        key, kind, rlzs_assoc, fname, sitecol, array, oq, checksum):\r\n    """"""\r\n    Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters\r\n    """"""\r\n    nsites = len(sitecol)\r\n    fnames = []\r\n    for imt, imls in oq.imtls.items():\r\n        slc = oq.imtls(imt)\r\n        dest = add_imt(fname, imt)\r\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\r\n        for iml in imls:\r\n            lst.append((\'poe-%s\' % iml, F32))\r\n        hcurves = numpy.zeros(nsites, lst)\r\n        for sid, lon, lat, dep in zip(\r\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\r\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\r\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\r\n            rlzs_assoc, kind, oq.investigation_time) + (\r\n                \', imt=""%s"", checksum=%d\' % (imt, checksum)\r\n            ), header=[name for (name, dt) in lst]))\r\n    return fnames', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hcurves_by_imt_csv(\n        key: str, kind: str, rlzs_assoc: object, fname: str, sitecol: object, array: numpy.ndarray,\n        oq: dict) -> list:\n    """"""\n    Export the curves of the given realization into CSV.\n\n    Parameters\n    ----------\n    key : str\n        output_type and export type\n\n    kind : str\n        a string with the kind of output (realization or statistics)\n\n    rlzs_assoc : object\n        an instance of openquake.commonlib.source.RlzsAssoc, containing associated realizations\n\n    fname : str\n        name of the exported file\n\n    sitecol : object\n        site collection\n\n    array : numpy.ndarray, shape (N, L) and dtype numpy.float32\n        an array representing the depths of the given realization\n\n    oq : dict\n        job.ini parameters\n\n    Returns\n    -------\n    list\n        a list of filenames for each exported curve CSV file\n\n    Raises\n    ------\n    TypeError\n        if rlzs_assoc is not an instance of openquake.commonlib.source.RlzsAssoc, or if oq.imtls is empty\n    ValueError\n        if any(imt not in oq.imtls for imt in rlzs_assoc.get(\'imts\', []))\n    """"""\n\n    # Calculate the number of sites and filenames needed for each exported curve CSV file\n    nsites = len(sitecol)\n    fnames = []\n    for imt, imls in oq.imtls.items():\n        # Get the associated realizations\n        slc = oq.imtls(imt)\n        dest = add_imt(fname, imt)\n\n        # Prepare a list of columns for the CSV file\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\n\n        # Add information about each point on the curve to the CSV file\n        for iml in imls:\n            lst.append((\'poe-%s\' % iml, F32))\n\n        # Create an array of shape (nsites, 3) containing the coordinates and depths of each point on the curve\n        hcurves = numpy.zeros(nsites, lst)\n\n        # Add information about each point on the curve to the CSV file\n        for sid, lon, lat, dep in zip(\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\n\n        # Write each CSV file with the exported data\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\n            rlzs_assoc, kind, oq.investigation_time) + ("" imt=""%s"", checksum=%d"" % (imt, checksum)), header=[name for (name, dt) in lst])))\n\n    return fnames\n```', 'origin_doc': 'Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L280-L294', 'func_name': 'hazard_curve_name', 'language': 'python', 'input_code': 'def hazard_curve_name(dstore, ekey, kind, rlzs_assoc):\r\n    """"""\r\n    :param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance\r\n    """"""\r\n    key, fmt = ekey\r\n    prefix = {\'hcurves\': \'hazard_curve\', \'hmaps\': \'hazard_map\',\r\n              \'uhs\': \'hazard_uhs\'}[key]\r\n    if kind.startswith(\'quantile-\'):  # strip the 7 characters \'hazard_\'\r\n        fname = dstore.build_fname(\'quantile_\' + prefix[7:], kind[9:], fmt)\r\n    else:\r\n        fname = dstore.build_fname(prefix, kind, fmt)\r\n    return fname', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef hazard_curve_name(dstore: object, ekey: str, kind: str, rlzs_assoc: object) -> str:\n    """"""\n    Generates the name of a hazard curve based on the export key and kind.\n\n    This function takes in three arguments: `calc_id`, `ekey`, `kind`, and `rlzs_assoc`.\n    It returns the formatted file name for the hazard curve.\n\n    Args:\n        dstore (object): The database store instance to use for building file names.\n        ekey (str): The export key associated with the hazard curve.\n        kind (str): The type of key that corresponds to the hazard curve.\n        rlzs_assoc (object): A RlzsAssoc instance representing the association.\n\n    Returns:\n        str: The formatted file name for the hazard curve.\n\n    Raises:\n        None\n\n    Example:\n        >>> import numpy as np\n        >>> from rlm.utils import hazard_curve_name\n        >>> dstore = ...  # Initialize database store instance\n        >>> ekey = \'hcurves/quantile/hazard_7\'\n        >>> kind = \'quantile\'\n        >>> rlzs_assoc = ...  # Initialize RlzsAssoc instance\n        >>> hazard_curve_name(dstore, ekey, kind, rlzs_assoc)\n        \'/path/to/file_name.hazard_curve\'\n    """"""\n```\n\nThis docstring uses Google-style formatting for consistency and readability. It includes a one-line summary of what the function does, as well as clear and concise information about each argument, return value, and any applicable exceptions. The example demonstrates how to use the function with sample arguments.', 'origin_doc': ':param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance'}]","```python
def export_hcurves_by_imt_csv(
        key: str, kind: str, rlzs_assoc: object, fname: str, sitecol: object, array: numpy.ndarray,
        oq: dict) -> list:
    """"""
    Export the curves of the given realization into CSV.

    Parameters
    ----------
    key : str
        output_type and export type

    kind : str
        a string with the kind of output (realization or statistics)

    rlzs_assoc : object
        an instance of openquake.commonlib.source.RlzsAssoc, containing associated realizations

    fname : str
        name of the exported file

    sitecol : object
        site collection

    array : numpy.ndarray, shape (N, L) and dtype numpy.float32
        an array representing the depths of the given realization

    oq : dict
        job.ini parameters

    Returns
    -------
    list
        a list of filenames for each exported curve CSV file

    Raises
    ------
    TypeError
        if rlzs_assoc is not an instance of openquake.commonlib.source.RlzsAssoc, or if oq.imtls is empty
    ValueError
        if any(imt not in oq.imtls for imt in rlzs_assoc.get('imts', []))
    """"""

    # Calculate the number of sites and filenames needed for each exported curve CSV file
    nsites = len(sitecol)
    fnames = []
    for imt, imls in oq.imtls.items():
        # Get the associated realizations
        slc = oq.imtls(imt)
        dest = add_imt(fname, imt)

        # Prepare a list of columns for the CSV file
        lst = [('lon', F32), ('lat', F32), ('depth', F32)]

        # Add information about each point on the curve to the CSV file
        for iml in imls:
            lst.append(('poe-%s' % iml, F32))

        # Create an array of shape (nsites, 3) containing the coordinates and depths of each point on the curve
        hcurves = numpy.zeros(nsites, lst)

        # Add information about each point on the curve to the CSV file
        for sid, lon, lat, dep in zip(
                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):
            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])

        # Write each CSV file with the exported data
        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(
            rlzs_assoc, kind, oq.investigation_time) + ("" imt=""%s"", checksum=%d"" % (imt, checksum)), header=[name for (name, dt) in lst])))

    return fnames
```","Export the curves of the given realization into CSV.

    :param key: output_type and export_type
    :param kind: a string with the kind of output (realization or statistics)
    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance
    :param fname: name of the exported file
    :param sitecol: site collection
    :param array: an array of shape (N, L) and dtype numpy.float32
    :param oq: job.ini parameters"
sample.csv,gem/oq-engine,https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L280-L294,hazard_curve_name,python,"def hazard_curve_name(dstore, ekey, kind, rlzs_assoc):
    """"""
    :param calc_id: the calculation ID
    :param ekey: the export key
    :param kind: the kind of key
    :param rlzs_assoc: a RlzsAssoc instance
    """"""
    key, fmt = ekey
    prefix = {'hcurves': 'hazard_curve', 'hmaps': 'hazard_map',
              'uhs': 'hazard_uhs'}[key]
    if kind.startswith('quantile-'):  # strip the 7 characters 'hazard_'
        fname = dstore.build_fname('quantile_' + prefix[7:], kind[9:], fmt)
    else:
        fname = dstore.build_fname(prefix, kind, fmt)
    return fname",llama3.2:1b,"[{'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L81-L106', 'func_name': 'export_ruptures_csv', 'language': 'python', 'input_code': 'def export_ruptures_csv(ekey, dstore):\r\n    """"""\r\n    :param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object\r\n    """"""\r\n    oq = dstore[\'oqparam\']\r\n    if \'scenario\' in oq.calculation_mode:\r\n        return []\r\n    dest = dstore.export_path(\'ruptures.csv\')\r\n    header = (\'rupid multiplicity mag centroid_lon centroid_lat \'\r\n              \'centroid_depth trt strike dip rake boundary\').split()\r\n    rows = []\r\n    for rgetter in gen_rupture_getters(dstore):\r\n        rups = rgetter.get_ruptures()\r\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\r\n        for r in rup_data.to_array(rups):\r\n            rows.append(\r\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\r\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\r\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\r\n                 r[\'boundary\']))\r\n    rows.sort()  # by rupture serial\r\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\r\n        oq.investigation_time, oq.ses_per_logic_tree_path)\r\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_ruptures_csv(ekey: tuple[int, str], dstore: \'DatastoreObjectStore\') -> list:\n    """"""\n    Generates a CSV file containing rupture data for the specified export key.\n\n    :param ekey: A pair (datastore key, fmt) representing the export key.\n    :param dstore: The datastore object to use for exporting ruptures.\n    :return: A list containing the destination filename and path of the exported CSV file.\n    """"""\n    # Get the oqparam calculation mode from the datastore\n    oq = dstore[\'oqparam\']\n\n    # If the calculation mode is in \'scenario\' mode, return an empty list\n    if \'scenario\' in oq.calculation_mode:\n        return []\n\n    # Set the export path for the CSV file\n    dest = dstore.export_path(\'ruptures.csv\')\n\n    # Define the header row for the CSV file\n    header = (\n        \'rupid multiplicity mag centroid_lon centroid_lat \'\n        \'centroid_depth trt strike dip rake boundary\').split()\n\n    # Initialize an empty list to store the rupture rows\n    rows = []\n\n    # Iterate over each rupture getter object (gen_rupture_getters)\n    for rgetter in gen_rupture_getters(dstore):\n        # Get the ruptures from the generator\n        rups = rgetter.get_ruptures()\n\n        # Create a RuptureData object with the relevant parameters\n        rup_data = calc.RuptureData(rgetter.trt, rgetter.rlzs_by_gsim)\n\n        # Iterate over each rupture in the data\n        for r in rup_data.to_array(rups):\n            # Append the row to the list of rows\n            rows.append(\n                (r[\'rup_id\'], r[\'multiplicity\'], r[\'mag\'],\n                 r[\'lon\'], r[\'lat\'], r[\'depth\'],\n                 rgetter.trt, r[\'strike\'], r[\'dip\'], r[\'rake\'],\n                 r[\'boundary\']))\n\n    # Sort the rows by rupture serial\n    rows.sort()\n\n    # Define a comment to include in the CSV file header\n    comment = \'investigation_time=%s, ses_per_logic_tree_path=%s\' % (\n        oq.investigation_time, oq.ses_per_logic_tree_path)\n\n    # Write the CSV file using the writers module\n    writers.write_csv(dest, rows, header=header, sep=\'\\t\', comment=comment)\n    \n    # Return a list containing the destination filename and path\n    return [dest]\n```', 'origin_doc': ':param ekey: export key, i.e. a pair (datastore key, fmt)\r\n    :param dstore: datastore object'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L223-L235', 'func_name': 'export_hmaps_csv', 'language': 'python', 'input_code': 'def export_hmaps_csv(key, dest, sitemesh, array, comment):\r\n    """"""\r\n    Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file\r\n    """"""\r\n    curves = util.compose_arrays(sitemesh, array)\r\n    writers.write_csv(dest, curves, comment=comment)\r\n    return [dest]', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hmaps_csv(\n    key: str,\n    dest: str,\n    sitemesh: str,\n    array: ""composite_array"",\n    comment: str = """"\n) -> list:\n    """"""\n    Export the hazard maps of the given realization into CSV.\n\n    This function generates a CSV file containing the hazard maps for the specified\n    realization, written by the HMP library. The hazard maps are composed from a given\n    composite array and exported to a specific destination file with an optional comment.\n\n    :param key: Output type and export type (string)\n    :param dest: Name of the exported CSV file (string)\n    :param sitemesh: Site collection (string)\n    :param array: Composite array of dtype hmap_dt\n    :param comment: Comment to use as header of the exported CSV file (string, optional)\n    :return: List containing the name of the exported CSV file\n    """"""\n\n    # Curves are generated from the site collection and composite array using util.compose_arrays\n    curves = util.compose_arrays(sitemesh, array)\n\n    # The hazard maps are written to a CSV file using writers.write_csv\n    writers.write_csv(dest, curves, comment=comment)\n\n    # Return a list containing the name of the exported CSV file\n    return [dest]\n```', 'origin_doc': 'Export the hazard maps of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param dest: name of the exported file\r\n    :param sitemesh: site collection\r\n    :param array: a composite array of dtype hmap_dt\r\n    :param comment: comment to use as header of the exported CSV file'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L238-L245', 'func_name': 'add_imt', 'language': 'python', 'input_code': 'def add_imt(fname, imt):\r\n    """"""\r\n    >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\r\n    \'/path/to/hcurve-SA(0.1)_23.csv\'\r\n    """"""\r\n    name = os.path.basename(fname)\r\n    newname = re.sub(r\'(_\\d+\\.)\', \'-%s\\\\1\' % imt, name)\r\n    return os.path.join(os.path.dirname(fname), newname)', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef add_imt(fname: str, imt: str) -> str:\n    """"""\n    Adds a suffix to the given file name in the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Args:\n        fname (str): The base filename with extension.\n        imt (str): The IMT suffix to be appended.\n\n    Returns:\n        str: The new filename with the appended suffix.\n\n    Raises:\n        ValueError: If the file name does not match the format \'YYYYMMDD_Hcurve_XXX.csv\'.\n\n    Example:\n        >>> add_imt(\'/path/to/hcurve_23.csv\', \'SA(0.1)\')\n        \'/path/to/hcurve-SA(0.1)_23.csv\'\n    """"""\n```\n\nNote: I\'ve added type hints for `fname` and `imt`, followed by a brief description of what each parameter represents, as well as the return value. The docstring also includes an example use case to help illustrate how to call the function.', 'origin_doc': "">>> add_imt('/path/to/hcurve_23.csv', 'SA(0.1)')\r\n    '/path/to/hcurve-SA(0.1)_23.csv'""}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L248-L277', 'func_name': 'export_hcurves_by_imt_csv', 'language': 'python', 'input_code': 'def export_hcurves_by_imt_csv(\r\n        key, kind, rlzs_assoc, fname, sitecol, array, oq, checksum):\r\n    """"""\r\n    Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters\r\n    """"""\r\n    nsites = len(sitecol)\r\n    fnames = []\r\n    for imt, imls in oq.imtls.items():\r\n        slc = oq.imtls(imt)\r\n        dest = add_imt(fname, imt)\r\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\r\n        for iml in imls:\r\n            lst.append((\'poe-%s\' % iml, F32))\r\n        hcurves = numpy.zeros(nsites, lst)\r\n        for sid, lon, lat, dep in zip(\r\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\r\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\r\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\r\n            rlzs_assoc, kind, oq.investigation_time) + (\r\n                \', imt=""%s"", checksum=%d\' % (imt, checksum)\r\n            ), header=[name for (name, dt) in lst]))\r\n    return fnames', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef export_hcurves_by_imt_csv(\n        key: str, kind: str, rlzs_assoc: object, fname: str, sitecol: object, array: numpy.ndarray,\n        oq: dict) -> list:\n    """"""\n    Export the curves of the given realization into CSV.\n\n    Parameters\n    ----------\n    key : str\n        output_type and export type\n\n    kind : str\n        a string with the kind of output (realization or statistics)\n\n    rlzs_assoc : object\n        an instance of openquake.commonlib.source.RlzsAssoc, containing associated realizations\n\n    fname : str\n        name of the exported file\n\n    sitecol : object\n        site collection\n\n    array : numpy.ndarray, shape (N, L) and dtype numpy.float32\n        an array representing the depths of the given realization\n\n    oq : dict\n        job.ini parameters\n\n    Returns\n    -------\n    list\n        a list of filenames for each exported curve CSV file\n\n    Raises\n    ------\n    TypeError\n        if rlzs_assoc is not an instance of openquake.commonlib.source.RlzsAssoc, or if oq.imtls is empty\n    ValueError\n        if any(imt not in oq.imtls for imt in rlzs_assoc.get(\'imts\', []))\n    """"""\n\n    # Calculate the number of sites and filenames needed for each exported curve CSV file\n    nsites = len(sitecol)\n    fnames = []\n    for imt, imls in oq.imtls.items():\n        # Get the associated realizations\n        slc = oq.imtls(imt)\n        dest = add_imt(fname, imt)\n\n        # Prepare a list of columns for the CSV file\n        lst = [(\'lon\', F32), (\'lat\', F32), (\'depth\', F32)]\n\n        # Add information about each point on the curve to the CSV file\n        for iml in imls:\n            lst.append((\'poe-%s\' % iml, F32))\n\n        # Create an array of shape (nsites, 3) containing the coordinates and depths of each point on the curve\n        hcurves = numpy.zeros(nsites, lst)\n\n        # Add information about each point on the curve to the CSV file\n        for sid, lon, lat, dep in zip(\n                range(nsites), sitecol.lons, sitecol.lats, sitecol.depths):\n            hcurves[sid] = (lon, lat, dep) + tuple(array[sid, slc])\n\n        # Write each CSV file with the exported data\n        fnames.append(writers.write_csv(dest, hcurves, comment=_comment(\n            rlzs_assoc, kind, oq.investigation_time) + ("" imt=""%s"", checksum=%d"" % (imt, checksum)), header=[name for (name, dt) in lst])))\n\n    return fnames\n```', 'origin_doc': 'Export the curves of the given realization into CSV.\r\n\r\n    :param key: output_type and export_type\r\n    :param kind: a string with the kind of output (realization or statistics)\r\n    :param rlzs_assoc: a :class:`openquake.commonlib.source.RlzsAssoc` instance\r\n    :param fname: name of the exported file\r\n    :param sitecol: site collection\r\n    :param array: an array of shape (N, L) and dtype numpy.float32\r\n    :param oq: job.ini parameters'}, {'filename': 'sample.csv', 'repo': 'gem/oq-engine', 'file_url': 'https://github.com/gem/oq-engine/blob/8294553a0b8aba33fd96437a35065d03547d0040/openquake/calculators/export/hazard.py#L280-L294', 'func_name': 'hazard_curve_name', 'language': 'python', 'input_code': 'def hazard_curve_name(dstore, ekey, kind, rlzs_assoc):\r\n    """"""\r\n    :param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance\r\n    """"""\r\n    key, fmt = ekey\r\n    prefix = {\'hcurves\': \'hazard_curve\', \'hmaps\': \'hazard_map\',\r\n              \'uhs\': \'hazard_uhs\'}[key]\r\n    if kind.startswith(\'quantile-\'):  # strip the 7 characters \'hazard_\'\r\n        fname = dstore.build_fname(\'quantile_\' + prefix[7:], kind[9:], fmt)\r\n    else:\r\n        fname = dstore.build_fname(prefix, kind, fmt)\r\n    return fname', 'model': 'llama3.2:1b', 'prompt': [...], 'generated_doc': '```python\ndef hazard_curve_name(dstore: object, ekey: str, kind: str, rlzs_assoc: object) -> str:\n    """"""\n    Generates the name of a hazard curve based on the export key and kind.\n\n    This function takes in three arguments: `calc_id`, `ekey`, `kind`, and `rlzs_assoc`.\n    It returns the formatted file name for the hazard curve.\n\n    Args:\n        dstore (object): The database store instance to use for building file names.\n        ekey (str): The export key associated with the hazard curve.\n        kind (str): The type of key that corresponds to the hazard curve.\n        rlzs_assoc (object): A RlzsAssoc instance representing the association.\n\n    Returns:\n        str: The formatted file name for the hazard curve.\n\n    Raises:\n        None\n\n    Example:\n        >>> import numpy as np\n        >>> from rlm.utils import hazard_curve_name\n        >>> dstore = ...  # Initialize database store instance\n        >>> ekey = \'hcurves/quantile/hazard_7\'\n        >>> kind = \'quantile\'\n        >>> rlzs_assoc = ...  # Initialize RlzsAssoc instance\n        >>> hazard_curve_name(dstore, ekey, kind, rlzs_assoc)\n        \'/path/to/file_name.hazard_curve\'\n    """"""\n```\n\nThis docstring uses Google-style formatting for consistency and readability. It includes a one-line summary of what the function does, as well as clear and concise information about each argument, return value, and any applicable exceptions. The example demonstrates how to use the function with sample arguments.', 'origin_doc': ':param calc_id: the calculation ID\r\n    :param ekey: the export key\r\n    :param kind: the kind of key\r\n    :param rlzs_assoc: a RlzsAssoc instance'}]","```python
def hazard_curve_name(dstore: object, ekey: str, kind: str, rlzs_assoc: object) -> str:
    """"""
    Generates the name of a hazard curve based on the export key and kind.

    This function takes in three arguments: `calc_id`, `ekey`, `kind`, and `rlzs_assoc`.
    It returns the formatted file name for the hazard curve.

    Args:
        dstore (object): The database store instance to use for building file names.
        ekey (str): The export key associated with the hazard curve.
        kind (str): The type of key that corresponds to the hazard curve.
        rlzs_assoc (object): A RlzsAssoc instance representing the association.

    Returns:
        str: The formatted file name for the hazard curve.

    Raises:
        None

    Example:
        >>> import numpy as np
        >>> from rlm.utils import hazard_curve_name
        >>> dstore = ...  # Initialize database store instance
        >>> ekey = 'hcurves/quantile/hazard_7'
        >>> kind = 'quantile'
        >>> rlzs_assoc = ...  # Initialize RlzsAssoc instance
        >>> hazard_curve_name(dstore, ekey, kind, rlzs_assoc)
        '/path/to/file_name.hazard_curve'
    """"""
```

This docstring uses Google-style formatting for consistency and readability. It includes a one-line summary of what the function does, as well as clear and concise information about each argument, return value, and any applicable exceptions. The example demonstrates how to use the function with sample arguments.",":param calc_id: the calculation ID
    :param ekey: the export key
    :param kind: the kind of key
    :param rlzs_assoc: a RlzsAssoc instance"
