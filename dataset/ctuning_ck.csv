repository_name,func_path_in_repository,func_name,whole_func_string,language,func_code_string,func_code_tokens,func_documentation_string,func_documentation_tokens,split_name,func_code_url
ctuning/ck,ck/repo/module/web/module.py,call_ck,"def call_ck(i):

    """"""
    Input:  {
              Input for CK
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              (stdout)     - stdout, if available
              (stderr)     - stderr, if available
              (std)        - stdout+stderr
            }
    """"""

    import subprocess
    import re

    # Check action
    action=i.get('action','')
    if action=='':
       return {'return':1, 'error':'action is not defined'}

    # Check that no special characters, otherwise can run any command from CMD
    if not re.match('^[A-Za-z0-9-_]*$', action):
       return {'return':1, 'error':'action contains illegal characters'}

    # Generate tmp file
    fd, fn=tempfile.mkstemp(suffix='.tmp', prefix='ck-') # suffix is important - CK will delete such file!
    os.close(fd)

    dc=i.get('detach_console','')
    if dc=='yes': i['out']='con' # If detach, output as console

    # Prepare dummy output
    rr={'return':0}
    rr['stdout']=''
    rr['stderr']=''

    # Save json to temporay file
    rx=ck.save_json_to_file({'json_file':fn, 'dict':i})
    if rx['return']>0: return rx

    # Prepare command line
    cmd='ck '+action+' @'+fn
    if dc=='yes':
       # Check platform
       rx=ck.get_os_ck({})
       if rx['return']>0: return rx

       plat=rx['platform']

       dci=ck.cfg.get('detached_console',{}).get(plat,{})

       dcmd=dci.get('cmd','')
       if dcmd=='':
          return {'return':1, 'error':'detached console is requested but cmd is not defined in kernel configuration'}

       dcmd=dcmd.replace('$#cmd#$', cmd)

       if dci.get('use_create_new_console_flag','')=='yes':
          process=subprocess.Popen(dcmd, stdin=None, stdout=None, stderr=None, shell=True, close_fds=True, creationflags=subprocess.CREATE_NEW_CONSOLE)
       else:
          # Will need to do the forking
          try:
             pid=os.fork()
          except OSError as e:
             return {'return':1, 'error':'forking detached console failed ('+format(e)+')'}

          if pid==0:
             os.setsid()

             pid=os.fork()
             if pid!=0: os._exit(0)

             try:
                 maxfd=os.sysconf(""SC_OPEN_MAX"")
             except (AttributeError, ValueError):
                 maxfd=1024

             for fd in range(maxfd):
                 try:
                    os.close(fd)
                 except OSError:
                    pass

             os.open('/dev/null', os.O_RDWR)
             os.dup2(0, 1)
             os.dup2(0, 2)

             # Normally child process
             process=os.system(dcmd)
             os._exit(0)

       stdout=ck.cfg.get('detached_console_html', 'Console was detached ...')
       stderr=''
    else:
       process=subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
       stdout,stderr=process.communicate()

    try: stdout=stdout.decode('utf8')
    except Exception as e: pass
    try: stderr=stderr.decode('utf8')
    except Exception as e: pass

    rr['std']=stdout+stderr
    rr['stdout']=stdout
    rr['stderr']=stderr

    return rr",python,"def call_ck(i):

    """"""
    Input:  {
              Input for CK
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              (stdout)     - stdout, if available
              (stderr)     - stderr, if available
              (std)        - stdout+stderr
            }
    """"""

    import subprocess
    import re

    # Check action
    action=i.get('action','')
    if action=='':
       return {'return':1, 'error':'action is not defined'}

    # Check that no special characters, otherwise can run any command from CMD
    if not re.match('^[A-Za-z0-9-_]*$', action):
       return {'return':1, 'error':'action contains illegal characters'}

    # Generate tmp file
    fd, fn=tempfile.mkstemp(suffix='.tmp', prefix='ck-') # suffix is important - CK will delete such file!
    os.close(fd)

    dc=i.get('detach_console','')
    if dc=='yes': i['out']='con' # If detach, output as console

    # Prepare dummy output
    rr={'return':0}
    rr['stdout']=''
    rr['stderr']=''

    # Save json to temporay file
    rx=ck.save_json_to_file({'json_file':fn, 'dict':i})
    if rx['return']>0: return rx

    # Prepare command line
    cmd='ck '+action+' @'+fn
    if dc=='yes':
       # Check platform
       rx=ck.get_os_ck({})
       if rx['return']>0: return rx

       plat=rx['platform']

       dci=ck.cfg.get('detached_console',{}).get(plat,{})

       dcmd=dci.get('cmd','')
       if dcmd=='':
          return {'return':1, 'error':'detached console is requested but cmd is not defined in kernel configuration'}

       dcmd=dcmd.replace('$#cmd#$', cmd)

       if dci.get('use_create_new_console_flag','')=='yes':
          process=subprocess.Popen(dcmd, stdin=None, stdout=None, stderr=None, shell=True, close_fds=True, creationflags=subprocess.CREATE_NEW_CONSOLE)
       else:
          # Will need to do the forking
          try:
             pid=os.fork()
          except OSError as e:
             return {'return':1, 'error':'forking detached console failed ('+format(e)+')'}

          if pid==0:
             os.setsid()

             pid=os.fork()
             if pid!=0: os._exit(0)

             try:
                 maxfd=os.sysconf(""SC_OPEN_MAX"")
             except (AttributeError, ValueError):
                 maxfd=1024

             for fd in range(maxfd):
                 try:
                    os.close(fd)
                 except OSError:
                    pass

             os.open('/dev/null', os.O_RDWR)
             os.dup2(0, 1)
             os.dup2(0, 2)

             # Normally child process
             process=os.system(dcmd)
             os._exit(0)

       stdout=ck.cfg.get('detached_console_html', 'Console was detached ...')
       stderr=''
    else:
       process=subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
       stdout,stderr=process.communicate()

    try: stdout=stdout.decode('utf8')
    except Exception as e: pass
    try: stderr=stderr.decode('utf8')
    except Exception as e: pass

    rr['std']=stdout+stderr
    rr['stdout']=stdout
    rr['stderr']=stderr

    return rr","['def' 'call_ck' '(' 'i' ')' ':' 'import' 'subprocess' 'import' 're'
 '# Check action' 'action' '=' 'i' '.' 'get' '(' ""'action'"" ',' ""''"" ')'
 'if' 'action' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' ""'action is not defined'"" '}'
 '# Check that no special characters, otherwise can run any command from CMD'
 'if' 'not' 're' '.' 'match' '(' ""'^[A-Za-z0-9-_]*$'"" ',' 'action' ')' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'action contains illegal characters'"" '}' '# Generate tmp file' 'fd' ','
 'fn' '=' 'tempfile' '.' 'mkstemp' '(' 'suffix' '=' ""'.tmp'"" ',' 'prefix'
 '=' ""'ck-'"" ')' '# suffix is important - CK will delete such file!' 'os'
 '.' 'close' '(' 'fd' ')' 'dc' '=' 'i' '.' 'get' '(' ""'detach_console'""
 ',' ""''"" ')' 'if' 'dc' '==' ""'yes'"" ':' 'i' '[' ""'out'"" ']' '=' ""'con'""
 '# If detach, output as console' '# Prepare dummy output' 'rr' '=' '{'
 ""'return'"" ':' '0' '}' 'rr' '[' ""'stdout'"" ']' '=' ""''"" 'rr' '['
 ""'stderr'"" ']' '=' ""''"" '# Save json to temporay file' 'rx' '=' 'ck' '.'
 'save_json_to_file' '(' '{' ""'json_file'"" ':' 'fn' ',' ""'dict'"" ':' 'i'
 '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx'
 '# Prepare command line' 'cmd' '=' ""'ck '"" '+' 'action' '+' ""' @'"" '+'
 'fn' 'if' 'dc' '==' ""'yes'"" ':' '# Check platform' 'rx' '=' 'ck' '.'
 'get_os_ck' '(' '{' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'rx' 'plat' '=' 'rx' '[' ""'platform'"" ']' 'dci' '=' 'ck' '.'
 'cfg' '.' 'get' '(' ""'detached_console'"" ',' '{' '}' ')' '.' 'get' '('
 'plat' ',' '{' '}' ')' 'dcmd' '=' 'dci' '.' 'get' '(' ""'cmd'"" ',' ""''""
 ')' 'if' 'dcmd' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':'
 ""'detached console is requested but cmd is not defined in kernel configuration'""
 '}' 'dcmd' '=' 'dcmd' '.' 'replace' '(' ""'$#cmd#$'"" ',' 'cmd' ')' 'if'
 'dci' '.' 'get' '(' ""'use_create_new_console_flag'"" ',' ""''"" ')' '=='
 ""'yes'"" ':' 'process' '=' 'subprocess' '.' 'Popen' '(' 'dcmd' ',' 'stdin'
 '=' 'None' ',' 'stdout' '=' 'None' ',' 'stderr' '=' 'None' ',' 'shell'
 '=' 'True' ',' 'close_fds' '=' 'True' ',' 'creationflags' '='
 'subprocess' '.' 'CREATE_NEW_CONSOLE' ')' 'else' ':'
 '# Will need to do the forking' 'try' ':' 'pid' '=' 'os' '.' 'fork' '('
 ')' 'except' 'OSError' 'as' 'e' ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'forking detached console failed ('"" '+' 'format' '(' 'e'
 ')' '+' ""')'"" '}' 'if' 'pid' '==' '0' ':' 'os' '.' 'setsid' '(' ')' 'pid'
 '=' 'os' '.' 'fork' '(' ')' 'if' 'pid' '!=' '0' ':' 'os' '.' '_exit' '('
 '0' ')' 'try' ':' 'maxfd' '=' 'os' '.' 'sysconf' '(' '""SC_OPEN_MAX""' ')'
 'except' '(' 'AttributeError' ',' 'ValueError' ')' ':' 'maxfd' '=' '1024'
 'for' 'fd' 'in' 'range' '(' 'maxfd' ')' ':' 'try' ':' 'os' '.' 'close'
 '(' 'fd' ')' 'except' 'OSError' ':' 'pass' 'os' '.' 'open' '('
 ""'/dev/null'"" ',' 'os' '.' 'O_RDWR' ')' 'os' '.' 'dup2' '(' '0' ',' '1'
 ')' 'os' '.' 'dup2' '(' '0' ',' '2' ')' '# Normally child process'
 'process' '=' 'os' '.' 'system' '(' 'dcmd' ')' 'os' '.' '_exit' '(' '0'
 ')' 'stdout' '=' 'ck' '.' 'cfg' '.' 'get' '(' ""'detached_console_html'""
 ',' ""'Console was detached ...'"" ')' 'stderr' '=' ""''"" 'else' ':'
 'process' '=' 'subprocess' '.' 'Popen' '(' 'cmd' ',' 'stdout' '='
 'subprocess' '.' 'PIPE' ',' 'stderr' '=' 'subprocess' '.' 'PIPE' ','
 'shell' '=' 'True' ')' 'stdout' ',' 'stderr' '=' 'process' '.'
 'communicate' '(' ')' 'try' ':' 'stdout' '=' 'stdout' '.' 'decode' '('
 ""'utf8'"" ')' 'except' 'Exception' 'as' 'e' ':' 'pass' 'try' ':' 'stderr'
 '=' 'stderr' '.' 'decode' '(' ""'utf8'"" ')' 'except' 'Exception' 'as' 'e'
 ':' 'pass' 'rr' '[' ""'std'"" ']' '=' 'stdout' '+' 'stderr' 'rr' '['
 ""'stdout'"" ']' '=' 'stdout' 'rr' '[' ""'stderr'"" ']' '=' 'stderr' 'return'
 'rr']","Input:  {
              Input for CK
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              (stdout)     - stdout, if available
              (stderr)     - stderr, if available
              (std)        - stdout+stderr
            }",['Input' ':' '{' 'Input' 'for' 'CK' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/web/module.py#L76-L188
ctuning/ck,ck/repo/module/web/module.py,web_err,"def web_err(i):

    """"""
    Input:  {
              http - http object
              type - content type
              bin  - bytes to output
            }

    Output: {
              return - 0
            }
    """"""

    http=i['http']
    tp=i['type']
    bin=i['bin']

    try: bin=bin.decode('utf-8')
    except Exception as e: pass

    if tp=='json':
       rx=ck.dumps_json({'dict':{'return':1, 'error':bin}})
       if rx['return']>0:
          bin2=rx['error'].encode('utf8')
       else:
          bin2=rx['string'].encode('utf-8')
    elif tp=='con':
       bin2=bin.encode('utf8')
    else:
       bin2=b'<html><body><pre>'+bin.encode('utf8')+b'</pre></body></html>'

    i['bin']=bin2
    return web_out(i)",python,"def web_err(i):

    """"""
    Input:  {
              http - http object
              type - content type
              bin  - bytes to output
            }

    Output: {
              return - 0
            }
    """"""

    http=i['http']
    tp=i['type']
    bin=i['bin']

    try: bin=bin.decode('utf-8')
    except Exception as e: pass

    if tp=='json':
       rx=ck.dumps_json({'dict':{'return':1, 'error':bin}})
       if rx['return']>0:
          bin2=rx['error'].encode('utf8')
       else:
          bin2=rx['string'].encode('utf-8')
    elif tp=='con':
       bin2=bin.encode('utf8')
    else:
       bin2=b'<html><body><pre>'+bin.encode('utf8')+b'</pre></body></html>'

    i['bin']=bin2
    return web_out(i)","['def' 'web_err' '(' 'i' ')' ':' 'http' '=' 'i' '[' ""'http'"" ']' 'tp' '='
 'i' '[' ""'type'"" ']' 'bin' '=' 'i' '[' ""'bin'"" ']' 'try' ':' 'bin' '='
 'bin' '.' 'decode' '(' ""'utf-8'"" ')' 'except' 'Exception' 'as' 'e' ':'
 'pass' 'if' 'tp' '==' ""'json'"" ':' 'rx' '=' 'ck' '.' 'dumps_json' '(' '{'
 ""'dict'"" ':' '{' ""'return'"" ':' '1' ',' ""'error'"" ':' 'bin' '}' '}' ')'
 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'bin2' '=' 'rx' '[' ""'error'""
 ']' '.' 'encode' '(' ""'utf8'"" ')' 'else' ':' 'bin2' '=' 'rx' '['
 ""'string'"" ']' '.' 'encode' '(' ""'utf-8'"" ')' 'elif' 'tp' '==' ""'con'""
 ':' 'bin2' '=' 'bin' '.' 'encode' '(' ""'utf8'"" ')' 'else' ':' 'bin2' '='
 ""b'<html><body><pre>'"" '+' 'bin' '.' 'encode' '(' ""'utf8'"" ')' '+'
 ""b'</pre></body></html>'"" 'i' '[' ""'bin'"" ']' '=' 'bin2' 'return'
 'web_out' '(' 'i' ')']","Input:  {
              http - http object
              type - content type
              bin  - bytes to output
            }

    Output: {
              return - 0
            }","['Input' ':' '{' 'http' '-' 'http' 'object' 'type' '-' 'content' 'type'
 'bin' '-' 'bytes' 'to' 'output' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/web/module.py#L193-L226
ctuning/ck,ck/repo/module/repo/module.py,add,"def add(i):
    """"""
    Note, that we can't create repos in parallel (recording to repo cache may fail).
    However, for now, we do not expect such cases (i.e. repos are created rarely)

    Input:  {
              (repo_uoa)                 - repo UOA (where to create entry)
              data_uoa                   - data UOA
              (data_uid)                 - data UID (if uoa is an alias)
              (data_name)                - user friendly data name

              (cids[0])                  - as uoa or full CID

              (path)                     - if !='' - create in this path or import from this path
              (here)                     - if =='yes', create in current path
              (use_default_path)         - if 'yes' create repository in the default path (CK_REPOS)
                                           instead of the current path (default is 'yes')

              (use_current_path)         - if 'yes' create repository in the current path
                                           (default is 'no')

              (default)                  - if 'yes', no path is used, 
                                           but the repository is taken either 
                                           from the CK directory or from CK_LOCAL_REPO

              (import)                   - if 'yes', register repo in the current directory in CK
                                           (when received from someone else)

              (remote)                   - if 'yes', remote repository
              (remote_repo_uoa)          - if !='' and type=='remote' repository UOA on the remote CK server

              (shared)                   - if not remote and =='git', repo is shared/synced through GIT
              (share)                    - (for user-friendly CMD) if 'yes', set shared=git

              (allow_writing)            - if 'yes', allow writing 
                                           (useful when kernel is set to allow writing only to such repositories)

              (url)                      - if type=='remote' or 'git', URL of remote repository or git repository
              (hostname)                 - if !='', automatically form url above (add http:// + /ck?)
              (port)                     - if !='', automatically add to url above
              (hostext)                  - if !='', add to the end of above URL instead of '/ck?' -
                                           useful when CK server is accessed via Apache2, IIS, Nginx or other web servers

              (githubuser)               - if shared repo, use this GitHub user space instead of default ""ctuning""
              (sync)                     - if 'yes' and type=='git', sync repo after each write operation

              (gitzip)                   - if 'yes', download as zip from GitHub
              (zip)                      - path to zipfile (local or remote http/ftp)
              (overwrite)                - if 'yes', overwrite files when unarchiving

              (repo_deps)                - dict with dependencies on other shared repositories with following keys:
                                             ""repo_uoa""
                                             (""repo_uid"") - specific UID (version) of a repo
                                             (""repo_url"") - URL of the shared repository (if not from github.com/ctuning)

              (quiet)                    - if 'yes', do not ask questions unless really needed

              (skip_reusing_remote_info) - if 'yes', do not reuse remote .cmr.json description of a repository

              (current_repos)            - if resolving dependencies on other repos, list of repos being updated (to avoid infinite recursion)

              (describe)                 - describe repository for Artifact Evaluation (see http://cTuning.org/ae)

              (stable)        - take stable version (highly experimental)
              (version)       - checkout version (default - stable)
              (branch)        - git branch
              (checkout)      - git checkout
            }

    Output: {
              return       - return code =  0, if successful
                                           16, repository with a given path is already registered in CK
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    # Check if global writing is allowed
    r=ck.check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    a=i.get('repo_uoa','')
    d=i.get('data_uoa','')
    di=i.get('data_uid','')
    dn=i.get('data_name','')

    stable=i.get('stable','')
    version=i.get('version','')
    if stable=='yes': version='stable'
    branch=i.get('branch','')
    checkout=i.get('checkout','')

    cr=i.get('current_repos',[])

    rdeps=i.get('repo_deps',[])

    quiet=i.get('quiet','')

    overwrite=i.get('overwrite','')

    remote=i.get('remote','')
    rruoa=i.get('remote_repo_uoa','')
    shared=i.get('shared','')
    if shared=='yes': shared='git'

    share=i.get('share','')
    if share=='yes' and shared=='': shared='git'

    ptr=''
    zp=i.get('zip','')
    gz=i.get('gitzip','')

    if zp!='':
       if zp.startswith('~'):
          from os.path import expanduser
          home = expanduser(""~"")

          zp=os.path.abspath(home+os.sep+zp[1:])

       quiet='yes'

       if d=='':
          # Try to get data UOA
          if not os.path.isfile(zp):
             return {'return':1, 'error':'zip file not found'}

          # Try to get .ckr.json
          import zipfile

          try:
             with zipfile.ZipFile(zp) as z:
                zip_has_git=False
                if '.git/HEAD' in z.namelist():
                   zip_has_git=True

                if ck.cfg['repo_file'] in z.namelist():
                   x=z.open(ck.cfg['repo_file'])
                   y=x.read()

                   r=ck.convert_json_str_to_dict({'str':y, 'skip_quote_replacement':'yes'})
                   if r['return']>0: return r
                   yd=r['dict']

                   d=yd.get('data_uoa','')
                   di=yd.get('data_uid','')
                   dn=yd.get('data_name','')

                   zip_shared=yd.get('dict',{}).get('shared','')
                   if zip_shared!='':
                      if zip_shared!='git' or zip_has_git:
                         shared=yd['dict']['shared']
                         share='yes'

                   x.close()
             z.close()
          except Exception as e:
             return {'return':1, 'error':'problem reading zip file ('+format(e)+')'}

          if d=='':
             x1=os.path.basename(zp)
             d=os.path.splitext(x1)[0]
             if d.startswith('ckr-'):
                d=d[4:]

             if o=='con':
                ck.out('Auto-detected repo name from zip filename: '+d)

    if gz=='yes':
       zp=ck.cfg['default_shared_repo_url']+'/'+d+'/archive/master.zip'
       ptr=d+'-master/'
       quiet='yes'

    rx=form_url(i)
    if rx['return']>0: return rx
    url=rx['url']

    sync=i.get('sync','')
    df=i.get('default','')

    eaw=i.get('allow_writing','')

    udp=i.get('use_default_path','yes')
    ucp=i.get('use_current_path','')
    if ucp=='yes': udp=''

    # Get repo path (unless 'here' later)
    px=i.get('path','')

    # Check if import
    imp=i.get('import','')
    if imp=='yes': 
       if px=='': i['here']='yes'

    # Get 'here' path
    if i.get('here','')=='yes': px=os.getcwd()
    p=px

    if imp=='yes': 
       py=os.path.join(p,ck.cfg['repo_file'])
       if os.path.isfile(py):
          r=ck.load_json_file({'json_file':py})
          if r['return']>0: return r
          dc=r['dict']

          d=dc.get('data_uoa','')
          di=dc.get('data_uid','')
          dn=dc.get('data_name','')

    if p=='' and udp=='yes': p=os.path.join(ck.work['dir_repos'], d)

    # Normalize path
    p=os.path.normpath(p)

    # If console mode, first, check if shared (GIT, etc)
    if o=='con':
       # Asking for alias
       if df!='yes' and (d=='' or ck.is_uid(d)):
          r=ck.inp({'text':'Enter an alias for this repository (or Enter to skip it): '})
          d=r['string']
          if d=='': d=di
          if d=='':
             r=ck.gen_uid({})
             if r['return']>0: return r
             di=r['data_uid']
             d=di

       # Asking for a user-friendly name
       if df!='yes' and dn=='':
          if quiet!='yes':
             r=ck.inp({'text':'Enter a user-friendly name of this repository (or Enter to reuse alias): '})
             dn=r['string']
          if dn=='': dn=d

       # Asking if remote
       if df!='yes' and remote=='':
          if quiet!='yes':
             r=ck.inp({'text':'Is this repository a remote CK web service (y/N)? '})
             remote=r['string'].lower()
          if remote=='yes' or remote=='y': remote='yes'
          else: remote=''

       # Asking for a user-friendly name
       if px=='' and df!='yes' and remote!='yes' and udp=='':
          if quiet!='yes':
             r=ck.inp({'text':'Would you like to create repo in the directory from CK_REPOS variable (Y/n): '})
             x=r['string'].lower()
             if x=='' or x=='yes' or x=='y':
                p=os.path.join(ck.work['dir_repos'], d)

       # Asking for remote url
       if df!='yes' and remote=='yes' and url=='':
          if quiet!='yes':
             r=ck.inp({'text':'Enter URL of remote CK repo (example: http://localhost:3344/ck?): '})
             url=r['string'].lower()
          if url=='':
             return {'return':1, 'error':'URL is empty'}

       # Asking for remote repo UOA
       if df!='yes' and remote=='yes' and rruoa=='':
          if quiet!='yes':
             r=ck.inp({'text':'Enter remote repo UOA or Enter to skip: '})
             rruoa=r['string'].lower()

       # Asking for shared
       if remote=='' and shared=='' and share=='':
          if quiet!='yes':
             r=ck.inp({'text':'Is this repository shared via GIT (y/N)? '})
             x=r['string'].lower()
             if x=='yes' or x=='y':
                share='yes'

       if share=='yes' and shared=='': shared='git'

       # Check additional parameters if git
       ghu=i.get('githubuser','')
       if shared=='git' and url=='':

          if ghu!='': 
             durl=ck.cfg.get('github_repo_url','')
             if not durl.endswith('/'): durl+='/'
             durl+=ghu
          else: durl=ck.cfg.get('default_shared_repo_url','')

          if not durl.endswith('/'): durl+='/'
          durl+=d
#          if durl.startswith('http://') or durl.startswith('https://'):
#             durl+='.git'

          if quiet!='yes':
             s='Enter URL of GIT repo '
             if d=='': s+='(for example, https://github.com/ctuning/ck-analytics.git)'
             else:     s+='(or Enter for '+durl+')'
             r=ck.inp({'text': s+': '})
             url=r['string'].lower()
          if url=='': url=durl

       # Check additional parameters if git
       if shared=='git' and sync=='':
          if quiet!='yes':
             r=ck.inp({'text': 'Would you like to sync repo each time after writing to it (y/N)?: '})
             x=r['string'].lower()
             if x=='yes' or x=='y':
                sync='yes'

       # Asking for a user-friendly name
       if df!='yes' and remote!='yes' and eaw=='':
          if quiet!='yes':
             r=ck.inp({'text':'Would you like to explicitly allow writing to this repository in case kernel disables all writing (y/N): '})
             x=r['string'].lower()
             if x=='yes' or x=='y':
                eaw='yes'

       # Check if add more deps
       if quiet!='yes':
          r=add_more_deps({})
          if r['return']>0: return r

          rdeps1=r['repo_deps']
          for q in rdeps1:
              rdeps.append(q)

    # Check if already registered (if not remote)
    if remote!='yes':
       r=ck.find_repo_by_path({'path':p})
       if r['return']>0 and r['return']!=16: 
          return r

    # Check if repository is already registered with this path
    r=ck.find_repo_by_path({'path':p})
    if r['return']==0:
       return {'return':16, 'error':'repository with a given path is already registered in CK'}
    elif r['return']!=16: 
       return r

    # Prepare local description file
    py=os.path.join(p,ck.cfg['repo_file'])

    # Create dummy if doesn't exist
    if remote!='yes' and not os.path.isdir(p):
       os.makedirs(p)

    # If zip, get (download) and unzip file ...
    if zp!='':
       rz=get_and_unzip_archive({'zip':zp, 'path':p, 'path_to_remove':ptr, 'overwrite':overwrite, 'out':o})
       if rz['return']>0: return rz

       py = os.path.join(p, ck.cfg['repo_file'])
       if os.path.isfile(py):
           r = ck.load_json_file({'json_file': py})
           if r['return'] > 0: return r
           dc = r['dict']

           d = dc.get('data_uoa', '')
           di = dc.get('data_uid', '')
           dn = dc.get('data_name', '')

    # If git, clone repo
    repo_had_local=True
    dd={}
    if remote!='yes' and shared=='git' and zp=='':
       r=pull({'path':p, 'type':shared, 'url':url, 'clone':'yes', 'git':i.get('git',''), 'out':o})
       if r['return']>0: return r

       # Check if there is a local repo description
       if os.path.isfile(py):
          r=ck.load_json_file({'json_file':py})
          if r['return']>0: return r
          dc=r['dict']
          ddc=dc.get('dict',{})
          dd.update(ddc)

          xd=dc.get('data_uoa','')
          xdi=dc.get('data_uid','')
          xdn=dc.get('data_name','')

          if o=='con':
             ck.out('Cloned repository has the following info:')
             ck.out(' UID                = '+xdi)
             ck.out(' UOA                = '+xd)
             ck.out(' User friendly name = '+xdn)
             ck.out('')
          if i.get('skip_reusing_remote_info','')!='yes':
             d=xd
             di=xdi
             dn=xdn
       else:
          repo_had_local=False

    # Prepare meta description
    if df=='yes': 
       dd['default']='yes'
    if remote=='yes': 
       dd['remote']='yes'
       if rruoa!='': 
          dd['remote_repo_uoa']=rruoa
    if shared!='':
       dd['shared']=shared
       if sync!='': 
          dd['sync']=sync
    if url!='': 
       dd['url']=url
    if remote!='yes': 
       dd['path']=p
    if eaw=='yes':
       dd['allow_writing']='yes'
    if len(rdeps)>0:
       dd['repo_deps']=rdeps

    # Check if need to describe for Artifact Evaluation
    if i.get('describe','')=='yes':
       r=describe({'dict':dd})
       if r['return']>0: return r

    # If not default, go to common core function to create entry
    if df!='yes':
       ii={'module_uoa':work['self_module_uoa'],
           'action':'add',
           'data_uoa':d,
           'dict':dd,
           'common_func':'yes'}
       if a!='': ii['repo_uoa']=a
       if di!='': ii['data_uid']=di
       if dn!='': ii['data_name']=dn
       rx=ck.access(ii)
       if rx['return']>0: return rx
    else:
       # Load default repo and prepare return
       ii={'module_uoa':work['self_module_uoa'],
           'action':'load',
           'data_uoa':'default',
           'common_func':'yes'}
       rx=ck.access(ii)
    px=rx['path']
    dx=rx['data_uid']
    alias=rx['data_alias']

    # Update repo cache if not default local
    dz={'data_uoa':d, 'data_uid':dx, 'data_alias':alias, 'path_to_repo_desc':px, 'data_name':dn, 'dict':dd}

    if df!='yes':
       r=ck.reload_repo_cache({}) # Ignore errors
       ck.cache_repo_uoa[d]=dx
       ck.cache_repo_info[dx]=dz
       r=ck.save_repo_cache({})
       if r['return']>0: return r

    # Record local info of the repo (just in case)
    if remote!='yes':
       if 'path_to_repo_desc' in dz: del (dz['path_to_repo_desc'])        # Avoid recording some local info
       if dz.get('dict',{}).get('path','')!='': del (dz['dict']['path'])  # Avoid recording some local info

       if not os.path.isfile(py):
          ry=ck.save_json_to_file({'json_file':py, 'dict':dz})
          if ry['return']>0: return ry

       # If sync (or pulled repo did not have local description), add it ...
       if sync=='yes' or (shared=='git' and not repo_had_local):
          ppp=os.getcwd()

          os.chdir(p)
          ss=ck.cfg['repo_types'][shared]['add'].replace('$#path#$', px).replace('$#files#$', ck.cfg['repo_file'])
          os.system(ss)

          os.chdir(ppp)

    # If console mode, print various info
    if o=='con':
       ck.out('')
       ck.out('CK repository successfully registered!')
       ck.out('')

       if df!='yes':
          ck.out('CK repo description path = '+px)
          ck.out('CK repo UID              = '+dx)

    # Recache repos otherwise may be problems with deps
    if o=='con':
       ck.out('')
       ck.out('Recaching repos to speed up access ...')
       ck.out('')
    r=recache({'out':o})
    if r['return']>0: return r

    # Check deps
    if o=='con':
       ck.out('  ========================================')
       ck.out('  Checking dependencies on other repos ...')
       ck.out('')

    how='pull'
    if gz=='yes': how='add'
    r=deps({'path':p,
            'current_path':cr,
            'how':how,
            'version':version,
            'branch':branch,
            'checkout':checkout,
            'out':o})
    if r['return']>0: return r

    # Print if default
    if df=='yes' and o=='con':
       ck.out('')
       ck.out('Please, do not forget to add path to this repository to CK_LOCAL_REPO environment variable:')
       ck.out('')
       ck.out('  Linux: export CK_LOCAL_REPO='+p)
       ck.out('  Windows: set CK_LOCAL_REPO='+p)

    return rx",python,"def add(i):
    """"""
    Note, that we can't create repos in parallel (recording to repo cache may fail).
    However, for now, we do not expect such cases (i.e. repos are created rarely)

    Input:  {
              (repo_uoa)                 - repo UOA (where to create entry)
              data_uoa                   - data UOA
              (data_uid)                 - data UID (if uoa is an alias)
              (data_name)                - user friendly data name

              (cids[0])                  - as uoa or full CID

              (path)                     - if !='' - create in this path or import from this path
              (here)                     - if =='yes', create in current path
              (use_default_path)         - if 'yes' create repository in the default path (CK_REPOS)
                                           instead of the current path (default is 'yes')

              (use_current_path)         - if 'yes' create repository in the current path
                                           (default is 'no')

              (default)                  - if 'yes', no path is used, 
                                           but the repository is taken either 
                                           from the CK directory or from CK_LOCAL_REPO

              (import)                   - if 'yes', register repo in the current directory in CK
                                           (when received from someone else)

              (remote)                   - if 'yes', remote repository
              (remote_repo_uoa)          - if !='' and type=='remote' repository UOA on the remote CK server

              (shared)                   - if not remote and =='git', repo is shared/synced through GIT
              (share)                    - (for user-friendly CMD) if 'yes', set shared=git

              (allow_writing)            - if 'yes', allow writing 
                                           (useful when kernel is set to allow writing only to such repositories)

              (url)                      - if type=='remote' or 'git', URL of remote repository or git repository
              (hostname)                 - if !='', automatically form url above (add http:// + /ck?)
              (port)                     - if !='', automatically add to url above
              (hostext)                  - if !='', add to the end of above URL instead of '/ck?' -
                                           useful when CK server is accessed via Apache2, IIS, Nginx or other web servers

              (githubuser)               - if shared repo, use this GitHub user space instead of default ""ctuning""
              (sync)                     - if 'yes' and type=='git', sync repo after each write operation

              (gitzip)                   - if 'yes', download as zip from GitHub
              (zip)                      - path to zipfile (local or remote http/ftp)
              (overwrite)                - if 'yes', overwrite files when unarchiving

              (repo_deps)                - dict with dependencies on other shared repositories with following keys:
                                             ""repo_uoa""
                                             (""repo_uid"") - specific UID (version) of a repo
                                             (""repo_url"") - URL of the shared repository (if not from github.com/ctuning)

              (quiet)                    - if 'yes', do not ask questions unless really needed

              (skip_reusing_remote_info) - if 'yes', do not reuse remote .cmr.json description of a repository

              (current_repos)            - if resolving dependencies on other repos, list of repos being updated (to avoid infinite recursion)

              (describe)                 - describe repository for Artifact Evaluation (see http://cTuning.org/ae)

              (stable)        - take stable version (highly experimental)
              (version)       - checkout version (default - stable)
              (branch)        - git branch
              (checkout)      - git checkout
            }

    Output: {
              return       - return code =  0, if successful
                                           16, repository with a given path is already registered in CK
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    # Check if global writing is allowed
    r=ck.check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    a=i.get('repo_uoa','')
    d=i.get('data_uoa','')
    di=i.get('data_uid','')
    dn=i.get('data_name','')

    stable=i.get('stable','')
    version=i.get('version','')
    if stable=='yes': version='stable'
    branch=i.get('branch','')
    checkout=i.get('checkout','')

    cr=i.get('current_repos',[])

    rdeps=i.get('repo_deps',[])

    quiet=i.get('quiet','')

    overwrite=i.get('overwrite','')

    remote=i.get('remote','')
    rruoa=i.get('remote_repo_uoa','')
    shared=i.get('shared','')
    if shared=='yes': shared='git'

    share=i.get('share','')
    if share=='yes' and shared=='': shared='git'

    ptr=''
    zp=i.get('zip','')
    gz=i.get('gitzip','')

    if zp!='':
       if zp.startswith('~'):
          from os.path import expanduser
          home = expanduser(""~"")

          zp=os.path.abspath(home+os.sep+zp[1:])

       quiet='yes'

       if d=='':
          # Try to get data UOA
          if not os.path.isfile(zp):
             return {'return':1, 'error':'zip file not found'}

          # Try to get .ckr.json
          import zipfile

          try:
             with zipfile.ZipFile(zp) as z:
                zip_has_git=False
                if '.git/HEAD' in z.namelist():
                   zip_has_git=True

                if ck.cfg['repo_file'] in z.namelist():
                   x=z.open(ck.cfg['repo_file'])
                   y=x.read()

                   r=ck.convert_json_str_to_dict({'str':y, 'skip_quote_replacement':'yes'})
                   if r['return']>0: return r
                   yd=r['dict']

                   d=yd.get('data_uoa','')
                   di=yd.get('data_uid','')
                   dn=yd.get('data_name','')

                   zip_shared=yd.get('dict',{}).get('shared','')
                   if zip_shared!='':
                      if zip_shared!='git' or zip_has_git:
                         shared=yd['dict']['shared']
                         share='yes'

                   x.close()
             z.close()
          except Exception as e:
             return {'return':1, 'error':'problem reading zip file ('+format(e)+')'}

          if d=='':
             x1=os.path.basename(zp)
             d=os.path.splitext(x1)[0]
             if d.startswith('ckr-'):
                d=d[4:]

             if o=='con':
                ck.out('Auto-detected repo name from zip filename: '+d)

    if gz=='yes':
       zp=ck.cfg['default_shared_repo_url']+'/'+d+'/archive/master.zip'
       ptr=d+'-master/'
       quiet='yes'

    rx=form_url(i)
    if rx['return']>0: return rx
    url=rx['url']

    sync=i.get('sync','')
    df=i.get('default','')

    eaw=i.get('allow_writing','')

    udp=i.get('use_default_path','yes')
    ucp=i.get('use_current_path','')
    if ucp=='yes': udp=''

    # Get repo path (unless 'here' later)
    px=i.get('path','')

    # Check if import
    imp=i.get('import','')
    if imp=='yes': 
       if px=='': i['here']='yes'

    # Get 'here' path
    if i.get('here','')=='yes': px=os.getcwd()
    p=px

    if imp=='yes': 
       py=os.path.join(p,ck.cfg['repo_file'])
       if os.path.isfile(py):
          r=ck.load_json_file({'json_file':py})
          if r['return']>0: return r
          dc=r['dict']

          d=dc.get('data_uoa','')
          di=dc.get('data_uid','')
          dn=dc.get('data_name','')

    if p=='' and udp=='yes': p=os.path.join(ck.work['dir_repos'], d)

    # Normalize path
    p=os.path.normpath(p)

    # If console mode, first, check if shared (GIT, etc)
    if o=='con':
       # Asking for alias
       if df!='yes' and (d=='' or ck.is_uid(d)):
          r=ck.inp({'text':'Enter an alias for this repository (or Enter to skip it): '})
          d=r['string']
          if d=='': d=di
          if d=='':
             r=ck.gen_uid({})
             if r['return']>0: return r
             di=r['data_uid']
             d=di

       # Asking for a user-friendly name
       if df!='yes' and dn=='':
          if quiet!='yes':
             r=ck.inp({'text':'Enter a user-friendly name of this repository (or Enter to reuse alias): '})
             dn=r['string']
          if dn=='': dn=d

       # Asking if remote
       if df!='yes' and remote=='':
          if quiet!='yes':
             r=ck.inp({'text':'Is this repository a remote CK web service (y/N)? '})
             remote=r['string'].lower()
          if remote=='yes' or remote=='y': remote='yes'
          else: remote=''

       # Asking for a user-friendly name
       if px=='' and df!='yes' and remote!='yes' and udp=='':
          if quiet!='yes':
             r=ck.inp({'text':'Would you like to create repo in the directory from CK_REPOS variable (Y/n): '})
             x=r['string'].lower()
             if x=='' or x=='yes' or x=='y':
                p=os.path.join(ck.work['dir_repos'], d)

       # Asking for remote url
       if df!='yes' and remote=='yes' and url=='':
          if quiet!='yes':
             r=ck.inp({'text':'Enter URL of remote CK repo (example: http://localhost:3344/ck?): '})
             url=r['string'].lower()
          if url=='':
             return {'return':1, 'error':'URL is empty'}

       # Asking for remote repo UOA
       if df!='yes' and remote=='yes' and rruoa=='':
          if quiet!='yes':
             r=ck.inp({'text':'Enter remote repo UOA or Enter to skip: '})
             rruoa=r['string'].lower()

       # Asking for shared
       if remote=='' and shared=='' and share=='':
          if quiet!='yes':
             r=ck.inp({'text':'Is this repository shared via GIT (y/N)? '})
             x=r['string'].lower()
             if x=='yes' or x=='y':
                share='yes'

       if share=='yes' and shared=='': shared='git'

       # Check additional parameters if git
       ghu=i.get('githubuser','')
       if shared=='git' and url=='':

          if ghu!='': 
             durl=ck.cfg.get('github_repo_url','')
             if not durl.endswith('/'): durl+='/'
             durl+=ghu
          else: durl=ck.cfg.get('default_shared_repo_url','')

          if not durl.endswith('/'): durl+='/'
          durl+=d
#          if durl.startswith('http://') or durl.startswith('https://'):
#             durl+='.git'

          if quiet!='yes':
             s='Enter URL of GIT repo '
             if d=='': s+='(for example, https://github.com/ctuning/ck-analytics.git)'
             else:     s+='(or Enter for '+durl+')'
             r=ck.inp({'text': s+': '})
             url=r['string'].lower()
          if url=='': url=durl

       # Check additional parameters if git
       if shared=='git' and sync=='':
          if quiet!='yes':
             r=ck.inp({'text': 'Would you like to sync repo each time after writing to it (y/N)?: '})
             x=r['string'].lower()
             if x=='yes' or x=='y':
                sync='yes'

       # Asking for a user-friendly name
       if df!='yes' and remote!='yes' and eaw=='':
          if quiet!='yes':
             r=ck.inp({'text':'Would you like to explicitly allow writing to this repository in case kernel disables all writing (y/N): '})
             x=r['string'].lower()
             if x=='yes' or x=='y':
                eaw='yes'

       # Check if add more deps
       if quiet!='yes':
          r=add_more_deps({})
          if r['return']>0: return r

          rdeps1=r['repo_deps']
          for q in rdeps1:
              rdeps.append(q)

    # Check if already registered (if not remote)
    if remote!='yes':
       r=ck.find_repo_by_path({'path':p})
       if r['return']>0 and r['return']!=16: 
          return r

    # Check if repository is already registered with this path
    r=ck.find_repo_by_path({'path':p})
    if r['return']==0:
       return {'return':16, 'error':'repository with a given path is already registered in CK'}
    elif r['return']!=16: 
       return r

    # Prepare local description file
    py=os.path.join(p,ck.cfg['repo_file'])

    # Create dummy if doesn't exist
    if remote!='yes' and not os.path.isdir(p):
       os.makedirs(p)

    # If zip, get (download) and unzip file ...
    if zp!='':
       rz=get_and_unzip_archive({'zip':zp, 'path':p, 'path_to_remove':ptr, 'overwrite':overwrite, 'out':o})
       if rz['return']>0: return rz

       py = os.path.join(p, ck.cfg['repo_file'])
       if os.path.isfile(py):
           r = ck.load_json_file({'json_file': py})
           if r['return'] > 0: return r
           dc = r['dict']

           d = dc.get('data_uoa', '')
           di = dc.get('data_uid', '')
           dn = dc.get('data_name', '')

    # If git, clone repo
    repo_had_local=True
    dd={}
    if remote!='yes' and shared=='git' and zp=='':
       r=pull({'path':p, 'type':shared, 'url':url, 'clone':'yes', 'git':i.get('git',''), 'out':o})
       if r['return']>0: return r

       # Check if there is a local repo description
       if os.path.isfile(py):
          r=ck.load_json_file({'json_file':py})
          if r['return']>0: return r
          dc=r['dict']
          ddc=dc.get('dict',{})
          dd.update(ddc)

          xd=dc.get('data_uoa','')
          xdi=dc.get('data_uid','')
          xdn=dc.get('data_name','')

          if o=='con':
             ck.out('Cloned repository has the following info:')
             ck.out(' UID                = '+xdi)
             ck.out(' UOA                = '+xd)
             ck.out(' User friendly name = '+xdn)
             ck.out('')
          if i.get('skip_reusing_remote_info','')!='yes':
             d=xd
             di=xdi
             dn=xdn
       else:
          repo_had_local=False

    # Prepare meta description
    if df=='yes': 
       dd['default']='yes'
    if remote=='yes': 
       dd['remote']='yes'
       if rruoa!='': 
          dd['remote_repo_uoa']=rruoa
    if shared!='':
       dd['shared']=shared
       if sync!='': 
          dd['sync']=sync
    if url!='': 
       dd['url']=url
    if remote!='yes': 
       dd['path']=p
    if eaw=='yes':
       dd['allow_writing']='yes'
    if len(rdeps)>0:
       dd['repo_deps']=rdeps

    # Check if need to describe for Artifact Evaluation
    if i.get('describe','')=='yes':
       r=describe({'dict':dd})
       if r['return']>0: return r

    # If not default, go to common core function to create entry
    if df!='yes':
       ii={'module_uoa':work['self_module_uoa'],
           'action':'add',
           'data_uoa':d,
           'dict':dd,
           'common_func':'yes'}
       if a!='': ii['repo_uoa']=a
       if di!='': ii['data_uid']=di
       if dn!='': ii['data_name']=dn
       rx=ck.access(ii)
       if rx['return']>0: return rx
    else:
       # Load default repo and prepare return
       ii={'module_uoa':work['self_module_uoa'],
           'action':'load',
           'data_uoa':'default',
           'common_func':'yes'}
       rx=ck.access(ii)
    px=rx['path']
    dx=rx['data_uid']
    alias=rx['data_alias']

    # Update repo cache if not default local
    dz={'data_uoa':d, 'data_uid':dx, 'data_alias':alias, 'path_to_repo_desc':px, 'data_name':dn, 'dict':dd}

    if df!='yes':
       r=ck.reload_repo_cache({}) # Ignore errors
       ck.cache_repo_uoa[d]=dx
       ck.cache_repo_info[dx]=dz
       r=ck.save_repo_cache({})
       if r['return']>0: return r

    # Record local info of the repo (just in case)
    if remote!='yes':
       if 'path_to_repo_desc' in dz: del (dz['path_to_repo_desc'])        # Avoid recording some local info
       if dz.get('dict',{}).get('path','')!='': del (dz['dict']['path'])  # Avoid recording some local info

       if not os.path.isfile(py):
          ry=ck.save_json_to_file({'json_file':py, 'dict':dz})
          if ry['return']>0: return ry

       # If sync (or pulled repo did not have local description), add it ...
       if sync=='yes' or (shared=='git' and not repo_had_local):
          ppp=os.getcwd()

          os.chdir(p)
          ss=ck.cfg['repo_types'][shared]['add'].replace('$#path#$', px).replace('$#files#$', ck.cfg['repo_file'])
          os.system(ss)

          os.chdir(ppp)

    # If console mode, print various info
    if o=='con':
       ck.out('')
       ck.out('CK repository successfully registered!')
       ck.out('')

       if df!='yes':
          ck.out('CK repo description path = '+px)
          ck.out('CK repo UID              = '+dx)

    # Recache repos otherwise may be problems with deps
    if o=='con':
       ck.out('')
       ck.out('Recaching repos to speed up access ...')
       ck.out('')
    r=recache({'out':o})
    if r['return']>0: return r

    # Check deps
    if o=='con':
       ck.out('  ========================================')
       ck.out('  Checking dependencies on other repos ...')
       ck.out('')

    how='pull'
    if gz=='yes': how='add'
    r=deps({'path':p,
            'current_path':cr,
            'how':how,
            'version':version,
            'branch':branch,
            'checkout':checkout,
            'out':o})
    if r['return']>0: return r

    # Print if default
    if df=='yes' and o=='con':
       ck.out('')
       ck.out('Please, do not forget to add path to this repository to CK_LOCAL_REPO environment variable:')
       ck.out('')
       ck.out('  Linux: export CK_LOCAL_REPO='+p)
       ck.out('  Windows: set CK_LOCAL_REPO='+p)

    return rx",['def' 'add' '(' ... ')' 'return' 'rx'],"Note, that we can't create repos in parallel (recording to repo cache may fail).
    However, for now, we do not expect such cases (i.e. repos are created rarely)

    Input:  {
              (repo_uoa)                 - repo UOA (where to create entry)
              data_uoa                   - data UOA
              (data_uid)                 - data UID (if uoa is an alias)
              (data_name)                - user friendly data name

              (cids[0])                  - as uoa or full CID

              (path)                     - if !='' - create in this path or import from this path
              (here)                     - if =='yes', create in current path
              (use_default_path)         - if 'yes' create repository in the default path (CK_REPOS)
                                           instead of the current path (default is 'yes')

              (use_current_path)         - if 'yes' create repository in the current path
                                           (default is 'no')

              (default)                  - if 'yes', no path is used, 
                                           but the repository is taken either 
                                           from the CK directory or from CK_LOCAL_REPO

              (import)                   - if 'yes', register repo in the current directory in CK
                                           (when received from someone else)

              (remote)                   - if 'yes', remote repository
              (remote_repo_uoa)          - if !='' and type=='remote' repository UOA on the remote CK server

              (shared)                   - if not remote and =='git', repo is shared/synced through GIT
              (share)                    - (for user-friendly CMD) if 'yes', set shared=git

              (allow_writing)            - if 'yes', allow writing 
                                           (useful when kernel is set to allow writing only to such repositories)

              (url)                      - if type=='remote' or 'git', URL of remote repository or git repository
              (hostname)                 - if !='', automatically form url above (add http:// + /ck?)
              (port)                     - if !='', automatically add to url above
              (hostext)                  - if !='', add to the end of above URL instead of '/ck?' -
                                           useful when CK server is accessed via Apache2, IIS, Nginx or other web servers

              (githubuser)               - if shared repo, use this GitHub user space instead of default ""ctuning""
              (sync)                     - if 'yes' and type=='git', sync repo after each write operation

              (gitzip)                   - if 'yes', download as zip from GitHub
              (zip)                      - path to zipfile (local or remote http/ftp)
              (overwrite)                - if 'yes', overwrite files when unarchiving

              (repo_deps)                - dict with dependencies on other shared repositories with following keys:
                                             ""repo_uoa""
                                             (""repo_uid"") - specific UID (version) of a repo
                                             (""repo_url"") - URL of the shared repository (if not from github.com/ctuning)

              (quiet)                    - if 'yes', do not ask questions unless really needed

              (skip_reusing_remote_info) - if 'yes', do not reuse remote .cmr.json description of a repository

              (current_repos)            - if resolving dependencies on other repos, list of repos being updated (to avoid infinite recursion)

              (describe)                 - describe repository for Artifact Evaluation (see http://cTuning.org/ae)

              (stable)        - take stable version (highly experimental)
              (version)       - checkout version (default - stable)
              (branch)        - git branch
              (checkout)      - git checkout
            }

    Output: {
              return       - return code =  0, if successful
                                           16, repository with a given path is already registered in CK
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Note' 'that' 'we' 'can' 't' 'create' 'repos' 'in' 'parallel' '('
 'recording' 'to' 'repo' 'cache' 'may' 'fail' ')' '.' 'However' 'for'
 'now' 'we' 'do' 'not' 'expect' 'such' 'cases' '(' 'i' '.' 'e' '.' 'repos'
 'are' 'created' 'rarely' ')']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L37-L547
ctuning/ck,ck/repo/module/repo/module.py,update,"def update(i):
    """"""
    Update repository info

    Input:  {
              data_uoa                   - data UOA of the repo

              (shared)                   - if not remote and =='git', shared through GIT

              (url)                      - if type=='git', URL of remote repository or git repository
              (hostname)                 - if !='', automatically form url above (add http:// + /ck?)
              (port)                     - if !='', automatically add to url above
              (hostext)                  - if !='', add to the end of above URL instead of '/ck?' -
                                           useful when CK server is accessed via Apache2, IIS, Nginx or other web servers

              (sync)                     - if 'yes' and type=='git', sync repo after each write operation
              (allow_writing)            - if 'yes', allow writing 
                                           (useful when kernel is set to allow writing only to such repositories)

              (repo_deps)                - dict with dependencies on other shared repositories with following keys:
                                             ""repo_uoa""
                                             (""repo_uid"") - specific UID (version) of a repo
                                             (""repo_url"") - URL of the shared repository (if not from github.com/ctuning)

              (update)                   - if 'yes', force updating

              (describe)                 - describe repository for Artifact Evaluation (see http://cTuning.org/ae)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=ck.check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    duoa=i.get('data_uoa','')

    remote=i.get('remote','')
    rruoa=i.get('remote_repo_uoa','')
    shared=i.get('shared','')
    sync=i.get('sync','')

    rx=form_url(i)
    if rx['return']>0: return rx
    url=rx['url']

    rdeps=i.get('repo_deps',[])

    eaw=i.get('allow_writing','')

    # Get configuration (not from Cache - can be outdated info!)
#    r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':duoa})
    if r['return']>0: return r

    p=r.get('dict',{}).get('path','')

    dn=r.get('data_name','')
    d=r['dict']

    remote=d.get('remote','')

    changed=False

    # Check user-friendly name
    if dn!='':
       ck.out('Current user-friendly name of this repository: '+dn)
       ck.out('')

    r=ck.inp({'text':'Enter a user-friendly name of this repository (or Enter to keep old value): '})
    x=r['string']
    if x!='': 
       dn=x
       changed=True

    # If remote, update URL
    shared=d.get('shared','')
    if remote=='yes':
       url=d.get('url','')
       ck.out('Repository is remote ...')
       ck.out('')
       ck.out('Current URL: '+url)
       ck.out('')
       rx=ck.inp({'text':'Enter new URL (or Enter to leave old one): '})
       x=rx['string']
       if x!='': 
          d['url']=x
          changed=True
    elif shared!='':
       url=d.get('url','')
       ck.out('Repository is shared ...')
       ck.out('')
       ck.out('Current URL: '+url)

       if shared=='git':
          sync=d.get('sync','')
          ck.out('')
          if sync!='':
             ck.out('Current sync setting: '+sync)
          r=ck.inp({'text': 'Would you like to sync repo each time after writing to it (y/N)?: '})
          x=r['string'].lower()
          if x=='yes' or x=='y':
             d['sync']='yes'
             changed=True

    # Asking about forbidding explicit writing to this repository
    if remote!='yes' and eaw=='':
       if eaw=='': eaw=d.get('allow_writing','')
       ck.out('')
       if eaw!='':
          ck.out('Current ""allow writing"" setting: '+eaw)

       r=ck.inp({'text':'Would you like to allow explicit writing to this repository when kernel disables all writing (y/N): '})
       x=r['string'].lower()
       if x=='yes' or x=='y':
          d['allow_writing']='yes'
          changed=True

    # Check if explicit deps
    if len(rdeps)>0:
       if 'repo_deps' not in d: d['repo_deps']=rdeps
       else: 
          for q in rdeps:
              d['repo_deps'].append(q)
       changed=True

    # Print deps
    rdeps=d.get('repo_deps',[])
    if len(rdeps)>0:
       ck.out('')
       ck.out('Current dependencies on other repositories:')
       r=print_deps({'repo_deps':rdeps, 'out':o, 'out_prefix':'  '})
       if r['return']>0: return r
       ck.out('')

    # Check if add more deps
    r=add_more_deps({})
    if r['return']>0: return r

    rdeps1=r['repo_deps']
    if len(rdeps1)>0:
       if 'repo_deps' not in d: d['repo_deps']=rdeps1
       else: 
          for q in rdeps1:
              d['repo_deps'].append(q)
       changed=True

    # Check if need to describe for Artifact Evaluation
    if i.get('describe','')=='yes':
       r=describe({'dict':d})
       if r['return']>0: return r
       changed=True

    # Write if changed
    if changed or i.get('update','')=='yes':
       if o=='con':
          ck.out('')
          ck.out('Updating repo info ...')

       rx=ck.access({'action':'update',
                     'module_uoa':ck.cfg['repo_name'],
                     'data_uoa':duoa,
                     'data_name':dn,
                     'dict':d,
                     'common_func':'yes',
                     'overwrite':'yes'})
       if rx['return']>0: return rx

       # Recaching
       if o=='con':
          ck.out('')
          ck.out('Recaching repos to speed up access ...')
          ck.out('')
       r=recache({'out':o})
       if r['return']>0: return r

       # Updating local repository description
       if remote!='yes':
          r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
          if r['return']>0: return r

          del(r['return'])
          if 'path_to_repo_desc' in r: del (r['path_to_repo_desc'])        # Avoid recording some local info
          if r.get('dict',{}).get('path','')!='': del (r['dict']['path'])  # Avoid recording some local info

          py=os.path.join(p, ck.cfg['repo_file'])

          ry=ck.save_json_to_file({'json_file':py, 'dict':r})
          if ry['return']>0: return ry

    return {'return':0}",python,"def update(i):
    """"""
    Update repository info

    Input:  {
              data_uoa                   - data UOA of the repo

              (shared)                   - if not remote and =='git', shared through GIT

              (url)                      - if type=='git', URL of remote repository or git repository
              (hostname)                 - if !='', automatically form url above (add http:// + /ck?)
              (port)                     - if !='', automatically add to url above
              (hostext)                  - if !='', add to the end of above URL instead of '/ck?' -
                                           useful when CK server is accessed via Apache2, IIS, Nginx or other web servers

              (sync)                     - if 'yes' and type=='git', sync repo after each write operation
              (allow_writing)            - if 'yes', allow writing 
                                           (useful when kernel is set to allow writing only to such repositories)

              (repo_deps)                - dict with dependencies on other shared repositories with following keys:
                                             ""repo_uoa""
                                             (""repo_uid"") - specific UID (version) of a repo
                                             (""repo_url"") - URL of the shared repository (if not from github.com/ctuning)

              (update)                   - if 'yes', force updating

              (describe)                 - describe repository for Artifact Evaluation (see http://cTuning.org/ae)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=ck.check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    duoa=i.get('data_uoa','')

    remote=i.get('remote','')
    rruoa=i.get('remote_repo_uoa','')
    shared=i.get('shared','')
    sync=i.get('sync','')

    rx=form_url(i)
    if rx['return']>0: return rx
    url=rx['url']

    rdeps=i.get('repo_deps',[])

    eaw=i.get('allow_writing','')

    # Get configuration (not from Cache - can be outdated info!)
#    r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':duoa})
    if r['return']>0: return r

    p=r.get('dict',{}).get('path','')

    dn=r.get('data_name','')
    d=r['dict']

    remote=d.get('remote','')

    changed=False

    # Check user-friendly name
    if dn!='':
       ck.out('Current user-friendly name of this repository: '+dn)
       ck.out('')

    r=ck.inp({'text':'Enter a user-friendly name of this repository (or Enter to keep old value): '})
    x=r['string']
    if x!='': 
       dn=x
       changed=True

    # If remote, update URL
    shared=d.get('shared','')
    if remote=='yes':
       url=d.get('url','')
       ck.out('Repository is remote ...')
       ck.out('')
       ck.out('Current URL: '+url)
       ck.out('')
       rx=ck.inp({'text':'Enter new URL (or Enter to leave old one): '})
       x=rx['string']
       if x!='': 
          d['url']=x
          changed=True
    elif shared!='':
       url=d.get('url','')
       ck.out('Repository is shared ...')
       ck.out('')
       ck.out('Current URL: '+url)

       if shared=='git':
          sync=d.get('sync','')
          ck.out('')
          if sync!='':
             ck.out('Current sync setting: '+sync)
          r=ck.inp({'text': 'Would you like to sync repo each time after writing to it (y/N)?: '})
          x=r['string'].lower()
          if x=='yes' or x=='y':
             d['sync']='yes'
             changed=True

    # Asking about forbidding explicit writing to this repository
    if remote!='yes' and eaw=='':
       if eaw=='': eaw=d.get('allow_writing','')
       ck.out('')
       if eaw!='':
          ck.out('Current ""allow writing"" setting: '+eaw)

       r=ck.inp({'text':'Would you like to allow explicit writing to this repository when kernel disables all writing (y/N): '})
       x=r['string'].lower()
       if x=='yes' or x=='y':
          d['allow_writing']='yes'
          changed=True

    # Check if explicit deps
    if len(rdeps)>0:
       if 'repo_deps' not in d: d['repo_deps']=rdeps
       else: 
          for q in rdeps:
              d['repo_deps'].append(q)
       changed=True

    # Print deps
    rdeps=d.get('repo_deps',[])
    if len(rdeps)>0:
       ck.out('')
       ck.out('Current dependencies on other repositories:')
       r=print_deps({'repo_deps':rdeps, 'out':o, 'out_prefix':'  '})
       if r['return']>0: return r
       ck.out('')

    # Check if add more deps
    r=add_more_deps({})
    if r['return']>0: return r

    rdeps1=r['repo_deps']
    if len(rdeps1)>0:
       if 'repo_deps' not in d: d['repo_deps']=rdeps1
       else: 
          for q in rdeps1:
              d['repo_deps'].append(q)
       changed=True

    # Check if need to describe for Artifact Evaluation
    if i.get('describe','')=='yes':
       r=describe({'dict':d})
       if r['return']>0: return r
       changed=True

    # Write if changed
    if changed or i.get('update','')=='yes':
       if o=='con':
          ck.out('')
          ck.out('Updating repo info ...')

       rx=ck.access({'action':'update',
                     'module_uoa':ck.cfg['repo_name'],
                     'data_uoa':duoa,
                     'data_name':dn,
                     'dict':d,
                     'common_func':'yes',
                     'overwrite':'yes'})
       if rx['return']>0: return rx

       # Recaching
       if o=='con':
          ck.out('')
          ck.out('Recaching repos to speed up access ...')
          ck.out('')
       r=recache({'out':o})
       if r['return']>0: return r

       # Updating local repository description
       if remote!='yes':
          r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
          if r['return']>0: return r

          del(r['return'])
          if 'path_to_repo_desc' in r: del (r['path_to_repo_desc'])        # Avoid recording some local info
          if r.get('dict',{}).get('path','')!='': del (r['dict']['path'])  # Avoid recording some local info

          py=os.path.join(p, ck.cfg['repo_file'])

          ry=ck.save_json_to_file({'json_file':py, 'dict':r})
          if ry['return']>0: return ry

    return {'return':0}","['def' 'update' '(' 'i' ')' ':' '# Check if global writing is allowed' 'r'
 '=' 'ck' '.' 'check_writing' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']'
 '>' '0' ':' 'return' 'r' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')'
 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'remote' '=' 'i'
 '.' 'get' '(' ""'remote'"" ',' ""''"" ')' 'rruoa' '=' 'i' '.' 'get' '('
 ""'remote_repo_uoa'"" ',' ""''"" ')' 'shared' '=' 'i' '.' 'get' '('
 ""'shared'"" ',' ""''"" ')' 'sync' '=' 'i' '.' 'get' '(' ""'sync'"" ',' ""''""
 ')' 'rx' '=' 'form_url' '(' 'i' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'rx' 'url' '=' 'rx' '[' ""'url'"" ']' 'rdeps' '=' 'i' '.'
 'get' '(' ""'repo_deps'"" ',' '[' ']' ')' 'eaw' '=' 'i' '.' 'get' '('
 ""'allow_writing'"" ',' ""''"" ')'
 '# Get configuration (not from Cache - can be outdated info!)'
 ""#    r=ck.load_repo_info_from_cache({'repo_uoa':duoa})"" 'r' '=' 'ck' '.'
 'access' '(' '{' ""'action'"" ':' ""'load'"" ',' ""'module_uoa'"" ':' 'work'
 '[' ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'p' '=' 'r' '.' 'get' '('
 ""'dict'"" ',' '{' '}' ')' '.' 'get' '(' ""'path'"" ',' ""''"" ')' 'dn' '=' 'r'
 '.' 'get' '(' ""'data_name'"" ',' ""''"" ')' 'd' '=' 'r' '[' ""'dict'"" ']'
 'remote' '=' 'd' '.' 'get' '(' ""'remote'"" ',' ""''"" ')' 'changed' '='
 'False' '# Check user-friendly name' 'if' 'dn' '!=' ""''"" ':' 'ck' '.'
 'out' '(' ""'Current user-friendly name of this repository: '"" '+' 'dn'
 ')' 'ck' '.' 'out' '(' ""''"" ')' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'""
 ':'
 ""'Enter a user-friendly name of this repository (or Enter to keep old value): '""
 '}' ')' 'x' '=' 'r' '[' ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'dn' '='
 'x' 'changed' '=' 'True' '# If remote, update URL' 'shared' '=' 'd' '.'
 'get' '(' ""'shared'"" ',' ""''"" ')' 'if' 'remote' '==' ""'yes'"" ':' 'url'
 '=' 'd' '.' 'get' '(' ""'url'"" ',' ""''"" ')' 'ck' '.' 'out' '('
 ""'Repository is remote ...'"" ')' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.'
 'out' '(' ""'Current URL: '"" '+' 'url' ')' 'ck' '.' 'out' '(' ""''"" ')'
 'rx' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Enter new URL (or Enter to leave old one): '"" '}' ')' 'x' '=' 'rx' '['
 ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'd' '[' ""'url'"" ']' '=' 'x'
 'changed' '=' 'True' 'elif' 'shared' '!=' ""''"" ':' 'url' '=' 'd' '.'
 'get' '(' ""'url'"" ',' ""''"" ')' 'ck' '.' 'out' '('
 ""'Repository is shared ...'"" ')' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.'
 'out' '(' ""'Current URL: '"" '+' 'url' ')' 'if' 'shared' '==' ""'git'"" ':'
 'sync' '=' 'd' '.' 'get' '(' ""'sync'"" ',' ""''"" ')' 'ck' '.' 'out' '('
 ""''"" ')' 'if' 'sync' '!=' ""''"" ':' 'ck' '.' 'out' '('
 ""'Current sync setting: '"" '+' 'sync' ')' 'r' '=' 'ck' '.' 'inp' '(' '{'
 ""'text'"" ':'
 ""'Would you like to sync repo each time after writing to it (y/N)?: '""
 '}' ')' 'x' '=' 'r' '[' ""'string'"" ']' '.' 'lower' '(' ')' 'if' 'x' '=='
 ""'yes'"" 'or' 'x' '==' ""'y'"" ':' 'd' '[' ""'sync'"" ']' '=' ""'yes'""
 'changed' '=' 'True'
 '# Asking about forbidding explicit writing to this repository' 'if'
 'remote' '!=' ""'yes'"" 'and' 'eaw' '==' ""''"" ':' 'if' 'eaw' '==' ""''"" ':'
 'eaw' '=' 'd' '.' 'get' '(' ""'allow_writing'"" ',' ""''"" ')' 'ck' '.' 'out'
 '(' ""''"" ')' 'if' 'eaw' '!=' ""''"" ':' 'ck' '.' 'out' '('
 '\'Current ""allow writing"" setting: \'' '+' 'eaw' ')' 'r' '=' 'ck' '.'
 'inp' '(' '{' ""'text'"" ':'
 ""'Would you like to allow explicit writing to this repository when kernel disables all writing (y/N): '""
 '}' ')' 'x' '=' 'r' '[' ""'string'"" ']' '.' 'lower' '(' ')' 'if' 'x' '=='
 ""'yes'"" 'or' 'x' '==' ""'y'"" ':' 'd' '[' ""'allow_writing'"" ']' '=' ""'yes'""
 'changed' '=' 'True' '# Check if explicit deps' 'if' 'len' '(' 'rdeps'
 ')' '>' '0' ':' 'if' ""'repo_deps'"" 'not' 'in' 'd' ':' 'd' '['
 ""'repo_deps'"" ']' '=' 'rdeps' 'else' ':' 'for' 'q' 'in' 'rdeps' ':' 'd'
 '[' ""'repo_deps'"" ']' '.' 'append' '(' 'q' ')' 'changed' '=' 'True'
 '# Print deps' 'rdeps' '=' 'd' '.' 'get' '(' ""'repo_deps'"" ',' '[' ']'
 ')' 'if' 'len' '(' 'rdeps' ')' '>' '0' ':' 'ck' '.' 'out' '(' ""''"" ')'
 'ck' '.' 'out' '(' ""'Current dependencies on other repositories:'"" ')'
 'r' '=' 'print_deps' '(' '{' ""'repo_deps'"" ':' 'rdeps' ',' ""'out'"" ':'
 'o' ',' ""'out_prefix'"" ':' ""'  '"" '}' ')' 'if' 'r' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'r' 'ck' '.' 'out' '(' ""''"" ')'
 '# Check if add more deps' 'r' '=' 'add_more_deps' '(' '{' '}' ')' 'if'
 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'rdeps1' '=' 'r' '['
 ""'repo_deps'"" ']' 'if' 'len' '(' 'rdeps1' ')' '>' '0' ':' 'if'
 ""'repo_deps'"" 'not' 'in' 'd' ':' 'd' '[' ""'repo_deps'"" ']' '=' 'rdeps1'
 'else' ':' 'for' 'q' 'in' 'rdeps1' ':' 'd' '[' ""'repo_deps'"" ']' '.'
 'append' '(' 'q' ')' 'changed' '=' 'True'
 '# Check if need to describe for Artifact Evaluation' 'if' 'i' '.' 'get'
 '(' ""'describe'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'r' '=' 'describe' '(' '{'
 ""'dict'"" ':' 'd' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return'
 'r' 'changed' '=' 'True' '# Write if changed' 'if' 'changed' 'or' 'i' '.'
 'get' '(' ""'update'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'if' 'o' '==' ""'con'""
 ':' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '('
 ""'Updating repo info ...'"" ')' 'rx' '=' 'ck' '.' 'access' '(' '{'
 ""'action'"" ':' ""'update'"" ',' ""'module_uoa'"" ':' 'ck' '.' 'cfg' '['
 ""'repo_name'"" ']' ',' ""'data_uoa'"" ':' 'duoa' ',' ""'data_name'"" ':' 'dn'
 ',' ""'dict'"" ':' 'd' ',' ""'common_func'"" ':' ""'yes'"" ',' ""'overwrite'""
 ':' ""'yes'"" '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return'
 'rx' '# Recaching' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '(' ""''"" ')'
 'ck' '.' 'out' '(' ""'Recaching repos to speed up access ...'"" ')' 'ck'
 '.' 'out' '(' ""''"" ')' 'r' '=' 'recache' '(' '{' ""'out'"" ':' 'o' '}' ')'
 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r'
 '# Updating local repository description' 'if' 'remote' '!=' ""'yes'"" ':'
 'r' '=' 'ck' '.' 'load_repo_info_from_cache' '(' '{' ""'repo_uoa'"" ':'
 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'del'
 '(' 'r' '[' ""'return'"" ']' ')' 'if' ""'path_to_repo_desc'"" 'in' 'r' ':'
 'del' '(' 'r' '[' ""'path_to_repo_desc'"" ']' ')'
 '# Avoid recording some local info' 'if' 'r' '.' 'get' '(' ""'dict'"" ','
 '{' '}' ')' '.' 'get' '(' ""'path'"" ',' ""''"" ')' '!=' ""''"" ':' 'del' '('
 'r' '[' ""'dict'"" ']' '[' ""'path'"" ']' ')'
 '# Avoid recording some local info' 'py' '=' 'os' '.' 'path' '.' 'join'
 '(' 'p' ',' 'ck' '.' 'cfg' '[' ""'repo_file'"" ']' ')' 'ry' '=' 'ck' '.'
 'save_json_to_file' '(' '{' ""'json_file'"" ':' 'py' ',' ""'dict'"" ':' 'r'
 '}' ')' 'if' 'ry' '[' ""'return'"" ']' '>' '0' ':' 'return' 'ry' 'return'
 '{' ""'return'"" ':' '0' '}']","Update repository info

    Input:  {
              data_uoa                   - data UOA of the repo

              (shared)                   - if not remote and =='git', shared through GIT

              (url)                      - if type=='git', URL of remote repository or git repository
              (hostname)                 - if !='', automatically form url above (add http:// + /ck?)
              (port)                     - if !='', automatically add to url above
              (hostext)                  - if !='', add to the end of above URL instead of '/ck?' -
                                           useful when CK server is accessed via Apache2, IIS, Nginx or other web servers

              (sync)                     - if 'yes' and type=='git', sync repo after each write operation
              (allow_writing)            - if 'yes', allow writing 
                                           (useful when kernel is set to allow writing only to such repositories)

              (repo_deps)                - dict with dependencies on other shared repositories with following keys:
                                             ""repo_uoa""
                                             (""repo_uid"") - specific UID (version) of a repo
                                             (""repo_url"") - URL of the shared repository (if not from github.com/ctuning)

              (update)                   - if 'yes', force updating

              (describe)                 - describe repository for Artifact Evaluation (see http://cTuning.org/ae)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Update' 'repository' 'info'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L552-L752
ctuning/ck,ck/repo/module/repo/module.py,pull,"def pull(i):
    """"""
    Input:  {
              (path)  - repo UOA (where to create entry)
              (type)  - type
              (url)   - URL

                or

              (data_uoa)      - repo UOA

              (clone)         - if 'yes', clone repo instead of update

              (current_repos) - if resolving dependencies on other repos, list of repos being updated (to avoid infinite recursion)

              (git)           - if 'yes', use git protocol instead of https

              (ignore_pull)   - useful just for switching to another branch

              (stable)        - take stable version (highly experimental)
              (version)       - checkout version (default - stable)
              (branch)        - git branch
              (checkout)      - git checkout
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    xrecache=False

    pp=[]
    px=i.get('path','')
    t=i.get('type','')
    url=i.get('url','')

    stable=i.get('stable','')
    version=i.get('version','')
    if stable=='yes': version='stable'
    branch=i.get('branch','')
    checkout=i.get('checkout','')

    ip=i.get('ignore_pull','')

    cr=i.get('current_repos',[])

    tt='pull'
    if i.get('clone','')=='yes': tt='clone'

    if px!='': 
       pp.append({'path':px, 'type':t, 'url':url})

    uoa=i.get('data_uoa','')

    cids=i.get('cids',[])
    if len(cids)>0 and uoa=='': 
       uoa=cids[0]

    # If url is not empty and uoa is empty, get name from URL:
    if url!='' and uoa=='' and px=='':
       ix=url.rfind('/')
       if ix>0:
          uoa=url[ix+1:]
          if uoa.endswith('.git'):
             uoa=uoa[:-4]

          i['data_uoa']=uoa

    if uoa=='' and len(pp)==0 and url=='': 
       uoa='*'

    if uoa!='':
       if uoa.find('*')>=0 or uoa.find('?')>=0:
          r=ck.list_data({'module_uoa':work['self_module_uoa'], 'data_uoa':uoa})
          if r['return']>0: return r

          lst=r['lst']
          for q in lst:
              # Loading repo
              r=ck.access({'action':'load',
                           'module_uoa':work['self_module_uoa'],
                           'data_uoa':q['data_uoa'],
                           'common':'yes'})
              if r['return']>0: return r
              d=r['dict']
              t=d.get('shared','')
              duoa=r['data_uoa']

              if d.get('recache','')=='yes':
                 xrecache=True

              if t!='':
                 p=d.get('path','')
                 url=d.get('url','')
                 checkouts=d.get('checkouts',{})
                 pp.append({'path':p, 'type':t, 'url':url, 'data_uoa':duoa, 'checkouts':checkouts})
       else:
          # Loading repo
          r=ck.access({'action':'load',
                       'module_uoa':work['self_module_uoa'],
                       'data_uoa':uoa,
                       'common':'yes'})
          if r['return']>0: 
             if r['return']==16:
                # If not found, try to add from GIT

                i['action']='add'
                i['shared']='yes'
                x=i.get('quiet','')
                if x=='': x='yes'
                i['quiet']=x
                i['current_repos']=cr

                return add(i)
             else:
                return r

          d=r['dict']
          duoa=r['data_uoa']

          if d.get('recache','')=='yes':
             xrecache=True

          p=d['path']
          t=d.get('shared','')
          url=d.get('url','')
          checkouts=d.get('checkouts',{})

          pp.append({'path':p, 'type':t, 'url':url, 'data_uoa':duoa, 'checkouts':checkouts})

    # Updating ...
    for q in pp:
        p=q.get('path','')
        duoa=q.get('data_uoa','')
        t=q.get('type','')
        url=q.get('url','')

        # Semi hack (useful for Anton)
        if i.get('git','')=='yes':
           url=url.replace('https://','git@')

           j=url.find('/')
           if j>0:
              url=url[:j]+':'+url[j+1:]

           url+='.git'

        if o=='con' and tt!='clone':
           ck.out('******************************************************************')
           ck.out('Updating repo ""'+duoa+'"" ...')
           ck.out('')
           ck.out('  Local path: '+p)
           ck.out('  URL:        '+url)

        if t=='git':
           # Check if git is installed
           rq=ck.gen_tmp_file({})
           if rq['return']>0: return rq
           xfn=rq['file_name']

           os.system('git --version > '+xfn)

           rq=ck.load_text_file({'text_file':xfn, 
                                 'delete_after_read':'yes'})
           xs=''
           if rq['return']==0:
              xs=rq['string'].strip()

           if xs.find(' version ')<0:
              return{'return':1, 'error':'git command line client is not found - please, install it or download repo as zip'}

           # Continue
           try:
              px=os.getcwd()
           except OSError:
              from os.path import expanduser
              px=expanduser(""~"")

           if not os.path.isdir(p):
              os.makedirs(p)

           if o=='con':
              ck.out('')
              ck.out('  cd '+p)
           os.chdir(p)

           r=0
           if ip!='yes':
              s=ck.cfg['repo_types'][t][tt].replace('$#url#$', url).replace('$#path#$', p)

              if o=='con':
                 ck.out('  '+s)
                 ck.out('')

              r=os.system(s)

              if o=='con': 
                 ck.out('')

           os.chdir(px) # Restore path

           if r>0:
              if o=='con':
                 ck.out('')
                 ck.out(' WARNING: repository update likely failed OR IN A DIFFERENT BRANCH/CHECKOUT (git exit code: '+str(r)+')')
                 ck.out('')
                 rx=ck.inp({'text': 'Would you like to continue (Y/n)?: '})
                 x=rx['string'].lower()
                 if x=='n' or x=='no':
                    return {'return':1, 'error':'repository update likely failed - exit code '+str(r)}
              else:
                 return {'return':1, 'error':'repository update likely failed - exit code '+str(r)}
        else:
           if o=='con':
              ck.out('CK warning: this repository is not shared!')

        # Check deps
        if tt!='clone': # clone is done in add ...
           if o=='con':
              ck.out('  ========================================')
              ck.out('  Checking dependencies on other repos ...')
              ck.out('')

           r=deps({'path':p,
                   'current_path':cr,
                   'how':'pull',
                   'version':version,
                   'branch':branch,
                   'checkout':checkout,
                   'out':o})
           if r['return']>0: return r

    # Re-caching ...
    if xrecache:
       if o=='con':
          ck.out('  ==============================================')
          ck.out('  At least one repository requires recaching ...')
          ck.out('')

       r=recache({'out':o})
       if r['return']>0: return r

    return {'return':0}",python,"def pull(i):
    """"""
    Input:  {
              (path)  - repo UOA (where to create entry)
              (type)  - type
              (url)   - URL

                or

              (data_uoa)      - repo UOA

              (clone)         - if 'yes', clone repo instead of update

              (current_repos) - if resolving dependencies on other repos, list of repos being updated (to avoid infinite recursion)

              (git)           - if 'yes', use git protocol instead of https

              (ignore_pull)   - useful just for switching to another branch

              (stable)        - take stable version (highly experimental)
              (version)       - checkout version (default - stable)
              (branch)        - git branch
              (checkout)      - git checkout
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    xrecache=False

    pp=[]
    px=i.get('path','')
    t=i.get('type','')
    url=i.get('url','')

    stable=i.get('stable','')
    version=i.get('version','')
    if stable=='yes': version='stable'
    branch=i.get('branch','')
    checkout=i.get('checkout','')

    ip=i.get('ignore_pull','')

    cr=i.get('current_repos',[])

    tt='pull'
    if i.get('clone','')=='yes': tt='clone'

    if px!='': 
       pp.append({'path':px, 'type':t, 'url':url})

    uoa=i.get('data_uoa','')

    cids=i.get('cids',[])
    if len(cids)>0 and uoa=='': 
       uoa=cids[0]

    # If url is not empty and uoa is empty, get name from URL:
    if url!='' and uoa=='' and px=='':
       ix=url.rfind('/')
       if ix>0:
          uoa=url[ix+1:]
          if uoa.endswith('.git'):
             uoa=uoa[:-4]

          i['data_uoa']=uoa

    if uoa=='' and len(pp)==0 and url=='': 
       uoa='*'

    if uoa!='':
       if uoa.find('*')>=0 or uoa.find('?')>=0:
          r=ck.list_data({'module_uoa':work['self_module_uoa'], 'data_uoa':uoa})
          if r['return']>0: return r

          lst=r['lst']
          for q in lst:
              # Loading repo
              r=ck.access({'action':'load',
                           'module_uoa':work['self_module_uoa'],
                           'data_uoa':q['data_uoa'],
                           'common':'yes'})
              if r['return']>0: return r
              d=r['dict']
              t=d.get('shared','')
              duoa=r['data_uoa']

              if d.get('recache','')=='yes':
                 xrecache=True

              if t!='':
                 p=d.get('path','')
                 url=d.get('url','')
                 checkouts=d.get('checkouts',{})
                 pp.append({'path':p, 'type':t, 'url':url, 'data_uoa':duoa, 'checkouts':checkouts})
       else:
          # Loading repo
          r=ck.access({'action':'load',
                       'module_uoa':work['self_module_uoa'],
                       'data_uoa':uoa,
                       'common':'yes'})
          if r['return']>0: 
             if r['return']==16:
                # If not found, try to add from GIT

                i['action']='add'
                i['shared']='yes'
                x=i.get('quiet','')
                if x=='': x='yes'
                i['quiet']=x
                i['current_repos']=cr

                return add(i)
             else:
                return r

          d=r['dict']
          duoa=r['data_uoa']

          if d.get('recache','')=='yes':
             xrecache=True

          p=d['path']
          t=d.get('shared','')
          url=d.get('url','')
          checkouts=d.get('checkouts',{})

          pp.append({'path':p, 'type':t, 'url':url, 'data_uoa':duoa, 'checkouts':checkouts})

    # Updating ...
    for q in pp:
        p=q.get('path','')
        duoa=q.get('data_uoa','')
        t=q.get('type','')
        url=q.get('url','')

        # Semi hack (useful for Anton)
        if i.get('git','')=='yes':
           url=url.replace('https://','git@')

           j=url.find('/')
           if j>0:
              url=url[:j]+':'+url[j+1:]

           url+='.git'

        if o=='con' and tt!='clone':
           ck.out('******************************************************************')
           ck.out('Updating repo ""'+duoa+'"" ...')
           ck.out('')
           ck.out('  Local path: '+p)
           ck.out('  URL:        '+url)

        if t=='git':
           # Check if git is installed
           rq=ck.gen_tmp_file({})
           if rq['return']>0: return rq
           xfn=rq['file_name']

           os.system('git --version > '+xfn)

           rq=ck.load_text_file({'text_file':xfn, 
                                 'delete_after_read':'yes'})
           xs=''
           if rq['return']==0:
              xs=rq['string'].strip()

           if xs.find(' version ')<0:
              return{'return':1, 'error':'git command line client is not found - please, install it or download repo as zip'}

           # Continue
           try:
              px=os.getcwd()
           except OSError:
              from os.path import expanduser
              px=expanduser(""~"")

           if not os.path.isdir(p):
              os.makedirs(p)

           if o=='con':
              ck.out('')
              ck.out('  cd '+p)
           os.chdir(p)

           r=0
           if ip!='yes':
              s=ck.cfg['repo_types'][t][tt].replace('$#url#$', url).replace('$#path#$', p)

              if o=='con':
                 ck.out('  '+s)
                 ck.out('')

              r=os.system(s)

              if o=='con': 
                 ck.out('')

           os.chdir(px) # Restore path

           if r>0:
              if o=='con':
                 ck.out('')
                 ck.out(' WARNING: repository update likely failed OR IN A DIFFERENT BRANCH/CHECKOUT (git exit code: '+str(r)+')')
                 ck.out('')
                 rx=ck.inp({'text': 'Would you like to continue (Y/n)?: '})
                 x=rx['string'].lower()
                 if x=='n' or x=='no':
                    return {'return':1, 'error':'repository update likely failed - exit code '+str(r)}
              else:
                 return {'return':1, 'error':'repository update likely failed - exit code '+str(r)}
        else:
           if o=='con':
              ck.out('CK warning: this repository is not shared!')

        # Check deps
        if tt!='clone': # clone is done in add ...
           if o=='con':
              ck.out('  ========================================')
              ck.out('  Checking dependencies on other repos ...')
              ck.out('')

           r=deps({'path':p,
                   'current_path':cr,
                   'how':'pull',
                   'version':version,
                   'branch':branch,
                   'checkout':checkout,
                   'out':o})
           if r['return']>0: return r

    # Re-caching ...
    if xrecache:
       if o=='con':
          ck.out('  ==============================================')
          ck.out('  At least one repository requires recaching ...')
          ck.out('')

       r=recache({'out':o})
       if r['return']>0: return r

    return {'return':0}",['def' 'pull' '(' ... ':' '0' '}'],"Input:  {
              (path)  - repo UOA (where to create entry)
              (type)  - type
              (url)   - URL

                or

              (data_uoa)      - repo UOA

              (clone)         - if 'yes', clone repo instead of update

              (current_repos) - if resolving dependencies on other repos, list of repos being updated (to avoid infinite recursion)

              (git)           - if 'yes', use git protocol instead of https

              (ignore_pull)   - useful just for switching to another branch

              (stable)        - take stable version (highly experimental)
              (version)       - checkout version (default - stable)
              (branch)        - git branch
              (checkout)      - git checkout
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'path' ')' '-' 'repo' 'UOA' '(' 'where' 'to' 'create'
 'entry' ')' '(' 'type' ')' '-' 'type' '(' 'url' ')' '-' 'URL']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L757-L1005
ctuning/ck,ck/repo/module/repo/module.py,push,"def push(i):
    """"""
    Input:  {
              (path)  - repo UOA (where to create entry)
              (type)  - type
              (url)   - URL

                or

              (data_uoa)  - repo UOA

              (clone) - if 'yes', clone repo instead of update
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    pp=[]
    px=i.get('path','')
    t=i.get('type','')
    url=i.get('url','')

    if px!='': 
       pp.append({'path':px, 'type':t, 'url':url})

    uoa=i.get('data_uoa','')
    cids=i.get('cids',[])
    if len(cids)>0: uoa=cids[0]

    if uoa=='' and len(pp)==0: uoa='*'

    if uoa!='':
       if uoa.find('*')>=0 or uoa.find('?')>=0:
          r=ck.list_data({'module_uoa':work['self_module_uoa'], 'data_uoa':uoa})
          if r['return']>0: return r

          lst=r['lst']
          for q in lst:
              # Loading repo
              r=ck.access({'action':'load',
                           'module_uoa':work['self_module_uoa'],
                           'data_uoa':q['data_uoa'],
                           'common':'yes'})
              if r['return']>0: return r
              d=r['dict']
              t=d.get('shared','')
              if t!='':
                 p=d.get('path','')
                 url=d.get('url','')
                 pp.append({'path':p, 'type':t, 'url':url})
       else:
          # Loading repo
          r=ck.access({'action':'load',
                       'module_uoa':work['self_module_uoa'],
                       'data_uoa':uoa,
                       'common':'yes'})
          if r['return']>0: return r
          d=r['dict']

          p=d['path']
          t=d.get('shared','')
          url=d.get('url','')

          pp.append({'path':p, 'type':t, 'url':url})

    # Pushing ...
    for q in pp:
        p=q.get('path','')
        t=q.get('type','')
        url=q.get('url','')

        if o=='con':
           ck.out('')
           ck.out('Trying to commit and push '+p+' ...')

        if t=='git':
           px=os.getcwd()

           if not os.path.isdir(p):
              return {'return':1, 'error':'local path to repository is not found'}

           if o=='con':
              ck.out('')
              ck.out('cd '+p+' ...')

           os.chdir(p)

           s=ck.cfg['repo_types'][t]['commit'].replace('$#url#$', url).replace('$#path#$', p)
           if o=='con':
              ck.out('')
              ck.out('Executing command: '+s)
              ck.out('')
           r=os.system(s)

           if o=='con': 
              ck.out('')

           s=ck.cfg['repo_types'][t]['push'].replace('$#url#$', url).replace('$#path#$', p)
           if o=='con':
              ck.out('')
              ck.out('Executing command: '+s)
              ck.out('')
           r=os.system(s)

           if o=='con': 
              ck.out('')

           os.chdir(px) # Restore path

           if r>0:
              if o=='con':
                 ck.out('')
                 ck.out(' WARNING: repository update likely failed - exit code '+str(r))
                 ck.out('')
                 rx=ck.inp({'text': 'Would you like to continue (Y/n)?: '})
                 x=rx['string'].lower()
                 if x=='n' or x=='no':
                    return {'return':1, 'error':'repository update likely failed - exit code '+str(r)}
              else:
                 return {'return':1, 'error':'repository update likely failed - exit code '+str(r)}
        else:
           if o=='con':
              ck.out('CK warning: this repository is not shared!')

    return {'return':0}",python,"def push(i):
    """"""
    Input:  {
              (path)  - repo UOA (where to create entry)
              (type)  - type
              (url)   - URL

                or

              (data_uoa)  - repo UOA

              (clone) - if 'yes', clone repo instead of update
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    pp=[]
    px=i.get('path','')
    t=i.get('type','')
    url=i.get('url','')

    if px!='': 
       pp.append({'path':px, 'type':t, 'url':url})

    uoa=i.get('data_uoa','')
    cids=i.get('cids',[])
    if len(cids)>0: uoa=cids[0]

    if uoa=='' and len(pp)==0: uoa='*'

    if uoa!='':
       if uoa.find('*')>=0 or uoa.find('?')>=0:
          r=ck.list_data({'module_uoa':work['self_module_uoa'], 'data_uoa':uoa})
          if r['return']>0: return r

          lst=r['lst']
          for q in lst:
              # Loading repo
              r=ck.access({'action':'load',
                           'module_uoa':work['self_module_uoa'],
                           'data_uoa':q['data_uoa'],
                           'common':'yes'})
              if r['return']>0: return r
              d=r['dict']
              t=d.get('shared','')
              if t!='':
                 p=d.get('path','')
                 url=d.get('url','')
                 pp.append({'path':p, 'type':t, 'url':url})
       else:
          # Loading repo
          r=ck.access({'action':'load',
                       'module_uoa':work['self_module_uoa'],
                       'data_uoa':uoa,
                       'common':'yes'})
          if r['return']>0: return r
          d=r['dict']

          p=d['path']
          t=d.get('shared','')
          url=d.get('url','')

          pp.append({'path':p, 'type':t, 'url':url})

    # Pushing ...
    for q in pp:
        p=q.get('path','')
        t=q.get('type','')
        url=q.get('url','')

        if o=='con':
           ck.out('')
           ck.out('Trying to commit and push '+p+' ...')

        if t=='git':
           px=os.getcwd()

           if not os.path.isdir(p):
              return {'return':1, 'error':'local path to repository is not found'}

           if o=='con':
              ck.out('')
              ck.out('cd '+p+' ...')

           os.chdir(p)

           s=ck.cfg['repo_types'][t]['commit'].replace('$#url#$', url).replace('$#path#$', p)
           if o=='con':
              ck.out('')
              ck.out('Executing command: '+s)
              ck.out('')
           r=os.system(s)

           if o=='con': 
              ck.out('')

           s=ck.cfg['repo_types'][t]['push'].replace('$#url#$', url).replace('$#path#$', p)
           if o=='con':
              ck.out('')
              ck.out('Executing command: '+s)
              ck.out('')
           r=os.system(s)

           if o=='con': 
              ck.out('')

           os.chdir(px) # Restore path

           if r>0:
              if o=='con':
                 ck.out('')
                 ck.out(' WARNING: repository update likely failed - exit code '+str(r))
                 ck.out('')
                 rx=ck.inp({'text': 'Would you like to continue (Y/n)?: '})
                 x=rx['string'].lower()
                 if x=='n' or x=='no':
                    return {'return':1, 'error':'repository update likely failed - exit code '+str(r)}
              else:
                 return {'return':1, 'error':'repository update likely failed - exit code '+str(r)}
        else:
           if o=='con':
              ck.out('CK warning: this repository is not shared!')

    return {'return':0}","['def' 'push' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'pp' '=' '[' ']' 'px' '=' 'i' '.' 'get' '(' ""'path'"" ',' ""''"" ')' 't'
 '=' 'i' '.' 'get' '(' ""'type'"" ',' ""''"" ')' 'url' '=' 'i' '.' 'get' '('
 ""'url'"" ',' ""''"" ')' 'if' 'px' '!=' ""''"" ':' 'pp' '.' 'append' '(' '{'
 ""'path'"" ':' 'px' ',' ""'type'"" ':' 't' ',' ""'url'"" ':' 'url' '}' ')'
 'uoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'cids' '=' 'i' '.'
 'get' '(' ""'cids'"" ',' '[' ']' ')' 'if' 'len' '(' 'cids' ')' '>' '0' ':'
 'uoa' '=' 'cids' '[' '0' ']' 'if' 'uoa' '==' ""''"" 'and' 'len' '(' 'pp'
 ')' '==' '0' ':' 'uoa' '=' ""'*'"" 'if' 'uoa' '!=' ""''"" ':' 'if' 'uoa' '.'
 'find' '(' ""'*'"" ')' '>=' '0' 'or' 'uoa' '.' 'find' '(' ""'?'"" ')' '>='
 '0' ':' 'r' '=' 'ck' '.' 'list_data' '(' '{' ""'module_uoa'"" ':' 'work'
 '[' ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'uoa' '}' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'lst' '=' 'r' '[' ""'lst'"" ']'
 'for' 'q' 'in' 'lst' ':' '# Loading repo' 'r' '=' 'ck' '.' 'access' '('
 '{' ""'action'"" ':' ""'load'"" ',' ""'module_uoa'"" ':' 'work' '['
 ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'q' '[' ""'data_uoa'"" ']' ','
 ""'common'"" ':' ""'yes'"" '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'd' '=' 'r' '[' ""'dict'"" ']' 't' '=' 'd' '.' 'get' '('
 ""'shared'"" ',' ""''"" ')' 'if' 't' '!=' ""''"" ':' 'p' '=' 'd' '.' 'get' '('
 ""'path'"" ',' ""''"" ')' 'url' '=' 'd' '.' 'get' '(' ""'url'"" ',' ""''"" ')'
 'pp' '.' 'append' '(' '{' ""'path'"" ':' 'p' ',' ""'type'"" ':' 't' ','
 ""'url'"" ':' 'url' '}' ')' 'else' ':' '# Loading repo' 'r' '=' 'ck' '.'
 'access' '(' '{' ""'action'"" ':' ""'load'"" ',' ""'module_uoa'"" ':' 'work'
 '[' ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'uoa' ',' ""'common'"" ':'
 ""'yes'"" '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'd'
 '=' 'r' '[' ""'dict'"" ']' 'p' '=' 'd' '[' ""'path'"" ']' 't' '=' 'd' '.'
 'get' '(' ""'shared'"" ',' ""''"" ')' 'url' '=' 'd' '.' 'get' '(' ""'url'"" ','
 ""''"" ')' 'pp' '.' 'append' '(' '{' ""'path'"" ':' 'p' ',' ""'type'"" ':' 't'
 ',' ""'url'"" ':' 'url' '}' ')' '# Pushing ...' 'for' 'q' 'in' 'pp' ':' 'p'
 '=' 'q' '.' 'get' '(' ""'path'"" ',' ""''"" ')' 't' '=' 'q' '.' 'get' '('
 ""'type'"" ',' ""''"" ')' 'url' '=' 'q' '.' 'get' '(' ""'url'"" ',' ""''"" ')'
 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '('
 ""'Trying to commit and push '"" '+' 'p' '+' ""' ...'"" ')' 'if' 't' '=='
 ""'git'"" ':' 'px' '=' 'os' '.' 'getcwd' '(' ')' 'if' 'not' 'os' '.' 'path'
 '.' 'isdir' '(' 'p' ')' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' ""'local path to repository is not found'"" '}' 'if' 'o' '==' ""'con'""
 ':' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '(' ""'cd '"" '+' 'p' '+'
 ""' ...'"" ')' 'os' '.' 'chdir' '(' 'p' ')' 's' '=' 'ck' '.' 'cfg' '['
 ""'repo_types'"" ']' '[' 't' ']' '[' ""'commit'"" ']' '.' 'replace' '('
 ""'$#url#$'"" ',' 'url' ')' '.' 'replace' '(' ""'$#path#$'"" ',' 'p' ')' 'if'
 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '('
 ""'Executing command: '"" '+' 's' ')' 'ck' '.' 'out' '(' ""''"" ')' 'r' '='
 'os' '.' 'system' '(' 's' ')' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out'
 '(' ""''"" ')' 's' '=' 'ck' '.' 'cfg' '[' ""'repo_types'"" ']' '[' 't' ']'
 '[' ""'push'"" ']' '.' 'replace' '(' ""'$#url#$'"" ',' 'url' ')' '.'
 'replace' '(' ""'$#path#$'"" ',' 'p' ')' 'if' 'o' '==' ""'con'"" ':' 'ck' '.'
 'out' '(' ""''"" ')' 'ck' '.' 'out' '(' ""'Executing command: '"" '+' 's' ')'
 'ck' '.' 'out' '(' ""''"" ')' 'r' '=' 'os' '.' 'system' '(' 's' ')' 'if'
 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '(' ""''"" ')' 'os' '.' 'chdir' '('
 'px' ')' '# Restore path' 'if' 'r' '>' '0' ':' 'if' 'o' '==' ""'con'"" ':'
 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '('
 ""' WARNING: repository update likely failed - exit code '"" '+' 'str' '('
 'r' ')' ')' 'ck' '.' 'out' '(' ""''"" ')' 'rx' '=' 'ck' '.' 'inp' '(' '{'
 ""'text'"" ':' ""'Would you like to continue (Y/n)?: '"" '}' ')' 'x' '=' 'rx'
 '[' ""'string'"" ']' '.' 'lower' '(' ')' 'if' 'x' '==' ""'n'"" 'or' 'x' '=='
 ""'no'"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'repository update likely failed - exit code '"" '+' 'str' '(' 'r' ')'
 '}' 'else' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'repository update likely failed - exit code '"" '+' 'str' '(' 'r' ')'
 '}' 'else' ':' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '('
 ""'CK warning: this repository is not shared!'"" ')' 'return' '{'
 ""'return'"" ':' '0' '}']","Input:  {
              (path)  - repo UOA (where to create entry)
              (type)  - type
              (url)   - URL

                or

              (data_uoa)  - repo UOA

              (clone) - if 'yes', clone repo instead of update
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'path' ')' '-' 'repo' 'UOA' '(' 'where' 'to' 'create'
 'entry' ')' '(' 'type' ')' '-' 'type' '(' 'url' ')' '-' 'URL']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L1010-L1141
ctuning/ck,ck/repo/module/repo/module.py,recache,"def recache(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    o=i.get('out','')

    # Listing all repos
    r=ck.access({'action':'list',
                 'module_uoa':ck.cfg['repo_name']})
    if r['return']>0: return r
    l=r['lst']

    cru={}
    cri={}

    # Processing repos
    # We need 2 passes (if some repos such as remote ones are referenced inside new repos)

    for ps in [0,1]:
        for q in l:
            if ps==0 or (ps==1 and q.get('processed','')!='yes'):
               ruoa=q['repo_uoa']
               muoa=q['module_uoa']
               duoa=q['data_uoa']
               duid=q['data_uid']

               # First try to load from cache to check that not remote ...
               remote=False
               rx=ck.load_repo_info_from_cache({'repo_uoa':duoa})
               if rx['return']==0: 
                  rd=rx.get('dict',{})
                  if rd.get('remote','')=='yes':
                     remote=True

               if not remote:
                  if duid==ck.cfg['repo_uid_default'] or duid==ck.cfg['repo_uid_local']:
                     if o=='con':
                        ck.out('Skipping repo '+duoa+' ...')
                  else:
                     if o=='con':
                        ck.out('Processing repo '+duoa+' ...')

                     # Repo dictionary (may be changing in .ckr.json)
                     dt={}

                     # Find real repo and get .ckr.json
                     rx=ck.access({'action':'where',
                                   'module_uoa':muoa,
                                   'data_uoa':duoa})
                     if rx['return']==0: 
                        pckr=os.path.join(rx['path'], ck.cfg['repo_file'])
                        if os.path.isfile(pckr):
                           rx=ck.load_json_file({'json_file':pckr})
                           if rx['return']>0: return rx

                           dt=rx['dict']['dict']

                     # Load extra info repo (do not use repo, since may not exist in cache)
                     rx=ck.access({'action':'load',
                                   'module_uoa':muoa,
                                   'data_uoa':duoa})
                     if rx['return']>0: 
                        if ps==0:
                           continue
                        else:
                           return rx

                     if len(dt)==0:
                        dt=rx['dict']
                     else:
                        if rx['dict'].get('path','')!='':
                           dt['path']=rx['dict']['path']

                     dname=rx['data_name']
                     dalias=rx['data_alias']
                     dp=rx['path']

                     if duoa!=duid:
                        cru[duoa]=duid

                     dd={'dict':dt}

                     dd['data_uid']=duid
                     dd['data_uoa']=duoa
                     dd['data_alias']=dalias
                     dd['data_name']=dname
                     dd['path_to_repo_desc']=dp

                     cri[duid]=dd

                  q['processed']='yes'

        # Recording 
        ck.cache_repo_uoa=cru
        ck.cache_repo_info=cri

        rx=ck.save_repo_cache({})
        if rx['return']>0: return rx

        rx=ck.reload_repo_cache({'force':'yes'})
        if rx['return']>0: return rx

    if o=='con':
       ck.out('')
       ck.out('Repositories were successfully recached!')

    return {'return':0}",python,"def recache(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    o=i.get('out','')

    # Listing all repos
    r=ck.access({'action':'list',
                 'module_uoa':ck.cfg['repo_name']})
    if r['return']>0: return r
    l=r['lst']

    cru={}
    cri={}

    # Processing repos
    # We need 2 passes (if some repos such as remote ones are referenced inside new repos)

    for ps in [0,1]:
        for q in l:
            if ps==0 or (ps==1 and q.get('processed','')!='yes'):
               ruoa=q['repo_uoa']
               muoa=q['module_uoa']
               duoa=q['data_uoa']
               duid=q['data_uid']

               # First try to load from cache to check that not remote ...
               remote=False
               rx=ck.load_repo_info_from_cache({'repo_uoa':duoa})
               if rx['return']==0: 
                  rd=rx.get('dict',{})
                  if rd.get('remote','')=='yes':
                     remote=True

               if not remote:
                  if duid==ck.cfg['repo_uid_default'] or duid==ck.cfg['repo_uid_local']:
                     if o=='con':
                        ck.out('Skipping repo '+duoa+' ...')
                  else:
                     if o=='con':
                        ck.out('Processing repo '+duoa+' ...')

                     # Repo dictionary (may be changing in .ckr.json)
                     dt={}

                     # Find real repo and get .ckr.json
                     rx=ck.access({'action':'where',
                                   'module_uoa':muoa,
                                   'data_uoa':duoa})
                     if rx['return']==0: 
                        pckr=os.path.join(rx['path'], ck.cfg['repo_file'])
                        if os.path.isfile(pckr):
                           rx=ck.load_json_file({'json_file':pckr})
                           if rx['return']>0: return rx

                           dt=rx['dict']['dict']

                     # Load extra info repo (do not use repo, since may not exist in cache)
                     rx=ck.access({'action':'load',
                                   'module_uoa':muoa,
                                   'data_uoa':duoa})
                     if rx['return']>0: 
                        if ps==0:
                           continue
                        else:
                           return rx

                     if len(dt)==0:
                        dt=rx['dict']
                     else:
                        if rx['dict'].get('path','')!='':
                           dt['path']=rx['dict']['path']

                     dname=rx['data_name']
                     dalias=rx['data_alias']
                     dp=rx['path']

                     if duoa!=duid:
                        cru[duoa]=duid

                     dd={'dict':dt}

                     dd['data_uid']=duid
                     dd['data_uoa']=duoa
                     dd['data_alias']=dalias
                     dd['data_name']=dname
                     dd['path_to_repo_desc']=dp

                     cri[duid]=dd

                  q['processed']='yes'

        # Recording 
        ck.cache_repo_uoa=cru
        ck.cache_repo_info=cri

        rx=ck.save_repo_cache({})
        if rx['return']>0: return rx

        rx=ck.reload_repo_cache({'force':'yes'})
        if rx['return']>0: return rx

    if o=='con':
       ck.out('')
       ck.out('Repositories were successfully recached!')

    return {'return':0}","['def' 'recache' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ','
 ""''"" ')' '# Listing all repos' 'r' '=' 'ck' '.' 'access' '(' '{'
 ""'action'"" ':' ""'list'"" ',' ""'module_uoa'"" ':' 'ck' '.' 'cfg' '['
 ""'repo_name'"" ']' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'l' '=' 'r' '[' ""'lst'"" ']' 'cru' '=' '{' '}' 'cri' '=' '{'
 '}' '# Processing repos'
 '# We need 2 passes (if some repos such as remote ones are referenced inside new repos)'
 'for' 'ps' 'in' '[' '0' ',' '1' ']' ':' 'for' 'q' 'in' 'l' ':' 'if' 'ps'
 '==' '0' 'or' '(' 'ps' '==' '1' 'and' 'q' '.' 'get' '(' ""'processed'"" ','
 ""''"" ')' '!=' ""'yes'"" ')' ':' 'ruoa' '=' 'q' '[' ""'repo_uoa'"" ']' 'muoa'
 '=' 'q' '[' ""'module_uoa'"" ']' 'duoa' '=' 'q' '[' ""'data_uoa'"" ']' 'duid'
 '=' 'q' '[' ""'data_uid'"" ']'
 '# First try to load from cache to check that not remote ...' 'remote'
 '=' 'False' 'rx' '=' 'ck' '.' 'load_repo_info_from_cache' '(' '{'
 ""'repo_uoa'"" ':' 'duoa' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '==' '0' ':'
 'rd' '=' 'rx' '.' 'get' '(' ""'dict'"" ',' '{' '}' ')' 'if' 'rd' '.' 'get'
 '(' ""'remote'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'remote' '=' 'True' 'if'
 'not' 'remote' ':' 'if' 'duid' '==' 'ck' '.' 'cfg' '['
 ""'repo_uid_default'"" ']' 'or' 'duid' '==' 'ck' '.' 'cfg' '['
 ""'repo_uid_local'"" ']' ':' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '('
 ""'Skipping repo '"" '+' 'duoa' '+' ""' ...'"" ')' 'else' ':' 'if' 'o' '=='
 ""'con'"" ':' 'ck' '.' 'out' '(' ""'Processing repo '"" '+' 'duoa' '+'
 ""' ...'"" ')' '# Repo dictionary (may be changing in .ckr.json)' 'dt' '='
 '{' '}' '# Find real repo and get .ckr.json' 'rx' '=' 'ck' '.' 'access'
 '(' '{' ""'action'"" ':' ""'where'"" ',' ""'module_uoa'"" ':' 'muoa' ','
 ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '==' '0' ':'
 'pckr' '=' 'os' '.' 'path' '.' 'join' '(' 'rx' '[' ""'path'"" ']' ',' 'ck'
 '.' 'cfg' '[' ""'repo_file'"" ']' ')' 'if' 'os' '.' 'path' '.' 'isfile' '('
 'pckr' ')' ':' 'rx' '=' 'ck' '.' 'load_json_file' '(' '{' ""'json_file'""
 ':' 'pckr' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx'
 'dt' '=' 'rx' '[' ""'dict'"" ']' '[' ""'dict'"" ']'
 '# Load extra info repo (do not use repo, since may not exist in cache)'
 'rx' '=' 'ck' '.' 'access' '(' '{' ""'action'"" ':' ""'load'"" ','
 ""'module_uoa'"" ':' 'muoa' ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'rx'
 '[' ""'return'"" ']' '>' '0' ':' 'if' 'ps' '==' '0' ':' 'continue' 'else'
 ':' 'return' 'rx' 'if' 'len' '(' 'dt' ')' '==' '0' ':' 'dt' '=' 'rx' '['
 ""'dict'"" ']' 'else' ':' 'if' 'rx' '[' ""'dict'"" ']' '.' 'get' '(' ""'path'""
 ',' ""''"" ')' '!=' ""''"" ':' 'dt' '[' ""'path'"" ']' '=' 'rx' '[' ""'dict'""
 ']' '[' ""'path'"" ']' 'dname' '=' 'rx' '[' ""'data_name'"" ']' 'dalias' '='
 'rx' '[' ""'data_alias'"" ']' 'dp' '=' 'rx' '[' ""'path'"" ']' 'if' 'duoa'
 '!=' 'duid' ':' 'cru' '[' 'duoa' ']' '=' 'duid' 'dd' '=' '{' ""'dict'"" ':'
 'dt' '}' 'dd' '[' ""'data_uid'"" ']' '=' 'duid' 'dd' '[' ""'data_uoa'"" ']'
 '=' 'duoa' 'dd' '[' ""'data_alias'"" ']' '=' 'dalias' 'dd' '['
 ""'data_name'"" ']' '=' 'dname' 'dd' '[' ""'path_to_repo_desc'"" ']' '=' 'dp'
 'cri' '[' 'duid' ']' '=' 'dd' 'q' '[' ""'processed'"" ']' '=' ""'yes'""
 '# Recording ' 'ck' '.' 'cache_repo_uoa' '=' 'cru' 'ck' '.'
 'cache_repo_info' '=' 'cri' 'rx' '=' 'ck' '.' 'save_repo_cache' '(' '{'
 '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'rx' '='
 'ck' '.' 'reload_repo_cache' '(' '{' ""'force'"" ':' ""'yes'"" '}' ')' 'if'
 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'if' 'o' '==' ""'con'""
 ':' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '('
 ""'Repositories were successfully recached!'"" ')' 'return' '{' ""'return'""
 ':' '0' '}']","Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L1157-L1270
ctuning/ck,ck/repo/module/repo/module.py,rm,"def rm(i):
    """"""
    Input:  {
              (repo_uoa)            - repo UOA (where to delete entry about repository)
              uoa                   - data UOA
              (force)               - if 'yes', force removal
              (with_files) or (all) - if 'yes', remove files as well
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    # Check if global writing is allowed
    r=ck.check_writing({})
    if r['return']>0: return r

    global cache_repo_uoa, cache_repo_info

    ruoa=i.get('repo_uoa','')
    uoa=i.get('data_uoa','')

    o=i.get('out','')

    if uoa=='': 
       return {'return':1, 'error':'UOA of the repository is not defined'}

    wf=i.get('with_files','')
    if wf=='': wf=i.get('all','')

    force=i.get('force','')

    r=ck.access({'action':'load',
                 'repo_uoa':ruoa,
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':uoa,
                 'common_func':'yes'})
    if r['return']>0: return r
    duid=r['data_uid']
    duoa=r['data_uoa']

    d=r['dict']
    p=d.get('path','')

    to_delete=True
    if o=='con' and force!='yes':
       r=ck.inp({'text':'Are you sure to delete information about repository '+duoa+' (y/N): '})
       c=r['string'].lower()
       if c!='yes' and c!='y': to_delete=False

    if to_delete and o=='con' and force!='yes' and wf=='yes':
       r=ck.inp({'text':'You indicated that you want to DELETE ALL ENTRIES IN THE REPOSITORY! Are you sure (y/N): '})
       x=r['string'].lower()
       if x!='yes' and x!='y': wf=''

    if to_delete:
       if o=='con': 
          ck.out('')
          ck.out('Reloading repo cache ...')
       r=ck.reload_repo_cache({}) # Ignore errors
       if r['return']>0: return r

       if o=='con': ck.out('Removing from cache ...')
       if duoa in ck.cache_repo_uoa: del (ck.cache_repo_uoa[duoa])
       if duid in ck.cache_repo_info: del (ck.cache_repo_info[duid])

       if o=='con': ck.out('Rewriting repo cache ...')
       r=ck.save_repo_cache({})
       if r['return']>0: return r

       if o=='con': ck.out('Removing entry ...')
       r=ck.access({'action':'remove',
                    'repo_uoa':ruoa,
                    'module_uoa':work['self_module_uoa'],
                    'data_uoa':uoa,
                    'common_func':'yes'})
       if r['return']>0: return r

       if wf=='yes' and p!='':
          if o=='con': ck.out('Removing entries from the repository ...')
          import shutil
          if os.path.isdir(p): 
             shutil.rmtree(p, onerror=ck.rm_read_only)

       if o=='con': 
          ck.out('')
          ck.out('Information about repository was removed successfully!')
          if wf!='yes':
             ck.out('Note: repository itself was not removed!')

    return {'return':0}",python,"def rm(i):
    """"""
    Input:  {
              (repo_uoa)            - repo UOA (where to delete entry about repository)
              uoa                   - data UOA
              (force)               - if 'yes', force removal
              (with_files) or (all) - if 'yes', remove files as well
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    # Check if global writing is allowed
    r=ck.check_writing({})
    if r['return']>0: return r

    global cache_repo_uoa, cache_repo_info

    ruoa=i.get('repo_uoa','')
    uoa=i.get('data_uoa','')

    o=i.get('out','')

    if uoa=='': 
       return {'return':1, 'error':'UOA of the repository is not defined'}

    wf=i.get('with_files','')
    if wf=='': wf=i.get('all','')

    force=i.get('force','')

    r=ck.access({'action':'load',
                 'repo_uoa':ruoa,
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':uoa,
                 'common_func':'yes'})
    if r['return']>0: return r
    duid=r['data_uid']
    duoa=r['data_uoa']

    d=r['dict']
    p=d.get('path','')

    to_delete=True
    if o=='con' and force!='yes':
       r=ck.inp({'text':'Are you sure to delete information about repository '+duoa+' (y/N): '})
       c=r['string'].lower()
       if c!='yes' and c!='y': to_delete=False

    if to_delete and o=='con' and force!='yes' and wf=='yes':
       r=ck.inp({'text':'You indicated that you want to DELETE ALL ENTRIES IN THE REPOSITORY! Are you sure (y/N): '})
       x=r['string'].lower()
       if x!='yes' and x!='y': wf=''

    if to_delete:
       if o=='con': 
          ck.out('')
          ck.out('Reloading repo cache ...')
       r=ck.reload_repo_cache({}) # Ignore errors
       if r['return']>0: return r

       if o=='con': ck.out('Removing from cache ...')
       if duoa in ck.cache_repo_uoa: del (ck.cache_repo_uoa[duoa])
       if duid in ck.cache_repo_info: del (ck.cache_repo_info[duid])

       if o=='con': ck.out('Rewriting repo cache ...')
       r=ck.save_repo_cache({})
       if r['return']>0: return r

       if o=='con': ck.out('Removing entry ...')
       r=ck.access({'action':'remove',
                    'repo_uoa':ruoa,
                    'module_uoa':work['self_module_uoa'],
                    'data_uoa':uoa,
                    'common_func':'yes'})
       if r['return']>0: return r

       if wf=='yes' and p!='':
          if o=='con': ck.out('Removing entries from the repository ...')
          import shutil
          if os.path.isdir(p): 
             shutil.rmtree(p, onerror=ck.rm_read_only)

       if o=='con': 
          ck.out('')
          ck.out('Information about repository was removed successfully!')
          if wf!='yes':
             ck.out('Note: repository itself was not removed!')

    return {'return':0}","['def' 'rm' '(' 'i' ')' ':' '# Check if global writing is allowed' 'r' '='
 'ck' '.' 'check_writing' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'r' 'global' 'cache_repo_uoa' ',' 'cache_repo_info'
 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'uoa' '=' 'i' '.'
 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ','
 ""''"" ')' 'if' 'uoa' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'UOA of the repository is not defined'"" '}' 'wf' '=' 'i'
 '.' 'get' '(' ""'with_files'"" ',' ""''"" ')' 'if' 'wf' '==' ""''"" ':' 'wf'
 '=' 'i' '.' 'get' '(' ""'all'"" ',' ""''"" ')' 'force' '=' 'i' '.' 'get' '('
 ""'force'"" ',' ""''"" ')' 'r' '=' 'ck' '.' 'access' '(' '{' ""'action'"" ':'
 ""'load'"" ',' ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'"" ':' 'work' '['
 ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'uoa' ',' ""'common_func'""
 ':' ""'yes'"" '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r'
 'duid' '=' 'r' '[' ""'data_uid'"" ']' 'duoa' '=' 'r' '[' ""'data_uoa'"" ']'
 'd' '=' 'r' '[' ""'dict'"" ']' 'p' '=' 'd' '.' 'get' '(' ""'path'"" ',' ""''""
 ')' 'to_delete' '=' 'True' 'if' 'o' '==' ""'con'"" 'and' 'force' '!='
 ""'yes'"" ':' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Are you sure to delete information about repository '"" '+' 'duoa' '+'
 ""' (y/N): '"" '}' ')' 'c' '=' 'r' '[' ""'string'"" ']' '.' 'lower' '(' ')'
 'if' 'c' '!=' ""'yes'"" 'and' 'c' '!=' ""'y'"" ':' 'to_delete' '=' 'False'
 'if' 'to_delete' 'and' 'o' '==' ""'con'"" 'and' 'force' '!=' ""'yes'"" 'and'
 'wf' '==' ""'yes'"" ':' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'You indicated that you want to DELETE ALL ENTRIES IN THE REPOSITORY! Are you sure (y/N): '""
 '}' ')' 'x' '=' 'r' '[' ""'string'"" ']' '.' 'lower' '(' ')' 'if' 'x' '!='
 ""'yes'"" 'and' 'x' '!=' ""'y'"" ':' 'wf' '=' ""''"" 'if' 'to_delete' ':' 'if'
 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '('
 ""'Reloading repo cache ...'"" ')' 'r' '=' 'ck' '.' 'reload_repo_cache' '('
 '{' '}' ')' '# Ignore errors' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '('
 ""'Removing from cache ...'"" ')' 'if' 'duoa' 'in' 'ck' '.'
 'cache_repo_uoa' ':' 'del' '(' 'ck' '.' 'cache_repo_uoa' '[' 'duoa' ']'
 ')' 'if' 'duid' 'in' 'ck' '.' 'cache_repo_info' ':' 'del' '(' 'ck' '.'
 'cache_repo_info' '[' 'duid' ']' ')' 'if' 'o' '==' ""'con'"" ':' 'ck' '.'
 'out' '(' ""'Rewriting repo cache ...'"" ')' 'r' '=' 'ck' '.'
 'save_repo_cache' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '('
 ""'Removing entry ...'"" ')' 'r' '=' 'ck' '.' 'access' '(' '{' ""'action'""
 ':' ""'remove'"" ',' ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'"" ':' 'work'
 '[' ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'uoa' ','
 ""'common_func'"" ':' ""'yes'"" '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' 'if' 'wf' '==' ""'yes'"" 'and' 'p' '!=' ""''"" ':' 'if' 'o'
 '==' ""'con'"" ':' 'ck' '.' 'out' '('
 ""'Removing entries from the repository ...'"" ')' 'import' 'shutil' 'if'
 'os' '.' 'path' '.' 'isdir' '(' 'p' ')' ':' 'shutil' '.' 'rmtree' '(' 'p'
 ',' 'onerror' '=' 'ck' '.' 'rm_read_only' ')' 'if' 'o' '==' ""'con'"" ':'
 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '('
 ""'Information about repository was removed successfully!'"" ')' 'if' 'wf'
 '!=' ""'yes'"" ':' 'ck' '.' 'out' '('
 ""'Note: repository itself was not removed!'"" ')' 'return' '{' ""'return'""
 ':' '0' '}']","Input:  {
              (repo_uoa)            - repo UOA (where to delete entry about repository)
              uoa                   - data UOA
              (force)               - if 'yes', force removal
              (with_files) or (all) - if 'yes', remove files as well
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' '(' 'where' 'to'
 'delete' 'entry' 'about' 'repository' ')' 'uoa' '-' 'data' 'UOA' '('
 'force' ')' '-' 'if' 'yes' 'force' 'removal' '(' 'with_files' ')' 'or'
 '(' 'all' ')' '-' 'if' 'yes' 'remove' 'files' 'as' 'well' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L1275-L1368
ctuning/ck,ck/repo/module/repo/module.py,where,"def where(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa=i.get('data_uoa','')
    r=ck.find_path_to_repo({'repo_uoa':duoa})
    if r['return']>0: return r

    d=r.get('dict',{})
    url=d.get('url','')

    p=r['path']
    if p=='':
       p=url

    if o=='con':
       ck.out(p)

    return r",python,"def where(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa=i.get('data_uoa','')
    r=ck.find_path_to_repo({'repo_uoa':duoa})
    if r['return']>0: return r

    d=r.get('dict',{})
    url=d.get('url','')

    p=r['path']
    if p=='':
       p=url

    if o=='con':
       ck.out(p)

    return r","['def' 'where' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'r' '=' 'ck'
 '.' 'find_path_to_repo' '(' '{' ""'repo_uoa'"" ':' 'duoa' '}' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'd' '=' 'r' '.' 'get' '('
 ""'dict'"" ',' '{' '}' ')' 'url' '=' 'd' '.' 'get' '(' ""'url'"" ',' ""''"" ')'
 'p' '=' 'r' '[' ""'path'"" ']' 'if' 'p' '==' ""''"" ':' 'p' '=' 'url' 'if'
 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '(' 'p' ')' 'return' 'r']","Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L1395-L1424
ctuning/ck,ck/repo/module/repo/module.py,zip,"def zip(i):
    """"""
    Input:  {
              data_uoa       - repo UOA

              (archive_path) - if '' create inside repo path

              (archive_name) - if !='' use it for zip name
              (auto_name)    - if 'yes', generate name name from data_uoa: ckr-<repo_uoa>.zip
              (bittorent)    - if 'yes', generate zip name for BitTorrent: ckr-<repo_uid>-YYYYMMDD.zip

              (overwrite)    - if 'yes', overwrite zip file
              (store)        - if 'yes', store files instead of packing


              (data)         - CID allowing to add only these entries with pattern (can be from another archive)

              (all)          - archive all files
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa1=i.get('data_uoa','')
    duid=''
    path=''

    if duoa1!='':
       # Find path to repo
       r=ck.find_path_to_repo({'repo_uoa':duoa1})
       if r['return']>0: return r

       duoa=r['repo_uoa']
       duid=r['repo_uid']
       path=r['path']

    an=i.get('archive_name','')
#    if an=='': an='ckr.zip'

    if i.get('auto_name','')=='yes':
       an='ckr'
       if duoa!='': an+='-'+duoa
       an+='.zip'
    elif i.get('bittorrent','')=='yes':
       import time
       an='ckr-'
       if duid!='': an+=duid
       an+='-'+time.strftime('%Y%m%d')+'.zip'
    elif an=='': 
       if duoa1=='': an='ckr.zip'
       else: an='ckr-'+duoa1+'.zip'

    ap=i.get('archive_path','')
#    if ap=='': ap=path

    pfn=os.path.join(ap, an)

    if pfn.startswith('~'):
       from os.path import expanduser
       home = expanduser(""~"")

       pfn=os.path.abspath(home+os.sep+pfn[1:])

    if os.path.isfile(pfn):
       if i.get('overwrite','')=='yes':
          os.remove(pfn)
       else:
          return {'return':1, 'error':'archive '+pfn+' already exists'}

    if o=='con':
       ck.out('Creating archive '+pfn+' - please wait, it may take some time ...')

    # Check all files
    ignore=[]
    if i.get('all','')!='yes':
       ignore=ck.cfg.get('ignore_directories_when_archive_repo',[])

    # Prepare archive
    import zipfile

    zip_method=zipfile.ZIP_DEFLATED
    if i.get('store','')=='yes':
       zip_method=zipfile.ZIP_STORED

    # Prepare list of files
    fl={}

    data=i.get('data','')
    if data!='':
       xpm={}

       rx=ck.access({'action':'search',
                     'cid':data})
       if rx['return']>0: return rx
       lst=rx['lst']
       for q in lst:
           pp=q['path']

           pm1,pd=os.path.split(pp)
           pr,pm=os.path.split(pm1)

           if pr not in fl:
              fl[pr]=[]

           ry=ck.find_path_to_entry({'path':pr, 'data_uoa':pm})
           if ry['return']>0: return ry
           pm_uid=ry['data_uid']
           pm_alias=ry['data_alias']

           if pm_alias!='':
              if pm_alias not in xpm:
                 xpm[pm_alias]=pm_uid
                 fl[pr].append(os.path.join(ck.cfg['subdir_ck_ext'], ck.cfg['file_alias_a'] + pm_alias))
                 fl[pr].append(os.path.join(ck.cfg['subdir_ck_ext'], ck.cfg['file_alias_u'] + pm_uid))

           ry=ck.find_path_to_entry({'path':pm1, 'data_uoa':pd})
           if ry['return']>0: return ry
           pd_uid=ry['data_uid']
           pd_alias=ry['data_alias']

           if pd_alias!='':
              fl[pr].append(os.path.join(pm, ck.cfg['subdir_ck_ext'], ck.cfg['file_alias_a'] + pd_alias))
              fl[pr].append(os.path.join(pm, ck.cfg['subdir_ck_ext'], ck.cfg['file_alias_u'] + pd_uid))

           r=ck.list_all_files({'path':pp, 'all':'yes', 'ignore_names':ignore})
           if r['return']>0: return r
           for q in r['list']:
               fx=os.path.join(pm,pd,q)
               fl[pr].append(fx)

    else:
       r=ck.list_all_files({'path':path, 'all':'yes', 'ignore_names':ignore})
       if r['return']>0: return r
       fl[path]=r['list']

    # Write archive
    try:
       f=open(pfn, 'wb')
       z=zipfile.ZipFile(f, 'w', zip_method)
       for path in fl:
           fl1=fl[path]
           for fn in fl1:
               p1=os.path.join(path, fn)
               z.write(p1, fn, zip_method)
       z.close()
       f.close()

    except Exception as e:
       return {'return':1, 'error':'failed to prepare archive ('+format(e)+')'}

    return {'return':0}",python,"def zip(i):
    """"""
    Input:  {
              data_uoa       - repo UOA

              (archive_path) - if '' create inside repo path

              (archive_name) - if !='' use it for zip name
              (auto_name)    - if 'yes', generate name name from data_uoa: ckr-<repo_uoa>.zip
              (bittorent)    - if 'yes', generate zip name for BitTorrent: ckr-<repo_uid>-YYYYMMDD.zip

              (overwrite)    - if 'yes', overwrite zip file
              (store)        - if 'yes', store files instead of packing


              (data)         - CID allowing to add only these entries with pattern (can be from another archive)

              (all)          - archive all files
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa1=i.get('data_uoa','')
    duid=''
    path=''

    if duoa1!='':
       # Find path to repo
       r=ck.find_path_to_repo({'repo_uoa':duoa1})
       if r['return']>0: return r

       duoa=r['repo_uoa']
       duid=r['repo_uid']
       path=r['path']

    an=i.get('archive_name','')
#    if an=='': an='ckr.zip'

    if i.get('auto_name','')=='yes':
       an='ckr'
       if duoa!='': an+='-'+duoa
       an+='.zip'
    elif i.get('bittorrent','')=='yes':
       import time
       an='ckr-'
       if duid!='': an+=duid
       an+='-'+time.strftime('%Y%m%d')+'.zip'
    elif an=='': 
       if duoa1=='': an='ckr.zip'
       else: an='ckr-'+duoa1+'.zip'

    ap=i.get('archive_path','')
#    if ap=='': ap=path

    pfn=os.path.join(ap, an)

    if pfn.startswith('~'):
       from os.path import expanduser
       home = expanduser(""~"")

       pfn=os.path.abspath(home+os.sep+pfn[1:])

    if os.path.isfile(pfn):
       if i.get('overwrite','')=='yes':
          os.remove(pfn)
       else:
          return {'return':1, 'error':'archive '+pfn+' already exists'}

    if o=='con':
       ck.out('Creating archive '+pfn+' - please wait, it may take some time ...')

    # Check all files
    ignore=[]
    if i.get('all','')!='yes':
       ignore=ck.cfg.get('ignore_directories_when_archive_repo',[])

    # Prepare archive
    import zipfile

    zip_method=zipfile.ZIP_DEFLATED
    if i.get('store','')=='yes':
       zip_method=zipfile.ZIP_STORED

    # Prepare list of files
    fl={}

    data=i.get('data','')
    if data!='':
       xpm={}

       rx=ck.access({'action':'search',
                     'cid':data})
       if rx['return']>0: return rx
       lst=rx['lst']
       for q in lst:
           pp=q['path']

           pm1,pd=os.path.split(pp)
           pr,pm=os.path.split(pm1)

           if pr not in fl:
              fl[pr]=[]

           ry=ck.find_path_to_entry({'path':pr, 'data_uoa':pm})
           if ry['return']>0: return ry
           pm_uid=ry['data_uid']
           pm_alias=ry['data_alias']

           if pm_alias!='':
              if pm_alias not in xpm:
                 xpm[pm_alias]=pm_uid
                 fl[pr].append(os.path.join(ck.cfg['subdir_ck_ext'], ck.cfg['file_alias_a'] + pm_alias))
                 fl[pr].append(os.path.join(ck.cfg['subdir_ck_ext'], ck.cfg['file_alias_u'] + pm_uid))

           ry=ck.find_path_to_entry({'path':pm1, 'data_uoa':pd})
           if ry['return']>0: return ry
           pd_uid=ry['data_uid']
           pd_alias=ry['data_alias']

           if pd_alias!='':
              fl[pr].append(os.path.join(pm, ck.cfg['subdir_ck_ext'], ck.cfg['file_alias_a'] + pd_alias))
              fl[pr].append(os.path.join(pm, ck.cfg['subdir_ck_ext'], ck.cfg['file_alias_u'] + pd_uid))

           r=ck.list_all_files({'path':pp, 'all':'yes', 'ignore_names':ignore})
           if r['return']>0: return r
           for q in r['list']:
               fx=os.path.join(pm,pd,q)
               fl[pr].append(fx)

    else:
       r=ck.list_all_files({'path':path, 'all':'yes', 'ignore_names':ignore})
       if r['return']>0: return r
       fl[path]=r['list']

    # Write archive
    try:
       f=open(pfn, 'wb')
       z=zipfile.ZipFile(f, 'w', zip_method)
       for path in fl:
           fl1=fl[path]
           for fn in fl1:
               p1=os.path.join(path, fn)
               z.write(p1, fn, zip_method)
       z.close()
       f.close()

    except Exception as e:
       return {'return':1, 'error':'failed to prepare archive ('+format(e)+')'}

    return {'return':0}","['def' 'zip' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'duoa1' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'duid' '='
 ""''"" 'path' '=' ""''"" 'if' 'duoa1' '!=' ""''"" ':' '# Find path to repo' 'r'
 '=' 'ck' '.' 'find_path_to_repo' '(' '{' ""'repo_uoa'"" ':' 'duoa1' '}' ')'
 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'duoa' '=' 'r' '['
 ""'repo_uoa'"" ']' 'duid' '=' 'r' '[' ""'repo_uid'"" ']' 'path' '=' 'r' '['
 ""'path'"" ']' 'an' '=' 'i' '.' 'get' '(' ""'archive_name'"" ',' ""''"" ')'
 ""#    if an=='': an='ckr.zip'"" 'if' 'i' '.' 'get' '(' ""'auto_name'"" ','
 ""''"" ')' '==' ""'yes'"" ':' 'an' '=' ""'ckr'"" 'if' 'duoa' '!=' ""''"" ':' 'an'
 '+=' ""'-'"" '+' 'duoa' 'an' '+=' ""'.zip'"" 'elif' 'i' '.' 'get' '('
 ""'bittorrent'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'import' 'time' 'an' '='
 ""'ckr-'"" 'if' 'duid' '!=' ""''"" ':' 'an' '+=' 'duid' 'an' '+=' ""'-'"" '+'
 'time' '.' 'strftime' '(' ""'%Y%m%d'"" ')' '+' ""'.zip'"" 'elif' 'an' '=='
 ""''"" ':' 'if' 'duoa1' '==' ""''"" ':' 'an' '=' ""'ckr.zip'"" 'else' ':' 'an'
 '=' ""'ckr-'"" '+' 'duoa1' '+' ""'.zip'"" 'ap' '=' 'i' '.' 'get' '('
 ""'archive_path'"" ',' ""''"" ')' ""#    if ap=='': ap=path"" 'pfn' '=' 'os'
 '.' 'path' '.' 'join' '(' 'ap' ',' 'an' ')' 'if' 'pfn' '.' 'startswith'
 '(' ""'~'"" ')' ':' 'from' 'os' '.' 'path' 'import' 'expanduser' 'home' '='
 'expanduser' '(' '""~""' ')' 'pfn' '=' 'os' '.' 'path' '.' 'abspath' '('
 'home' '+' 'os' '.' 'sep' '+' 'pfn' '[' '1' ':' ']' ')' 'if' 'os' '.'
 'path' '.' 'isfile' '(' 'pfn' ')' ':' 'if' 'i' '.' 'get' '('
 ""'overwrite'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'os' '.' 'remove' '(' 'pfn'
 ')' 'else' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'archive '"" '+' 'pfn' '+' ""' already exists'"" '}' 'if' 'o' '==' ""'con'""
 ':' 'ck' '.' 'out' '(' ""'Creating archive '"" '+' 'pfn' '+'
 ""' - please wait, it may take some time ...'"" ')' '# Check all files'
 'ignore' '=' '[' ']' 'if' 'i' '.' 'get' '(' ""'all'"" ',' ""''"" ')' '!='
 ""'yes'"" ':' 'ignore' '=' 'ck' '.' 'cfg' '.' 'get' '('
 ""'ignore_directories_when_archive_repo'"" ',' '[' ']' ')'
 '# Prepare archive' 'import' 'zipfile' 'zip_method' '=' 'zipfile' '.'
 'ZIP_DEFLATED' 'if' 'i' '.' 'get' '(' ""'store'"" ',' ""''"" ')' '==' ""'yes'""
 ':' 'zip_method' '=' 'zipfile' '.' 'ZIP_STORED' '# Prepare list of files'
 'fl' '=' '{' '}' 'data' '=' 'i' '.' 'get' '(' ""'data'"" ',' ""''"" ')' 'if'
 'data' '!=' ""''"" ':' 'xpm' '=' '{' '}' 'rx' '=' 'ck' '.' 'access' '(' '{'
 ""'action'"" ':' ""'search'"" ',' ""'cid'"" ':' 'data' '}' ')' 'if' 'rx' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'lst' '=' 'rx' '[' ""'lst'"" ']'
 'for' 'q' 'in' 'lst' ':' 'pp' '=' 'q' '[' ""'path'"" ']' 'pm1' ',' 'pd' '='
 'os' '.' 'path' '.' 'split' '(' 'pp' ')' 'pr' ',' 'pm' '=' 'os' '.'
 'path' '.' 'split' '(' 'pm1' ')' 'if' 'pr' 'not' 'in' 'fl' ':' 'fl' '['
 'pr' ']' '=' '[' ']' 'ry' '=' 'ck' '.' 'find_path_to_entry' '(' '{'
 ""'path'"" ':' 'pr' ',' ""'data_uoa'"" ':' 'pm' '}' ')' 'if' 'ry' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'ry' 'pm_uid' '=' 'ry' '['
 ""'data_uid'"" ']' 'pm_alias' '=' 'ry' '[' ""'data_alias'"" ']' 'if'
 'pm_alias' '!=' ""''"" ':' 'if' 'pm_alias' 'not' 'in' 'xpm' ':' 'xpm' '['
 'pm_alias' ']' '=' 'pm_uid' 'fl' '[' 'pr' ']' '.' 'append' '(' 'os' '.'
 'path' '.' 'join' '(' 'ck' '.' 'cfg' '[' ""'subdir_ck_ext'"" ']' ',' 'ck'
 '.' 'cfg' '[' ""'file_alias_a'"" ']' '+' 'pm_alias' ')' ')' 'fl' '[' 'pr'
 ']' '.' 'append' '(' 'os' '.' 'path' '.' 'join' '(' 'ck' '.' 'cfg' '['
 ""'subdir_ck_ext'"" ']' ',' 'ck' '.' 'cfg' '[' ""'file_alias_u'"" ']' '+'
 'pm_uid' ')' ')' 'ry' '=' 'ck' '.' 'find_path_to_entry' '(' '{' ""'path'""
 ':' 'pm1' ',' ""'data_uoa'"" ':' 'pd' '}' ')' 'if' 'ry' '[' ""'return'"" ']'
 '>' '0' ':' 'return' 'ry' 'pd_uid' '=' 'ry' '[' ""'data_uid'"" ']'
 'pd_alias' '=' 'ry' '[' ""'data_alias'"" ']' 'if' 'pd_alias' '!=' ""''"" ':'
 'fl' '[' 'pr' ']' '.' 'append' '(' 'os' '.' 'path' '.' 'join' '(' 'pm'
 ',' 'ck' '.' 'cfg' '[' ""'subdir_ck_ext'"" ']' ',' 'ck' '.' 'cfg' '['
 ""'file_alias_a'"" ']' '+' 'pd_alias' ')' ')' 'fl' '[' 'pr' ']' '.'
 'append' '(' 'os' '.' 'path' '.' 'join' '(' 'pm' ',' 'ck' '.' 'cfg' '['
 ""'subdir_ck_ext'"" ']' ',' 'ck' '.' 'cfg' '[' ""'file_alias_u'"" ']' '+'
 'pd_uid' ')' ')' 'r' '=' 'ck' '.' 'list_all_files' '(' '{' ""'path'"" ':'
 'pp' ',' ""'all'"" ':' ""'yes'"" ',' ""'ignore_names'"" ':' 'ignore' '}' ')'
 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'for' 'q' 'in' 'r'
 '[' ""'list'"" ']' ':' 'fx' '=' 'os' '.' 'path' '.' 'join' '(' 'pm' ','
 'pd' ',' 'q' ')' 'fl' '[' 'pr' ']' '.' 'append' '(' 'fx' ')' 'else' ':'
 'r' '=' 'ck' '.' 'list_all_files' '(' '{' ""'path'"" ':' 'path' ',' ""'all'""
 ':' ""'yes'"" ',' ""'ignore_names'"" ':' 'ignore' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'fl' '[' 'path' ']' '=' 'r' '['
 ""'list'"" ']' '# Write archive' 'try' ':' 'f' '=' 'open' '(' 'pfn' ','
 ""'wb'"" ')' 'z' '=' 'zipfile' '.' 'ZipFile' '(' 'f' ',' ""'w'"" ','
 'zip_method' ')' 'for' 'path' 'in' 'fl' ':' 'fl1' '=' 'fl' '[' 'path' ']'
 'for' 'fn' 'in' 'fl1' ':' 'p1' '=' 'os' '.' 'path' '.' 'join' '(' 'path'
 ',' 'fn' ')' 'z' '.' 'write' '(' 'p1' ',' 'fn' ',' 'zip_method' ')' 'z'
 '.' 'close' '(' ')' 'f' '.' 'close' '(' ')' 'except' 'Exception' 'as' 'e'
 ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'failed to prepare archive ('"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}'
 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              data_uoa       - repo UOA

              (archive_path) - if '' create inside repo path

              (archive_name) - if !='' use it for zip name
              (auto_name)    - if 'yes', generate name name from data_uoa: ckr-<repo_uoa>.zip
              (bittorent)    - if 'yes', generate zip name for BitTorrent: ckr-<repo_uid>-YYYYMMDD.zip

              (overwrite)    - if 'yes', overwrite zip file
              (store)        - if 'yes', store files instead of packing


              (data)         - CID allowing to add only these entries with pattern (can be from another archive)

              (all)          - archive all files
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' 'data_uoa' '-' 'repo' 'UOA'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L1429-L1586
ctuning/ck,ck/repo/module/repo/module.py,unzip,"def unzip(i):
    """"""
    Input:  {
              (data_uoa)    - repo UOA where to unzip (default, if not specified)
              zip           - path to zipfile (local or remote http/ftp)
              (overwrite)   - if 'yes', overwrite files when unarchiving
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa=i.get('data_uoa','')
    if duoa=='': duoa='local'

    overwrite=i.get('overwrite','')

    zip=i.get('zip','')
    if zip=='': zip='ckr.zip'

    # Find path to repo
    r=ck.find_path_to_repo({'repo_uoa':duoa})
    if r['return']>0: return r

    path=r['path']

    # Unzipping archive
    rz=get_and_unzip_archive({'zip':zip, 'path':path, 'overwrite':overwrite, 'out':o})
    if rz['return']>0: return rz

    return {'return':0}",python,"def unzip(i):
    """"""
    Input:  {
              (data_uoa)    - repo UOA where to unzip (default, if not specified)
              zip           - path to zipfile (local or remote http/ftp)
              (overwrite)   - if 'yes', overwrite files when unarchiving
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa=i.get('data_uoa','')
    if duoa=='': duoa='local'

    overwrite=i.get('overwrite','')

    zip=i.get('zip','')
    if zip=='': zip='ckr.zip'

    # Find path to repo
    r=ck.find_path_to_repo({'repo_uoa':duoa})
    if r['return']>0: return r

    path=r['path']

    # Unzipping archive
    rz=get_and_unzip_archive({'zip':zip, 'path':path, 'overwrite':overwrite, 'out':o})
    if rz['return']>0: return rz

    return {'return':0}","['def' 'unzip' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if' 'duoa'
 '==' ""''"" ':' 'duoa' '=' ""'local'"" 'overwrite' '=' 'i' '.' 'get' '('
 ""'overwrite'"" ',' ""''"" ')' 'zip' '=' 'i' '.' 'get' '(' ""'zip'"" ',' ""''""
 ')' 'if' 'zip' '==' ""''"" ':' 'zip' '=' ""'ckr.zip'"" '# Find path to repo'
 'r' '=' 'ck' '.' 'find_path_to_repo' '(' '{' ""'repo_uoa'"" ':' 'duoa' '}'
 ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'path' '=' 'r'
 '[' ""'path'"" ']' '# Unzipping archive' 'rz' '=' 'get_and_unzip_archive'
 '(' '{' ""'zip'"" ':' 'zip' ',' ""'path'"" ':' 'path' ',' ""'overwrite'"" ':'
 'overwrite' ',' ""'out'"" ':' 'o' '}' ')' 'if' 'rz' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'rz' 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              (data_uoa)    - repo UOA where to unzip (default, if not specified)
              zip           - path to zipfile (local or remote http/ftp)
              (overwrite)   - if 'yes', overwrite files when unarchiving
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'data_uoa' ')' '-' 'repo' 'UOA' 'where' 'to' 'unzip'
 '(' 'default' 'if' 'not' 'specified' ')' 'zip' '-' 'path' 'to' 'zipfile'
 '(' 'local' 'or' 'remote' 'http' '/' 'ftp' ')' '(' 'overwrite' ')' '-'
 'if' 'yes' 'overwrite' 'files' 'when' 'unarchiving' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L1591-L1627
ctuning/ck,ck/repo/module/repo/module.py,get_and_unzip_archive,"def get_and_unzip_archive(i):
    """"""
    Input:  {
              zip              - zip filename or URL
              path             - path to extract
              (overwrite)      - if 'yes', overwrite files when unarchiving
              (path_to_remove) - if !='', remove this part of the path from extracted archive
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    zp=i['zip']
    p=i['path']
    pr=i.get('path_to_remove','')

    overwrite=i.get('overwrite','')

    # If zip, get (download) and unzip file ...
    rm_zip=False
    if zp.find('://')>=0:
       if o=='con':
          ck.out('Downloading CK archive ('+zp+') - it may take some time ...')

       rm_zip=True

       # Generate tmp file
       import tempfile
       fd, fn=tempfile.mkstemp(suffix='.tmp', prefix='ck-') # suffix is important - CK will delete such file!
       os.close(fd)
       os.remove(fn)

       # Import modules compatible with Python 2.x and 3.x
       import urllib

       try:
          import urllib.request as urllib2
       except:
          import urllib2

       # Prepare request
       request = urllib2.Request(zp)

       # Connect
       try:
          f=urllib2.urlopen(request)
       except Exception as e:
          return {'return':1, 'error':'Failed downloading CK archive ('+format(e)+')'}

       import time
       t = time.time()
       t0 = t

       chunk=32767
       size=0

       try:
          fo=open(fn, 'wb')
       except Exception as e:
          return {'return':1, 'error':'problem opening file='+fn+' ('+format(e)+')'}

       # Read from Internet
       try:
          while True:
             s=f.read(chunk)
             if not s: break
             fo.write(s)

             size+=len(s)

             if o=='con' and (time.time()-t)>3:
                speed='%.1d' % (size/(1000*(time.time()-t0)))
                ck.out('  Downloaded '+str(int(size/1000))+' KB ('+speed+' KB/sec.) ...')
                t=time.time()

          f.close()
       except Exception as e:
          return {'return':1, 'error':'Failed downlading CK archive ('+format(e)+')'}

       fo.close()

       zp=fn

    # Unzip if zip
    if zp!='':
       if o=='con':
          ck.out('  Extracting to '+p+' ...')

       import zipfile
       f=open(zp,'rb')
       z=zipfile.ZipFile(f)

       # First, try to find .ckr.json
       xprefix=''
       for dx in z.namelist():
           if pr!='' and dx.startswith(pr): dx=dx[len(pr):]
           if dx.endswith(ck.cfg['repo_file']):
              xprefix=dx[:-len(ck.cfg['repo_file'])]
              break

       # Second, extract files
       for dx in z.namelist():
           dx1=dx
           if pr!=''and dx1.startswith(pr): dx1=dx1[len(pr):]
           if xprefix!='' and dx1.startswith(xprefix): dx1=dx1[len(xprefix):]

           if dx1!='':
              pp=os.path.join(p,dx1)
              if dx.endswith('/'): 
                 # create directory 
                 if not os.path.exists(pp): os.makedirs(pp)
              else:
                 # extract file
                 ppd=os.path.dirname(pp)
                 if not os.path.exists(ppd): os.makedirs(ppd)

                 if os.path.isfile(pp) and overwrite!='yes':
                    if o=='con':
                       ck.out('File '+dx+' already exists in the entry - skipping ...')
                 else:
                    fo=open(pp, 'wb')
                    fo.write(z.read(dx))
                    fo.close()
       f.close()

       if rm_zip:
          os.remove(zp)

    return {'return':0}",python,"def get_and_unzip_archive(i):
    """"""
    Input:  {
              zip              - zip filename or URL
              path             - path to extract
              (overwrite)      - if 'yes', overwrite files when unarchiving
              (path_to_remove) - if !='', remove this part of the path from extracted archive
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    zp=i['zip']
    p=i['path']
    pr=i.get('path_to_remove','')

    overwrite=i.get('overwrite','')

    # If zip, get (download) and unzip file ...
    rm_zip=False
    if zp.find('://')>=0:
       if o=='con':
          ck.out('Downloading CK archive ('+zp+') - it may take some time ...')

       rm_zip=True

       # Generate tmp file
       import tempfile
       fd, fn=tempfile.mkstemp(suffix='.tmp', prefix='ck-') # suffix is important - CK will delete such file!
       os.close(fd)
       os.remove(fn)

       # Import modules compatible with Python 2.x and 3.x
       import urllib

       try:
          import urllib.request as urllib2
       except:
          import urllib2

       # Prepare request
       request = urllib2.Request(zp)

       # Connect
       try:
          f=urllib2.urlopen(request)
       except Exception as e:
          return {'return':1, 'error':'Failed downloading CK archive ('+format(e)+')'}

       import time
       t = time.time()
       t0 = t

       chunk=32767
       size=0

       try:
          fo=open(fn, 'wb')
       except Exception as e:
          return {'return':1, 'error':'problem opening file='+fn+' ('+format(e)+')'}

       # Read from Internet
       try:
          while True:
             s=f.read(chunk)
             if not s: break
             fo.write(s)

             size+=len(s)

             if o=='con' and (time.time()-t)>3:
                speed='%.1d' % (size/(1000*(time.time()-t0)))
                ck.out('  Downloaded '+str(int(size/1000))+' KB ('+speed+' KB/sec.) ...')
                t=time.time()

          f.close()
       except Exception as e:
          return {'return':1, 'error':'Failed downlading CK archive ('+format(e)+')'}

       fo.close()

       zp=fn

    # Unzip if zip
    if zp!='':
       if o=='con':
          ck.out('  Extracting to '+p+' ...')

       import zipfile
       f=open(zp,'rb')
       z=zipfile.ZipFile(f)

       # First, try to find .ckr.json
       xprefix=''
       for dx in z.namelist():
           if pr!='' and dx.startswith(pr): dx=dx[len(pr):]
           if dx.endswith(ck.cfg['repo_file']):
              xprefix=dx[:-len(ck.cfg['repo_file'])]
              break

       # Second, extract files
       for dx in z.namelist():
           dx1=dx
           if pr!=''and dx1.startswith(pr): dx1=dx1[len(pr):]
           if xprefix!='' and dx1.startswith(xprefix): dx1=dx1[len(xprefix):]

           if dx1!='':
              pp=os.path.join(p,dx1)
              if dx.endswith('/'): 
                 # create directory 
                 if not os.path.exists(pp): os.makedirs(pp)
              else:
                 # extract file
                 ppd=os.path.dirname(pp)
                 if not os.path.exists(ppd): os.makedirs(ppd)

                 if os.path.isfile(pp) and overwrite!='yes':
                    if o=='con':
                       ck.out('File '+dx+' already exists in the entry - skipping ...')
                 else:
                    fo=open(pp, 'wb')
                    fo.write(z.read(dx))
                    fo.close()
       f.close()

       if rm_zip:
          os.remove(zp)

    return {'return':0}","['def' 'get_and_unzip_archive' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '('
 ""'out'"" ',' ""''"" ')' 'zp' '=' 'i' '[' ""'zip'"" ']' 'p' '=' 'i' '['
 ""'path'"" ']' 'pr' '=' 'i' '.' 'get' '(' ""'path_to_remove'"" ',' ""''"" ')'
 'overwrite' '=' 'i' '.' 'get' '(' ""'overwrite'"" ',' ""''"" ')'
 '# If zip, get (download) and unzip file ...' 'rm_zip' '=' 'False' 'if'
 'zp' '.' 'find' '(' ""'://'"" ')' '>=' '0' ':' 'if' 'o' '==' ""'con'"" ':'
 'ck' '.' 'out' '(' ""'Downloading CK archive ('"" '+' 'zp' '+'
 ""') - it may take some time ...'"" ')' 'rm_zip' '=' 'True'
 '# Generate tmp file' 'import' 'tempfile' 'fd' ',' 'fn' '=' 'tempfile'
 '.' 'mkstemp' '(' 'suffix' '=' ""'.tmp'"" ',' 'prefix' '=' ""'ck-'"" ')'
 '# suffix is important - CK will delete such file!' 'os' '.' 'close' '('
 'fd' ')' 'os' '.' 'remove' '(' 'fn' ')'
 '# Import modules compatible with Python 2.x and 3.x' 'import' 'urllib'
 'try' ':' 'import' 'urllib' '.' 'request' 'as' 'urllib2' 'except' ':'
 'import' 'urllib2' '# Prepare request' 'request' '=' 'urllib2' '.'
 'Request' '(' 'zp' ')' '# Connect' 'try' ':' 'f' '=' 'urllib2' '.'
 'urlopen' '(' 'request' ')' 'except' 'Exception' 'as' 'e' ':' 'return'
 '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'Failed downloading CK archive ('"" '+' 'format' '(' 'e' ')' '+' ""')'""
 '}' 'import' 'time' 't' '=' 'time' '.' 'time' '(' ')' 't0' '=' 't'
 'chunk' '=' '32767' 'size' '=' '0' 'try' ':' 'fo' '=' 'open' '(' 'fn' ','
 ""'wb'"" ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{' ""'return'"" ':'
 '1' ',' ""'error'"" ':' ""'problem opening file='"" '+' 'fn' '+' ""' ('"" '+'
 'format' '(' 'e' ')' '+' ""')'"" '}' '# Read from Internet' 'try' ':'
 'while' 'True' ':' 's' '=' 'f' '.' 'read' '(' 'chunk' ')' 'if' 'not' 's'
 ':' 'break' 'fo' '.' 'write' '(' 's' ')' 'size' '+=' 'len' '(' 's' ')'
 'if' 'o' '==' ""'con'"" 'and' '(' 'time' '.' 'time' '(' ')' '-' 't' ')' '>'
 '3' ':' 'speed' '=' ""'%.1d'"" '%' '(' 'size' '/' '(' '1000' '*' '(' 'time'
 '.' 'time' '(' ')' '-' 't0' ')' ')' ')' 'ck' '.' 'out' '('
 ""'  Downloaded '"" '+' 'str' '(' 'int' '(' 'size' '/' '1000' ')' ')' '+'
 ""' KB ('"" '+' 'speed' '+' ""' KB/sec.) ...'"" ')' 't' '=' 'time' '.' 'time'
 '(' ')' 'f' '.' 'close' '(' ')' 'except' 'Exception' 'as' 'e' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'Failed downlading CK archive ('"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}'
 'fo' '.' 'close' '(' ')' 'zp' '=' 'fn' '# Unzip if zip' 'if' 'zp' '!='
 ""''"" ':' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '('
 ""'  Extracting to '"" '+' 'p' '+' ""' ...'"" ')' 'import' 'zipfile' 'f' '='
 'open' '(' 'zp' ',' ""'rb'"" ')' 'z' '=' 'zipfile' '.' 'ZipFile' '(' 'f'
 ')' '# First, try to find .ckr.json' 'xprefix' '=' ""''"" 'for' 'dx' 'in'
 'z' '.' 'namelist' '(' ')' ':' 'if' 'pr' '!=' ""''"" 'and' 'dx' '.'
 'startswith' '(' 'pr' ')' ':' 'dx' '=' 'dx' '[' 'len' '(' 'pr' ')' ':'
 ']' 'if' 'dx' '.' 'endswith' '(' 'ck' '.' 'cfg' '[' ""'repo_file'"" ']' ')'
 ':' 'xprefix' '=' 'dx' '[' ':' '-' 'len' '(' 'ck' '.' 'cfg' '['
 ""'repo_file'"" ']' ')' ']' 'break' '# Second, extract files' 'for' 'dx'
 'in' 'z' '.' 'namelist' '(' ')' ':' 'dx1' '=' 'dx' 'if' 'pr' '!=' ""''""
 'and' 'dx1' '.' 'startswith' '(' 'pr' ')' ':' 'dx1' '=' 'dx1' '[' 'len'
 '(' 'pr' ')' ':' ']' 'if' 'xprefix' '!=' ""''"" 'and' 'dx1' '.'
 'startswith' '(' 'xprefix' ')' ':' 'dx1' '=' 'dx1' '[' 'len' '('
 'xprefix' ')' ':' ']' 'if' 'dx1' '!=' ""''"" ':' 'pp' '=' 'os' '.' 'path'
 '.' 'join' '(' 'p' ',' 'dx1' ')' 'if' 'dx' '.' 'endswith' '(' ""'/'"" ')'
 ':' '# create directory ' 'if' 'not' 'os' '.' 'path' '.' 'exists' '('
 'pp' ')' ':' 'os' '.' 'makedirs' '(' 'pp' ')' 'else' ':' '# extract file'
 'ppd' '=' 'os' '.' 'path' '.' 'dirname' '(' 'pp' ')' 'if' 'not' 'os' '.'
 'path' '.' 'exists' '(' 'ppd' ')' ':' 'os' '.' 'makedirs' '(' 'ppd' ')'
 'if' 'os' '.' 'path' '.' 'isfile' '(' 'pp' ')' 'and' 'overwrite' '!='
 ""'yes'"" ':' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '(' ""'File '"" '+'
 'dx' '+' ""' already exists in the entry - skipping ...'"" ')' 'else' ':'
 'fo' '=' 'open' '(' 'pp' ',' ""'wb'"" ')' 'fo' '.' 'write' '(' 'z' '.'
 'read' '(' 'dx' ')' ')' 'fo' '.' 'close' '(' ')' 'f' '.' 'close' '(' ')'
 'if' 'rm_zip' ':' 'os' '.' 'remove' '(' 'zp' ')' 'return' '{' ""'return'""
 ':' '0' '}']","Input:  {
              zip              - zip filename or URL
              path             - path to extract
              (overwrite)      - if 'yes', overwrite files when unarchiving
              (path_to_remove) - if !='', remove this part of the path from extracted archive
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' 'zip' '-' 'zip' 'filename' 'or' 'URL' 'path' '-' 'path'
 'to' 'extract' '(' 'overwrite' ')' '-' 'if' 'yes' 'overwrite' 'files'
 'when' 'unarchiving' '(' 'path_to_remove' ')' '-' 'if' '!' '=' 'remove'
 'this' 'part' 'of' 'the' 'path' 'from' 'extracted' 'archive' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L1632-L1767
ctuning/ck,ck/repo/module/repo/module.py,deps,"def deps(i):
    """"""
    Input:  {
              (data_uoa)      - repo UOA
                  or
              (path)          - path to .cmr.json

              (current_repos) - list of repos being updated (to avoid infinite recursion)

              (how)           - 'pull' (default) or 'add'

              (version)       - checkout version (default - stable)
              (branch)        - git branch
              (checkout)      - git checkout
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    import os

    o=i.get('out','')

    duoa=i.get('data_uoa','')

    cr=i.get('current_repos',[])  # Added repos to avoid duplication/recursion

    how=i.get('how','')
    if how=='': how='pull'

    p=i.get('path','')
    if p=='':
       r=ck.access({'action':'load',
                    'module_uoa':work['self_module_uoa'],
                    'data_uoa':duoa})
       if r['return']>0: return r
       dr=r['dict']
       p=dr.get('path','')

    if p!='':
       # path to repo description
       pp=os.path.join(p, ck.cfg['repo_file'])
       if os.path.isfile(pp):
          r=ck.load_json_file({'json_file':pp})
          if r['return']>0: return r

          d=r['dict']

          # Check checkouts
          version=i.get('version','')
          branch=i.get('branch','')
          checkout=i.get('checkout','')

          if version!='':
             cx=d.get('dict',{}).get('checkouts',{}).get(version,{})
             branch=cx.get('branch','')
             checkout=cx.get('checkout','')

          ppp=os.getcwd()

          os.chdir(p)

          if branch!='':
             if o=='con':
                ck.out('  ====================================')
                ck.out('  git checkout '+branch)
                ck.out('')

             r=ck.run_and_get_stdout({'cmd':['git','checkout',branch]})
             ck.out(r.get('stdout',''))
             ck.out(r.get('stderr',''))

          if checkout!='':
             if o=='con':
                ck.out('  ====================================')
                ck.out('  git checkout '+checkout)
                ck.out('')

             r=ck.run_and_get_stdout({'cmd':['git','checkout',checkout]})
             ck.out(r.get('stdout',''))
             ck.out(r.get('stderr',''))

          os.chdir(ppp)

          rp1=d.get('dict',{}).get('repo_deps',[])
          if len(rp1)==0:
             rp1=d.get('repo_deps',[]) # for backwards compatibility ...

          rp2=[]
          rp=[]

          if len(rp1)>0:
             for xruoa in rp1:
                 if type(xruoa)!=list: # for backwards compatibility
                    ruoa=xruoa.get('repo_uoa','')
                    if xruoa.get('repo_uid','')!='': ruoa=xruoa['repo_uid']
                    if ruoa!='' and ruoa not in cr:
                       rp2.append(xruoa)

          # Add dependencies on other repositories (but avoid duplication)
          if len(rp2)==0:
             if o=='con':
                ck.out('  No dependencies on other repositories found!')
          else:
             for xruoa in rp2:
                 ruoa=xruoa.get('repo_uoa','')
                 if xruoa.get('repo_uid','')!='': ruoa=xruoa['repo_uid']
                 rurl=xruoa.get('repo_url','')
                 if ruoa!='':
                    x='  Dependency on repository '+ruoa+' '

                    # Check if this repo exists
                    r=ck.access({'action':'load',
                                 'module_uoa':work['self_module_uoa'],
                                 'data_uoa':ruoa})
                    if r['return']>0: 
                       if r['return']!=16: return r
                       rp.append(xruoa)
                       x+=': should be resolved ...'
                    else:
                       # If explicit branch, still add !
                       branch=xruoa.get('branch','')
                       checkout=xruoa.get('checkout','')
                       stable=xruoa.get('stable','')
                       version=xruoa.get('version','')

                       if branch!='' or checkout!='' or stable!='' or version!='':
                          xruoa['ignore_pull']='yes'
                          rp.append(xruoa)
                          x+=': should be switched to explicit branch ...'
                       else:
                          x+=': Ok'

                    if o=='con':
                       ck.out(x)

          if len(rp)>0:
             for xruoa in rp:
                 ruoa=xruoa.get('repo_uoa','')
                 ruid=xruoa.get('repo_uid','')
                 rurl=xruoa.get('repo_url','')

                 branch=xruoa.get('branch','')
                 checkout=xruoa.get('checkout','')
                 stable=xruoa.get('stable','')
                 version=xruoa.get('version','')

                 ignore_pull=xruoa.get('ignore_pull','')

                 if o=='con':
                    ck.out('')
                    x=''
                    if ruid!='': x=' ('+ruid+')'
                    ck.out('  Resolving dependency on repo: '+ruoa+x)
                    ck.out('')

                 if ruid!='': cr.append(ruid)
                 else: cr.append(ruoa)

                 ii={'action':how,
                     'module_uoa':work['self_module_uoa'],
                     'data_uoa':ruoa,
                     'current_repos':cr,
                     'url':rurl,
                     'ignore_pull':ignore_pull,
                     'branch':branch,
                     'checkout':checkout,
                     'stable':stable,
                     'version':version,
                     'out':o}
                 if ruid!='': ii['data_uid']=ruid
                 if how=='add': ii['gitzip']='yes'
                 r=ck.access(ii)
                 if r['return']>0: return r

    return {'return':0, 'current_repos':cr}",python,"def deps(i):
    """"""
    Input:  {
              (data_uoa)      - repo UOA
                  or
              (path)          - path to .cmr.json

              (current_repos) - list of repos being updated (to avoid infinite recursion)

              (how)           - 'pull' (default) or 'add'

              (version)       - checkout version (default - stable)
              (branch)        - git branch
              (checkout)      - git checkout
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    import os

    o=i.get('out','')

    duoa=i.get('data_uoa','')

    cr=i.get('current_repos',[])  # Added repos to avoid duplication/recursion

    how=i.get('how','')
    if how=='': how='pull'

    p=i.get('path','')
    if p=='':
       r=ck.access({'action':'load',
                    'module_uoa':work['self_module_uoa'],
                    'data_uoa':duoa})
       if r['return']>0: return r
       dr=r['dict']
       p=dr.get('path','')

    if p!='':
       # path to repo description
       pp=os.path.join(p, ck.cfg['repo_file'])
       if os.path.isfile(pp):
          r=ck.load_json_file({'json_file':pp})
          if r['return']>0: return r

          d=r['dict']

          # Check checkouts
          version=i.get('version','')
          branch=i.get('branch','')
          checkout=i.get('checkout','')

          if version!='':
             cx=d.get('dict',{}).get('checkouts',{}).get(version,{})
             branch=cx.get('branch','')
             checkout=cx.get('checkout','')

          ppp=os.getcwd()

          os.chdir(p)

          if branch!='':
             if o=='con':
                ck.out('  ====================================')
                ck.out('  git checkout '+branch)
                ck.out('')

             r=ck.run_and_get_stdout({'cmd':['git','checkout',branch]})
             ck.out(r.get('stdout',''))
             ck.out(r.get('stderr',''))

          if checkout!='':
             if o=='con':
                ck.out('  ====================================')
                ck.out('  git checkout '+checkout)
                ck.out('')

             r=ck.run_and_get_stdout({'cmd':['git','checkout',checkout]})
             ck.out(r.get('stdout',''))
             ck.out(r.get('stderr',''))

          os.chdir(ppp)

          rp1=d.get('dict',{}).get('repo_deps',[])
          if len(rp1)==0:
             rp1=d.get('repo_deps',[]) # for backwards compatibility ...

          rp2=[]
          rp=[]

          if len(rp1)>0:
             for xruoa in rp1:
                 if type(xruoa)!=list: # for backwards compatibility
                    ruoa=xruoa.get('repo_uoa','')
                    if xruoa.get('repo_uid','')!='': ruoa=xruoa['repo_uid']
                    if ruoa!='' and ruoa not in cr:
                       rp2.append(xruoa)

          # Add dependencies on other repositories (but avoid duplication)
          if len(rp2)==0:
             if o=='con':
                ck.out('  No dependencies on other repositories found!')
          else:
             for xruoa in rp2:
                 ruoa=xruoa.get('repo_uoa','')
                 if xruoa.get('repo_uid','')!='': ruoa=xruoa['repo_uid']
                 rurl=xruoa.get('repo_url','')
                 if ruoa!='':
                    x='  Dependency on repository '+ruoa+' '

                    # Check if this repo exists
                    r=ck.access({'action':'load',
                                 'module_uoa':work['self_module_uoa'],
                                 'data_uoa':ruoa})
                    if r['return']>0: 
                       if r['return']!=16: return r
                       rp.append(xruoa)
                       x+=': should be resolved ...'
                    else:
                       # If explicit branch, still add !
                       branch=xruoa.get('branch','')
                       checkout=xruoa.get('checkout','')
                       stable=xruoa.get('stable','')
                       version=xruoa.get('version','')

                       if branch!='' or checkout!='' or stable!='' or version!='':
                          xruoa['ignore_pull']='yes'
                          rp.append(xruoa)
                          x+=': should be switched to explicit branch ...'
                       else:
                          x+=': Ok'

                    if o=='con':
                       ck.out(x)

          if len(rp)>0:
             for xruoa in rp:
                 ruoa=xruoa.get('repo_uoa','')
                 ruid=xruoa.get('repo_uid','')
                 rurl=xruoa.get('repo_url','')

                 branch=xruoa.get('branch','')
                 checkout=xruoa.get('checkout','')
                 stable=xruoa.get('stable','')
                 version=xruoa.get('version','')

                 ignore_pull=xruoa.get('ignore_pull','')

                 if o=='con':
                    ck.out('')
                    x=''
                    if ruid!='': x=' ('+ruid+')'
                    ck.out('  Resolving dependency on repo: '+ruoa+x)
                    ck.out('')

                 if ruid!='': cr.append(ruid)
                 else: cr.append(ruoa)

                 ii={'action':how,
                     'module_uoa':work['self_module_uoa'],
                     'data_uoa':ruoa,
                     'current_repos':cr,
                     'url':rurl,
                     'ignore_pull':ignore_pull,
                     'branch':branch,
                     'checkout':checkout,
                     'stable':stable,
                     'version':version,
                     'out':o}
                 if ruid!='': ii['data_uid']=ruid
                 if how=='add': ii['gitzip']='yes'
                 r=ck.access(ii)
                 if r['return']>0: return r

    return {'return':0, 'current_repos':cr}",['def' 'deps' '(' ... ':' 'cr' '}'],"Input:  {
              (data_uoa)      - repo UOA
                  or
              (path)          - path to .cmr.json

              (current_repos) - list of repos being updated (to avoid infinite recursion)

              (how)           - 'pull' (default) or 'add'

              (version)       - checkout version (default - stable)
              (branch)        - git branch
              (checkout)      - git checkout
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'data_uoa' ')' '-' 'repo' 'UOA' 'or' '(' 'path' ')'
 '-' 'path' 'to' '.' 'cmr' '.' 'json']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L1792-L1972
ctuning/ck,ck/repo/module/repo/module.py,print_deps,"def print_deps(i):
    """"""
    Input:  {
              data_uoa                   - data UOA of the repo
                 or
              repo_deps                  - dict with dependencies on other shared repos

              (out_prefix)               - output prefix befor each string
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              repo_deps
            }

    """"""

    o=i.get('out','')

    op=i.get('out_prefix','')

    duoa=i.get('data_uoa','')
    if duoa!='':
       # Get configuration
       r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
       if r['return']>0: return r

       d=r['dict']
       rp1=d.get('dict',{}).get('repo_deps',[])
    else:
       rp1=i['repo_deps']

    if len(rp1)==0:
       rp1=d.get('repo_deps',[]) # for compatibility ...

    if o=='con' and len(rp1)>0:
       for q in rp1:
           ruoa=q.get('repo_uoa','')
           ruid=q.get('repo_uid','')
           rurl=q.get('repo_url','')

           x=op+ruoa
           if ruid!='': x+='; '+ruid
           elif rurl!='': x+='; '
           if rurl!='': x+='; '+rurl

           ck.out(x)

    return {'return':0, 'repo_deps':rp1}",python,"def print_deps(i):
    """"""
    Input:  {
              data_uoa                   - data UOA of the repo
                 or
              repo_deps                  - dict with dependencies on other shared repos

              (out_prefix)               - output prefix befor each string
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              repo_deps
            }

    """"""

    o=i.get('out','')

    op=i.get('out_prefix','')

    duoa=i.get('data_uoa','')
    if duoa!='':
       # Get configuration
       r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
       if r['return']>0: return r

       d=r['dict']
       rp1=d.get('dict',{}).get('repo_deps',[])
    else:
       rp1=i['repo_deps']

    if len(rp1)==0:
       rp1=d.get('repo_deps',[]) # for compatibility ...

    if o=='con' and len(rp1)>0:
       for q in rp1:
           ruoa=q.get('repo_uoa','')
           ruid=q.get('repo_uid','')
           rurl=q.get('repo_url','')

           x=op+ruoa
           if ruid!='': x+='; '+ruid
           elif rurl!='': x+='; '
           if rurl!='': x+='; '+rurl

           ck.out(x)

    return {'return':0, 'repo_deps':rp1}","['def' 'print_deps' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ','
 ""''"" ')' 'op' '=' 'i' '.' 'get' '(' ""'out_prefix'"" ',' ""''"" ')' 'duoa'
 '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if' 'duoa' '!=' ""''"" ':'
 '# Get configuration' 'r' '=' 'ck' '.' 'load_repo_info_from_cache' '('
 '{' ""'repo_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' 'd' '=' 'r' '[' ""'dict'"" ']' 'rp1' '=' 'd' '.' 'get' '('
 ""'dict'"" ',' '{' '}' ')' '.' 'get' '(' ""'repo_deps'"" ',' '[' ']' ')'
 'else' ':' 'rp1' '=' 'i' '[' ""'repo_deps'"" ']' 'if' 'len' '(' 'rp1' ')'
 '==' '0' ':' 'rp1' '=' 'd' '.' 'get' '(' ""'repo_deps'"" ',' '[' ']' ')'
 '# for compatibility ...' 'if' 'o' '==' ""'con'"" 'and' 'len' '(' 'rp1' ')'
 '>' '0' ':' 'for' 'q' 'in' 'rp1' ':' 'ruoa' '=' 'q' '.' 'get' '('
 ""'repo_uoa'"" ',' ""''"" ')' 'ruid' '=' 'q' '.' 'get' '(' ""'repo_uid'"" ','
 ""''"" ')' 'rurl' '=' 'q' '.' 'get' '(' ""'repo_url'"" ',' ""''"" ')' 'x' '='
 'op' '+' 'ruoa' 'if' 'ruid' '!=' ""''"" ':' 'x' '+=' ""'; '"" '+' 'ruid'
 'elif' 'rurl' '!=' ""''"" ':' 'x' '+=' ""'; '"" 'if' 'rurl' '!=' ""''"" ':' 'x'
 '+=' ""'; '"" '+' 'rurl' 'ck' '.' 'out' '(' 'x' ')' 'return' '{' ""'return'""
 ':' '0' ',' ""'repo_deps'"" ':' 'rp1' '}']","Input:  {
              data_uoa                   - data UOA of the repo
                 or
              repo_deps                  - dict with dependencies on other shared repos

              (out_prefix)               - output prefix befor each string
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              repo_deps
            }","['Input' ':' '{' 'data_uoa' '-' 'data' 'UOA' 'of' 'the' 'repo' 'or'
 'repo_deps' '-' 'dict' 'with' 'dependencies' 'on' 'other' 'shared'
 'repos']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L1977-L2028
ctuning/ck,ck/repo/module/repo/module.py,add_more_deps,"def add_more_deps(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              repo_deps    - list with dependencies on other repositories ...
            }

    """"""

    rp=[]

    r=ck.inp({'text': 'Would you like to add extra dependencies on other shared repositories (y/N)?: '})
    x=r['string'].lower()
    if x=='yes' or x=='y':
       ck.out('')
       ck.out('Use the following format: repo UOA; (repo UID) (; repo URL)')
       ck.out('For example:')
       ck.out('  ck-autotuning')
       ck.out('  ck-dissemination-modules;;https://github.com/gfursin/ck-dissemination-modules.git')
       ck.out('')
       ck.out('Press Enter to stop adding repositories!')
       ck.out('')

       while True:
          r=ck.inp({'text': ''})
          x=r['string'].strip()
          if x=='': break
             
          z={}

          y=x.split(';')
          if len(y)>0:
             z['repo_uoa']=y[0].strip()
             if len(y)>1:
                z['repo_uid']=y[1].strip()
                if len(y)>2:
                   z['repo_url']=y[2].strip()
         
          if len(z)>0:
             rp.append(z)

    return {'return':0, 'repo_deps':rp}",python,"def add_more_deps(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              repo_deps    - list with dependencies on other repositories ...
            }

    """"""

    rp=[]

    r=ck.inp({'text': 'Would you like to add extra dependencies on other shared repositories (y/N)?: '})
    x=r['string'].lower()
    if x=='yes' or x=='y':
       ck.out('')
       ck.out('Use the following format: repo UOA; (repo UID) (; repo URL)')
       ck.out('For example:')
       ck.out('  ck-autotuning')
       ck.out('  ck-dissemination-modules;;https://github.com/gfursin/ck-dissemination-modules.git')
       ck.out('')
       ck.out('Press Enter to stop adding repositories!')
       ck.out('')

       while True:
          r=ck.inp({'text': ''})
          x=r['string'].strip()
          if x=='': break
             
          z={}

          y=x.split(';')
          if len(y)>0:
             z['repo_uoa']=y[0].strip()
             if len(y)>1:
                z['repo_uid']=y[1].strip()
                if len(y)>2:
                   z['repo_url']=y[2].strip()
         
          if len(z)>0:
             rp.append(z)

    return {'return':0, 'repo_deps':rp}","['def' 'add_more_deps' '(' 'i' ')' ':' 'rp' '=' '[' ']' 'r' '=' 'ck' '.'
 'inp' '(' '{' ""'text'"" ':'
 ""'Would you like to add extra dependencies on other shared repositories (y/N)?: '""
 '}' ')' 'x' '=' 'r' '[' ""'string'"" ']' '.' 'lower' '(' ')' 'if' 'x' '=='
 ""'yes'"" 'or' 'x' '==' ""'y'"" ':' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.'
 'out' '(' ""'Use the following format: repo UOA; (repo UID) (; repo URL)'""
 ')' 'ck' '.' 'out' '(' ""'For example:'"" ')' 'ck' '.' 'out' '('
 ""'  ck-autotuning'"" ')' 'ck' '.' 'out' '('
 ""'  ck-dissemination-modules;;https://github.com/gfursin/ck-dissemination-modules.git'""
 ')' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '('
 ""'Press Enter to stop adding repositories!'"" ')' 'ck' '.' 'out' '(' ""''""
 ')' 'while' 'True' ':' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':' ""''""
 '}' ')' 'x' '=' 'r' '[' ""'string'"" ']' '.' 'strip' '(' ')' 'if' 'x' '=='
 ""''"" ':' 'break' 'z' '=' '{' '}' 'y' '=' 'x' '.' 'split' '(' ""';'"" ')'
 'if' 'len' '(' 'y' ')' '>' '0' ':' 'z' '[' ""'repo_uoa'"" ']' '=' 'y' '['
 '0' ']' '.' 'strip' '(' ')' 'if' 'len' '(' 'y' ')' '>' '1' ':' 'z' '['
 ""'repo_uid'"" ']' '=' 'y' '[' '1' ']' '.' 'strip' '(' ')' 'if' 'len' '('
 'y' ')' '>' '2' ':' 'z' '[' ""'repo_url'"" ']' '=' 'y' '[' '2' ']' '.'
 'strip' '(' ')' 'if' 'len' '(' 'z' ')' '>' '0' ':' 'rp' '.' 'append' '('
 'z' ')' 'return' '{' ""'return'"" ':' '0' ',' ""'repo_deps'"" ':' 'rp' '}']","Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              repo_deps    - list with dependencies on other repositories ...
            }",['Input' ':' '{' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L2033-L2080
ctuning/ck,ck/repo/module/repo/module.py,renew,"def renew(i):
    """"""
    Input:  {
              data_uoa                   - data UOA of the repo

              (stable)                   - take stable version (highly experimental)
              (checkout)                 - checkout (default - stable)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=ck.check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    duoa=i.get('data_uoa','')
    if duoa=='':
       return {'return':1, 'error':'repository UOA is not specified'}

    # Get configuration (not from Cache - can be outdated info!)
#    r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':duoa})
    if r['return']>0: return r

    p=r.get('dict',{}).get('path','')
    d=r['dict']
    dn=r.get('data_name','')

    shared=d.get('shared','')
    url=d.get('url','')

    if shared!='git' and url=='':
       return {'return':1, 'error':'this repository is not shared and can not be renewed!'}

    # first delete
    ii={'action':'rm',
        'module_uoa':work['self_module_uoa'],
        'data_uoa':duoa,
        'all':'yes'}
    if o=='con':
       ii['out']='con'
    r=ck.access(ii)
    if r['return']>0: return r

    # pull again
    ii={'action':'pull',
        'module_uoa':work['self_module_uoa'],
        'data_uoa':duoa,
        'data_name':dn,
        'url':url,
        'stable':i.get('stable',''),
        'checkout':i.get('checkout','')}
    if o=='con':
       ii['out']='con'
    return ck.access(ii)",python,"def renew(i):
    """"""
    Input:  {
              data_uoa                   - data UOA of the repo

              (stable)                   - take stable version (highly experimental)
              (checkout)                 - checkout (default - stable)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=ck.check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    duoa=i.get('data_uoa','')
    if duoa=='':
       return {'return':1, 'error':'repository UOA is not specified'}

    # Get configuration (not from Cache - can be outdated info!)
#    r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':duoa})
    if r['return']>0: return r

    p=r.get('dict',{}).get('path','')
    d=r['dict']
    dn=r.get('data_name','')

    shared=d.get('shared','')
    url=d.get('url','')

    if shared!='git' and url=='':
       return {'return':1, 'error':'this repository is not shared and can not be renewed!'}

    # first delete
    ii={'action':'rm',
        'module_uoa':work['self_module_uoa'],
        'data_uoa':duoa,
        'all':'yes'}
    if o=='con':
       ii['out']='con'
    r=ck.access(ii)
    if r['return']>0: return r

    # pull again
    ii={'action':'pull',
        'module_uoa':work['self_module_uoa'],
        'data_uoa':duoa,
        'data_name':dn,
        'url':url,
        'stable':i.get('stable',''),
        'checkout':i.get('checkout','')}
    if o=='con':
       ii['out']='con'
    return ck.access(ii)","['def' 'renew' '(' 'i' ')' ':' '# Check if global writing is allowed' 'r'
 '=' 'ck' '.' 'check_writing' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']'
 '>' '0' ':' 'return' 'r' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')'
 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if' 'duoa' '=='
 ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'repository UOA is not specified'"" '}'
 '# Get configuration (not from Cache - can be outdated info!)'
 ""#    r=ck.load_repo_info_from_cache({'repo_uoa':duoa})"" 'r' '=' 'ck' '.'
 'access' '(' '{' ""'action'"" ':' ""'load'"" ',' ""'module_uoa'"" ':' 'work'
 '[' ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'p' '=' 'r' '.' 'get' '('
 ""'dict'"" ',' '{' '}' ')' '.' 'get' '(' ""'path'"" ',' ""''"" ')' 'd' '=' 'r'
 '[' ""'dict'"" ']' 'dn' '=' 'r' '.' 'get' '(' ""'data_name'"" ',' ""''"" ')'
 'shared' '=' 'd' '.' 'get' '(' ""'shared'"" ',' ""''"" ')' 'url' '=' 'd' '.'
 'get' '(' ""'url'"" ',' ""''"" ')' 'if' 'shared' '!=' ""'git'"" 'and' 'url'
 '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'this repository is not shared and can not be renewed!'"" '}'
 '# first delete' 'ii' '=' '{' ""'action'"" ':' ""'rm'"" ',' ""'module_uoa'""
 ':' 'work' '[' ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'duoa' ','
 ""'all'"" ':' ""'yes'"" '}' 'if' 'o' '==' ""'con'"" ':' 'ii' '[' ""'out'"" ']'
 '=' ""'con'"" 'r' '=' 'ck' '.' 'access' '(' 'ii' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' '# pull again' 'ii' '=' '{'
 ""'action'"" ':' ""'pull'"" ',' ""'module_uoa'"" ':' 'work' '['
 ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'duoa' ',' ""'data_name'"" ':'
 'dn' ',' ""'url'"" ':' 'url' ',' ""'stable'"" ':' 'i' '.' 'get' '('
 ""'stable'"" ',' ""''"" ')' ',' ""'checkout'"" ':' 'i' '.' 'get' '('
 ""'checkout'"" ',' ""''"" ')' '}' 'if' 'o' '==' ""'con'"" ':' 'ii' '[' ""'out'""
 ']' '=' ""'con'"" 'return' 'ck' '.' 'access' '(' 'ii' ')']","Input:  {
              data_uoa                   - data UOA of the repo

              (stable)                   - take stable version (highly experimental)
              (checkout)                 - checkout (default - stable)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' 'data_uoa' '-' 'data' 'UOA' 'of' 'the' 'repo'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L2115-L2179
ctuning/ck,ck/repo/module/repo/module.py,browse,"def browse(i):
    """"""
    Input:  {
              data_uoa                   - data UOA of the repo
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa=i.get('data_uoa','')
    if duoa=='':
       return {'return':1, 'error':'repository UOA is not specified'}

    # Get configuration (not from Cache - can be outdated info!)
#    r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':duoa})
    if r['return']>0: return r

    p=r.get('dict',{}).get('path','')
    d=r['dict']
    dn=r.get('data_name','')

    shared=d.get('shared','')
    url=d.get('url','')

    if shared!='git' and url=='':
       return {'return':1, 'error':'this repository is not shared!'}

    import webbrowser
    webbrowser.open(url)

    return {'return':0}",python,"def browse(i):
    """"""
    Input:  {
              data_uoa                   - data UOA of the repo
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa=i.get('data_uoa','')
    if duoa=='':
       return {'return':1, 'error':'repository UOA is not specified'}

    # Get configuration (not from Cache - can be outdated info!)
#    r=ck.load_repo_info_from_cache({'repo_uoa':duoa})
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':duoa})
    if r['return']>0: return r

    p=r.get('dict',{}).get('path','')
    d=r['dict']
    dn=r.get('data_name','')

    shared=d.get('shared','')
    url=d.get('url','')

    if shared!='git' and url=='':
       return {'return':1, 'error':'this repository is not shared!'}

    import webbrowser
    webbrowser.open(url)

    return {'return':0}","['def' 'browse' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if' 'duoa'
 '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'repository UOA is not specified'"" '}'
 '# Get configuration (not from Cache - can be outdated info!)'
 ""#    r=ck.load_repo_info_from_cache({'repo_uoa':duoa})"" 'r' '=' 'ck' '.'
 'access' '(' '{' ""'action'"" ':' ""'load'"" ',' ""'module_uoa'"" ':' 'work'
 '[' ""'self_module_uoa'"" ']' ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'p' '=' 'r' '.' 'get' '('
 ""'dict'"" ',' '{' '}' ')' '.' 'get' '(' ""'path'"" ',' ""''"" ')' 'd' '=' 'r'
 '[' ""'dict'"" ']' 'dn' '=' 'r' '.' 'get' '(' ""'data_name'"" ',' ""''"" ')'
 'shared' '=' 'd' '.' 'get' '(' ""'shared'"" ',' ""''"" ')' 'url' '=' 'd' '.'
 'get' '(' ""'url'"" ',' ""''"" ')' 'if' 'shared' '!=' ""'git'"" 'and' 'url'
 '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'this repository is not shared!'"" '}' 'import' 'webbrowser' 'webbrowser'
 '.' 'open' '(' 'url' ')' 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              data_uoa                   - data UOA of the repo
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' 'data_uoa' '-' 'data' 'UOA' 'of' 'the' 'repo' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L2184-L2224
ctuning/ck,ck/repo/module/repo/module.py,describe,"def describe(i):
    """"""
    Input:  {
              (dict)  - dict with current repo description
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              (dict)  - updated dict with current repo description
            }

    """"""

    d=i.get('dict',{})

    a=d.get('artifact_pack_description',{})

    ck.out('')
    ck.out('Please, provide description of your artifact pack (see http://cTuning.org/ae for more details):')
    ck.out('')

    r=ck.inp({'text':'Enter title of your artifact pack (or associated paper): '})
    x=r['string']
    if x!='': a['title']=x

    r=ck.inp({'text':'List contributors: '})
    x=r['string']
    if x!='': a['contributors']=x

    r=ck.inp({'text':'Enter artifact abstract: '})
    x=r['string']
    if x!='': a['description']=x

    r=ck.inp({'text':'Enter license of the whole artifact pack: '})
    x=r['string']
    if x!='': a['license']=x

    r=ck.inp({'text':'Enter version/revision of the whole artifact pack: '})
    x=r['string']
    if x!='': a['version']=x

    r=ck.inp({'text':'How delivered (URL, DOI, OCRID, etc): '})
    x=r['string']
    if x!='': a['how_delivered']=x

    r=ck.inp({'text':'Describe software dependencies: '})
    x=r['string']
    if x!='': a['software_dependencies']=x

    r=ck.inp({'text':'Describe hardware dependencies: '})
    x=r['string']
    if x!='': a['hardware_dependencies']=x

    r=ck.inp({'text':'Describe data sets: '})
    x=r['string']
    if x!='': a['datasets']=x

    r=ck.inp({'text':'Describe installation procedure: '})
    x=r['string']
    if x!='': a['installation']=x

    r=ck.inp({'text':'Describe possible experiment parameterization: '})
    x=r['string']
    if x!='': a['parameterization']=x

    r=ck.inp({'text':'Describe experiment workflow: '})
    x=r['string']
    if x!='': a['experiment_workflow']=x

    r=ck.inp({'text':'Describe evaluation procedure and expected output: '})
    x=r['string']
    if x!='': a['evaluation']=x

    r=ck.inp({'text':'Acknowledgments: '})
    x=r['string']
    if x!='': a['acknowledgments']=x

    r=ck.inp({'text':'Misc notes: '})
    x=r['string']
    if x!='': a['notes']=x

    d['artifact_pack_description']=a

    return {'return':0, 'dict':d}",python,"def describe(i):
    """"""
    Input:  {
              (dict)  - dict with current repo description
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              (dict)  - updated dict with current repo description
            }

    """"""

    d=i.get('dict',{})

    a=d.get('artifact_pack_description',{})

    ck.out('')
    ck.out('Please, provide description of your artifact pack (see http://cTuning.org/ae for more details):')
    ck.out('')

    r=ck.inp({'text':'Enter title of your artifact pack (or associated paper): '})
    x=r['string']
    if x!='': a['title']=x

    r=ck.inp({'text':'List contributors: '})
    x=r['string']
    if x!='': a['contributors']=x

    r=ck.inp({'text':'Enter artifact abstract: '})
    x=r['string']
    if x!='': a['description']=x

    r=ck.inp({'text':'Enter license of the whole artifact pack: '})
    x=r['string']
    if x!='': a['license']=x

    r=ck.inp({'text':'Enter version/revision of the whole artifact pack: '})
    x=r['string']
    if x!='': a['version']=x

    r=ck.inp({'text':'How delivered (URL, DOI, OCRID, etc): '})
    x=r['string']
    if x!='': a['how_delivered']=x

    r=ck.inp({'text':'Describe software dependencies: '})
    x=r['string']
    if x!='': a['software_dependencies']=x

    r=ck.inp({'text':'Describe hardware dependencies: '})
    x=r['string']
    if x!='': a['hardware_dependencies']=x

    r=ck.inp({'text':'Describe data sets: '})
    x=r['string']
    if x!='': a['datasets']=x

    r=ck.inp({'text':'Describe installation procedure: '})
    x=r['string']
    if x!='': a['installation']=x

    r=ck.inp({'text':'Describe possible experiment parameterization: '})
    x=r['string']
    if x!='': a['parameterization']=x

    r=ck.inp({'text':'Describe experiment workflow: '})
    x=r['string']
    if x!='': a['experiment_workflow']=x

    r=ck.inp({'text':'Describe evaluation procedure and expected output: '})
    x=r['string']
    if x!='': a['evaluation']=x

    r=ck.inp({'text':'Acknowledgments: '})
    x=r['string']
    if x!='': a['acknowledgments']=x

    r=ck.inp({'text':'Misc notes: '})
    x=r['string']
    if x!='': a['notes']=x

    d['artifact_pack_description']=a

    return {'return':0, 'dict':d}","['def' 'describe' '(' 'i' ')' ':' 'd' '=' 'i' '.' 'get' '(' ""'dict'"" ','
 '{' '}' ')' 'a' '=' 'd' '.' 'get' '(' ""'artifact_pack_description'"" ','
 '{' '}' ')' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '('
 ""'Please, provide description of your artifact pack (see http://cTuning.org/ae for more details):'""
 ')' 'ck' '.' 'out' '(' ""''"" ')' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'""
 ':' ""'Enter title of your artifact pack (or associated paper): '"" '}' ')'
 'x' '=' 'r' '[' ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'title'""
 ']' '=' 'x' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'List contributors: '"" '}' ')' 'x' '=' 'r' '[' ""'string'"" ']' 'if' 'x'
 '!=' ""''"" ':' 'a' '[' ""'contributors'"" ']' '=' 'x' 'r' '=' 'ck' '.' 'inp'
 '(' '{' ""'text'"" ':' ""'Enter artifact abstract: '"" '}' ')' 'x' '=' 'r'
 '[' ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'description'"" ']' '='
 'x' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Enter license of the whole artifact pack: '"" '}' ')' 'x' '=' 'r' '['
 ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'license'"" ']' '=' 'x' 'r'
 '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Enter version/revision of the whole artifact pack: '"" '}' ')' 'x' '='
 'r' '[' ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'version'"" ']' '='
 'x' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'How delivered (URL, DOI, OCRID, etc): '"" '}' ')' 'x' '=' 'r' '['
 ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'how_delivered'"" ']' '='
 'x' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Describe software dependencies: '"" '}' ')' 'x' '=' 'r' '[' ""'string'""
 ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'software_dependencies'"" ']' '=' 'x'
 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Describe hardware dependencies: '"" '}' ')' 'x' '=' 'r' '[' ""'string'""
 ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'hardware_dependencies'"" ']' '=' 'x'
 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':' ""'Describe data sets: '"" '}'
 ')' 'x' '=' 'r' '[' ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'a' '['
 ""'datasets'"" ']' '=' 'x' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Describe installation procedure: '"" '}' ')' 'x' '=' 'r' '[' ""'string'""
 ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'installation'"" ']' '=' 'x' 'r' '='
 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Describe possible experiment parameterization: '"" '}' ')' 'x' '=' 'r'
 '[' ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'parameterization'""
 ']' '=' 'x' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Describe experiment workflow: '"" '}' ')' 'x' '=' 'r' '[' ""'string'"" ']'
 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'experiment_workflow'"" ']' '=' 'x' 'r'
 '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':'
 ""'Describe evaluation procedure and expected output: '"" '}' ')' 'x' '='
 'r' '[' ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'a' '[' ""'evaluation'"" ']'
 '=' 'x' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'"" ':' ""'Acknowledgments: '""
 '}' ')' 'x' '=' 'r' '[' ""'string'"" ']' 'if' 'x' '!=' ""''"" ':' 'a' '['
 ""'acknowledgments'"" ']' '=' 'x' 'r' '=' 'ck' '.' 'inp' '(' '{' ""'text'""
 ':' ""'Misc notes: '"" '}' ')' 'x' '=' 'r' '[' ""'string'"" ']' 'if' 'x' '!='
 ""''"" ':' 'a' '[' ""'notes'"" ']' '=' 'x' 'd' '['
 ""'artifact_pack_description'"" ']' '=' 'a' 'return' '{' ""'return'"" ':' '0'
 ',' ""'dict'"" ':' 'd' '}']","Input:  {
              (dict)  - dict with current repo description
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              (dict)  - updated dict with current repo description
            }","['Input' ':' '{' '(' 'dict' ')' '-' 'dict' 'with' 'current' 'repo'
 'description' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L2229-L2315
ctuning/ck,ck/repo/module/repo/module.py,form_url,"def form_url(i):
    """"""
    Input:  {
              (url)                      - if type=='remote' or 'git', URL of remote repository or git repository
              (hostname)                 - if !='', automatically form url above (add http:// + /ck?)
              (port)                     - if !='', automatically add to url above
              (hostext)                  - if !='', add to the end of above URL instead of '/ck?' -
                                           useful when CK server is accessed via Apache2, IIS or other web servers
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              url          - formed URL
            }

    """"""

    url=i.get('url','')

    if i.get('hostname','')!='':
       url='http://'+i['hostname']

       if i.get('port','')!='':
          url+=':'+i['port']

       if i.get('hostext','')!='':
          url+='/'+i['hostext']
       else:
          url+='/ck?'

    return {'return':0, 'url':url}",python,"def form_url(i):
    """"""
    Input:  {
              (url)                      - if type=='remote' or 'git', URL of remote repository or git repository
              (hostname)                 - if !='', automatically form url above (add http:// + /ck?)
              (port)                     - if !='', automatically add to url above
              (hostext)                  - if !='', add to the end of above URL instead of '/ck?' -
                                           useful when CK server is accessed via Apache2, IIS or other web servers
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              url          - formed URL
            }

    """"""

    url=i.get('url','')

    if i.get('hostname','')!='':
       url='http://'+i['hostname']

       if i.get('port','')!='':
          url+=':'+i['port']

       if i.get('hostext','')!='':
          url+='/'+i['hostext']
       else:
          url+='/ck?'

    return {'return':0, 'url':url}","['def' 'form_url' '(' 'i' ')' ':' 'url' '=' 'i' '.' 'get' '(' ""'url'"" ','
 ""''"" ')' 'if' 'i' '.' 'get' '(' ""'hostname'"" ',' ""''"" ')' '!=' ""''"" ':'
 'url' '=' ""'http://'"" '+' 'i' '[' ""'hostname'"" ']' 'if' 'i' '.' 'get' '('
 ""'port'"" ',' ""''"" ')' '!=' ""''"" ':' 'url' '+=' ""':'"" '+' 'i' '[' ""'port'""
 ']' 'if' 'i' '.' 'get' '(' ""'hostext'"" ',' ""''"" ')' '!=' ""''"" ':' 'url'
 '+=' ""'/'"" '+' 'i' '[' ""'hostext'"" ']' 'else' ':' 'url' '+=' ""'/ck?'""
 'return' '{' ""'return'"" ':' '0' ',' ""'url'"" ':' 'url' '}']","Input:  {
              (url)                      - if type=='remote' or 'git', URL of remote repository or git repository
              (hostname)                 - if !='', automatically form url above (add http:// + /ck?)
              (port)                     - if !='', automatically add to url above
              (hostext)                  - if !='', add to the end of above URL instead of '/ck?' -
                                           useful when CK server is accessed via Apache2, IIS or other web servers
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              url          - formed URL
            }","['Input' ':' '{' '(' 'url' ')' '-' 'if' 'type' '==' 'remote' 'or' 'git'
 'URL' 'of' 'remote' 'repository' 'or' 'git' 'repository' '(' 'hostname'
 ')' '-' 'if' '!' '=' 'automatically' 'form' 'url' 'above' '(' 'add'
 'http' ':' '//' '+' '/' 'ck?' ')' '(' 'port' ')' '-' 'if' '!' '='
 'automatically' 'add' 'to' 'url' 'above' '(' 'hostext' ')' '-' 'if' '!'
 '=' 'add' 'to' 'the' 'end' 'of' 'above' 'URL' 'instead' 'of' '/' 'ck?'
 '-' 'useful' 'when' 'CK' 'server' 'is' 'accessed' 'via' 'Apache2' 'IIS'
 'or' 'other' 'web' 'servers' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L2320-L2353
ctuning/ck,ck/repo/module/repo/module.py,show,"def show(i):
    """"""
    Input:  {
              (data_uoa) - repo UOA

              (reset)    - if 'yes', reset repos

              (stable)   - take stable version (highly experimental)
              (version)  - checkout version (default - stable)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    import os

    o=i.get('out','')

    curdir=os.getcwd()

    duoa=i.get('data_uoa','')

    reset=i.get('reset','')

    stable=i.get('stable','')
    version=i.get('version','')
    if stable=='yes': version='stable'

    r=ck.list_data({'module_uoa':work['self_module_uoa'], 
                    'data_uoa':duoa})
    if r['return']>0: return r

    if o=='con':
       ck.out('Please wait - it may take some time ...')
       ck.out('')

    r=ck.reload_repo_cache({}) # Ignore errors

    # Init header.
    pp=[({'branch':'branch', 'origin':'origin', 'checkout':'local', 'path':'path', 'type':'type', 'url':'url', 'data_uoa':'data_uoa'})]
    il=0
    for q in ck.cache_repo_info:
        # Get repo info
        qq=ck.cache_repo_info[q]

        d=qq['dict']

        t=d.get('shared','')

        if t!='':
           duoa=qq['data_uoa']

           if len(duoa)>il: il=len(duoa)

           p=d.get('path','')
           url=d.get('url','')

           branch=''
           origin=''
           checkout=''

           if os.path.isdir(p):
              # Detect status
              os.chdir(p)

              if reset=='yes':
                 r=ck.run_and_get_stdout({'cmd':['git','checkout','master']})

              if version!='':
                 cx=qq.get('dict',{}).get('checkouts',{}).get(version,{})
                 branch=cx.get('branch','')
                 checkout=cx.get('checkout','')

                 if branch!='':
                    r=ck.run_and_get_stdout({'cmd':['git','checkout',branch]})

                 if checkout!='':
                    r=ck.run_and_get_stdout({'cmd':['git','checkout',checkout]})

              # FGG TBD: we may need to add explicit check for branch/checkout in repo_deps here?
              # OR MAYBE NOT - need to think ...

              # Get current branch
              r=ck.run_and_get_stdout({'cmd':['git','rev-parse','--abbrev-ref','HEAD']})
              if r['return']==0 and r['return_code']==0:
                 branch=r['stdout'].strip()

              # Get origin hash
              r=ck.run_and_get_stdout({'cmd':['git','rev-parse','--short','origin/HEAD']})
              if r['return']==0 and r['return_code']==0:
                 origin=r['stdout'].strip()

              # Get current hash (append '-dirty' on dirty working tree)
              r=ck.run_and_get_stdout({'cmd':['git','describe','--match=NeVeRmAtCh','--always','--abbrev','--dirty']})
              if r['return']==0 and r['return_code']==0:
                 checkout=r['stdout'].strip()

           pp.append({'branch':branch, 'origin':origin, 'checkout':checkout, 'path':p, 'type':t, 'url':url, 'data_uoa':duoa})

    # Print
    for q in pp:
        name=q['data_uoa']

        x=name+' '*(il-len(name))

        branch=q.get('branch','')
        origin=q.get('origin','')
        checkout=q.get('checkout','')
        url=q.get('url','')

        if branch!='' or 'origin' or checkout!='' or url!='':
           x+=' ( '+branch+' ; '+origin+' ; '+checkout+' ; '+url+' )'

        ck.out(x)

    os.chdir(curdir)

    return {'return':0}",python,"def show(i):
    """"""
    Input:  {
              (data_uoa) - repo UOA

              (reset)    - if 'yes', reset repos

              (stable)   - take stable version (highly experimental)
              (version)  - checkout version (default - stable)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    import os

    o=i.get('out','')

    curdir=os.getcwd()

    duoa=i.get('data_uoa','')

    reset=i.get('reset','')

    stable=i.get('stable','')
    version=i.get('version','')
    if stable=='yes': version='stable'

    r=ck.list_data({'module_uoa':work['self_module_uoa'], 
                    'data_uoa':duoa})
    if r['return']>0: return r

    if o=='con':
       ck.out('Please wait - it may take some time ...')
       ck.out('')

    r=ck.reload_repo_cache({}) # Ignore errors

    # Init header.
    pp=[({'branch':'branch', 'origin':'origin', 'checkout':'local', 'path':'path', 'type':'type', 'url':'url', 'data_uoa':'data_uoa'})]
    il=0
    for q in ck.cache_repo_info:
        # Get repo info
        qq=ck.cache_repo_info[q]

        d=qq['dict']

        t=d.get('shared','')

        if t!='':
           duoa=qq['data_uoa']

           if len(duoa)>il: il=len(duoa)

           p=d.get('path','')
           url=d.get('url','')

           branch=''
           origin=''
           checkout=''

           if os.path.isdir(p):
              # Detect status
              os.chdir(p)

              if reset=='yes':
                 r=ck.run_and_get_stdout({'cmd':['git','checkout','master']})

              if version!='':
                 cx=qq.get('dict',{}).get('checkouts',{}).get(version,{})
                 branch=cx.get('branch','')
                 checkout=cx.get('checkout','')

                 if branch!='':
                    r=ck.run_and_get_stdout({'cmd':['git','checkout',branch]})

                 if checkout!='':
                    r=ck.run_and_get_stdout({'cmd':['git','checkout',checkout]})

              # FGG TBD: we may need to add explicit check for branch/checkout in repo_deps here?
              # OR MAYBE NOT - need to think ...

              # Get current branch
              r=ck.run_and_get_stdout({'cmd':['git','rev-parse','--abbrev-ref','HEAD']})
              if r['return']==0 and r['return_code']==0:
                 branch=r['stdout'].strip()

              # Get origin hash
              r=ck.run_and_get_stdout({'cmd':['git','rev-parse','--short','origin/HEAD']})
              if r['return']==0 and r['return_code']==0:
                 origin=r['stdout'].strip()

              # Get current hash (append '-dirty' on dirty working tree)
              r=ck.run_and_get_stdout({'cmd':['git','describe','--match=NeVeRmAtCh','--always','--abbrev','--dirty']})
              if r['return']==0 and r['return_code']==0:
                 checkout=r['stdout'].strip()

           pp.append({'branch':branch, 'origin':origin, 'checkout':checkout, 'path':p, 'type':t, 'url':url, 'data_uoa':duoa})

    # Print
    for q in pp:
        name=q['data_uoa']

        x=name+' '*(il-len(name))

        branch=q.get('branch','')
        origin=q.get('origin','')
        checkout=q.get('checkout','')
        url=q.get('url','')

        if branch!='' or 'origin' or checkout!='' or url!='':
           x+=' ( '+branch+' ; '+origin+' ; '+checkout+' ; '+url+' )'

        ck.out(x)

    os.chdir(curdir)

    return {'return':0}","['def' 'show' '(' 'i' ')' ':' 'import' 'os' 'o' '=' 'i' '.' 'get' '('
 ""'out'"" ',' ""''"" ')' 'curdir' '=' 'os' '.' 'getcwd' '(' ')' 'duoa' '='
 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'reset' '=' 'i' '.' 'get' '('
 ""'reset'"" ',' ""''"" ')' 'stable' '=' 'i' '.' 'get' '(' ""'stable'"" ',' ""''""
 ')' 'version' '=' 'i' '.' 'get' '(' ""'version'"" ',' ""''"" ')' 'if'
 'stable' '==' ""'yes'"" ':' 'version' '=' ""'stable'"" 'r' '=' 'ck' '.'
 'list_data' '(' '{' ""'module_uoa'"" ':' 'work' '[' ""'self_module_uoa'"" ']'
 ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '('
 ""'Please wait - it may take some time ...'"" ')' 'ck' '.' 'out' '(' ""''""
 ')' 'r' '=' 'ck' '.' 'reload_repo_cache' '(' '{' '}' ')'
 '# Ignore errors' '# Init header.' 'pp' '=' '[' '(' '{' ""'branch'"" ':'
 ""'branch'"" ',' ""'origin'"" ':' ""'origin'"" ',' ""'checkout'"" ':' ""'local'""
 ',' ""'path'"" ':' ""'path'"" ',' ""'type'"" ':' ""'type'"" ',' ""'url'"" ':'
 ""'url'"" ',' ""'data_uoa'"" ':' ""'data_uoa'"" '}' ')' ']' 'il' '=' '0' 'for'
 'q' 'in' 'ck' '.' 'cache_repo_info' ':' '# Get repo info' 'qq' '=' 'ck'
 '.' 'cache_repo_info' '[' 'q' ']' 'd' '=' 'qq' '[' ""'dict'"" ']' 't' '='
 'd' '.' 'get' '(' ""'shared'"" ',' ""''"" ')' 'if' 't' '!=' ""''"" ':' 'duoa'
 '=' 'qq' '[' ""'data_uoa'"" ']' 'if' 'len' '(' 'duoa' ')' '>' 'il' ':' 'il'
 '=' 'len' '(' 'duoa' ')' 'p' '=' 'd' '.' 'get' '(' ""'path'"" ',' ""''"" ')'
 'url' '=' 'd' '.' 'get' '(' ""'url'"" ',' ""''"" ')' 'branch' '=' ""''""
 'origin' '=' ""''"" 'checkout' '=' ""''"" 'if' 'os' '.' 'path' '.' 'isdir'
 '(' 'p' ')' ':' '# Detect status' 'os' '.' 'chdir' '(' 'p' ')' 'if'
 'reset' '==' ""'yes'"" ':' 'r' '=' 'ck' '.' 'run_and_get_stdout' '(' '{'
 ""'cmd'"" ':' '[' ""'git'"" ',' ""'checkout'"" ',' ""'master'"" ']' '}' ')' 'if'
 'version' '!=' ""''"" ':' 'cx' '=' 'qq' '.' 'get' '(' ""'dict'"" ',' '{' '}'
 ')' '.' 'get' '(' ""'checkouts'"" ',' '{' '}' ')' '.' 'get' '(' 'version'
 ',' '{' '}' ')' 'branch' '=' 'cx' '.' 'get' '(' ""'branch'"" ',' ""''"" ')'
 'checkout' '=' 'cx' '.' 'get' '(' ""'checkout'"" ',' ""''"" ')' 'if' 'branch'
 '!=' ""''"" ':' 'r' '=' 'ck' '.' 'run_and_get_stdout' '(' '{' ""'cmd'"" ':'
 '[' ""'git'"" ',' ""'checkout'"" ',' 'branch' ']' '}' ')' 'if' 'checkout'
 '!=' ""''"" ':' 'r' '=' 'ck' '.' 'run_and_get_stdout' '(' '{' ""'cmd'"" ':'
 '[' ""'git'"" ',' ""'checkout'"" ',' 'checkout' ']' '}' ')'
 '# FGG TBD: we may need to add explicit check for branch/checkout in repo_deps here?'
 '# OR MAYBE NOT - need to think ...' '# Get current branch' 'r' '=' 'ck'
 '.' 'run_and_get_stdout' '(' '{' ""'cmd'"" ':' '[' ""'git'"" ','
 ""'rev-parse'"" ',' ""'--abbrev-ref'"" ',' ""'HEAD'"" ']' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '==' '0' 'and' 'r' '[' ""'return_code'"" ']' '==' '0' ':'
 'branch' '=' 'r' '[' ""'stdout'"" ']' '.' 'strip' '(' ')'
 '# Get origin hash' 'r' '=' 'ck' '.' 'run_and_get_stdout' '(' '{' ""'cmd'""
 ':' '[' ""'git'"" ',' ""'rev-parse'"" ',' ""'--short'"" ',' ""'origin/HEAD'"" ']'
 '}' ')' 'if' 'r' '[' ""'return'"" ']' '==' '0' 'and' 'r' '['
 ""'return_code'"" ']' '==' '0' ':' 'origin' '=' 'r' '[' ""'stdout'"" ']' '.'
 'strip' '(' ')'
 ""# Get current hash (append '-dirty' on dirty working tree)"" 'r' '=' 'ck'
 '.' 'run_and_get_stdout' '(' '{' ""'cmd'"" ':' '[' ""'git'"" ',' ""'describe'""
 ',' ""'--match=NeVeRmAtCh'"" ',' ""'--always'"" ',' ""'--abbrev'"" ','
 ""'--dirty'"" ']' '}' ')' 'if' 'r' '[' ""'return'"" ']' '==' '0' 'and' 'r'
 '[' ""'return_code'"" ']' '==' '0' ':' 'checkout' '=' 'r' '[' ""'stdout'""
 ']' '.' 'strip' '(' ')' 'pp' '.' 'append' '(' '{' ""'branch'"" ':' 'branch'
 ',' ""'origin'"" ':' 'origin' ',' ""'checkout'"" ':' 'checkout' ',' ""'path'""
 ':' 'p' ',' ""'type'"" ':' 't' ',' ""'url'"" ':' 'url' ',' ""'data_uoa'"" ':'
 'duoa' '}' ')' '# Print' 'for' 'q' 'in' 'pp' ':' 'name' '=' 'q' '['
 ""'data_uoa'"" ']' 'x' '=' 'name' '+' ""' '"" '*' '(' 'il' '-' 'len' '('
 'name' ')' ')' 'branch' '=' 'q' '.' 'get' '(' ""'branch'"" ',' ""''"" ')'
 'origin' '=' 'q' '.' 'get' '(' ""'origin'"" ',' ""''"" ')' 'checkout' '=' 'q'
 '.' 'get' '(' ""'checkout'"" ',' ""''"" ')' 'url' '=' 'q' '.' 'get' '('
 ""'url'"" ',' ""''"" ')' 'if' 'branch' '!=' ""''"" 'or' ""'origin'"" 'or'
 'checkout' '!=' ""''"" 'or' 'url' '!=' ""''"" ':' 'x' '+=' ""' ( '"" '+'
 'branch' '+' ""' ; '"" '+' 'origin' '+' ""' ; '"" '+' 'checkout' '+' ""' ; '""
 '+' 'url' '+' ""' )'"" 'ck' '.' 'out' '(' 'x' ')' 'os' '.' 'chdir' '('
 'curdir' ')' 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              (data_uoa) - repo UOA

              (reset)    - if 'yes', reset repos

              (stable)   - take stable version (highly experimental)
              (version)  - checkout version (default - stable)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' '(' 'data_uoa' ')' '-' 'repo' 'UOA'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L2358-L2480
ctuning/ck,ck/repo/module/repo/module.py,ren,"def ren(i):
    """"""
    Input:  {
              data_uoa  - repo UOA

              (new_data_uoa)
                 or
              xcids[0]           - {'data_uoa'} - new data UOA
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa=i.get('data_uoa','')

    if duoa=='':
       return {'return':1, 'error':'repo is not defined'}

    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uid'],
                 'data_uoa':duoa})
    if r['return']>0: return r

    dd=r['dict']
    dp=r['path']
    duoa_real=r['data_uoa']
    dname=r['data_name']

    nduoa=i.get('new_data_uoa','')

    if nduoa=='':
       xcids=i.get('xcids',[])
       if len(xcids)>0: 
          xcid=xcids[0]
          nduoa=xcid.get('data_uoa','')

    if nduoa=='':
       xcids=i.get('cids',[])
       if len(xcids)>0: 
          nduoa=xcids[0]

    if nduoa=='': 
       return {'return':1, 'error':'new repo name is not defined'}

    if nduoa=='': 
       return {'return':1, 'error':'new repo name is not defined'}

    if nduoa=='local' or nduoa=='default': 
       return {'return':1, 'error':'new repo name already exists'}

    # Check if such repo doesn't exist
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uid'],
                 'data_uoa':nduoa})
    if r['return']==0:
       return {'return':1, 'error':'repo already exists'}

    # Update .ckr.json
    dpp=dd.get('path','')
    if dpp!='':
       pckr=os.path.join(dpp,ck.cfg['repo_file'])

       r=ck.load_json_file({'json_file':pckr})
       if r['return']>0: return r

       dckr=r['dict']

       x=dckr.get('data_uoa','')
       if x!='' and x==duoa_real: dckr['data_uoa']=nduoa

       x=dckr.get('data_alias','')
       if x!='' and x==duoa_real: dckr['data_alias']=nduoa

       x=dckr.get('data_name','')
       if x!='' and x==duoa_real: dckr['data_name']=nduoa

       r=ck.save_json_to_file({'json_file':pckr, 'dict':dckr})
       if r['return']>0: return r

    # Rename repo entry using internal command
    r=ck.access({'action':'ren',
                 'module_uoa':work['self_module_uid'],
                 'data_uoa':duoa,
                 'new_data_uoa':nduoa,
                 'common_func':'yes'})
    if r['return']>0: return r

    # Recache repos
    r1=recache({'out':o})
    if r1['return']>0: return r1

    return r",python,"def ren(i):
    """"""
    Input:  {
              data_uoa  - repo UOA

              (new_data_uoa)
                 or
              xcids[0]           - {'data_uoa'} - new data UOA
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    duoa=i.get('data_uoa','')

    if duoa=='':
       return {'return':1, 'error':'repo is not defined'}

    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uid'],
                 'data_uoa':duoa})
    if r['return']>0: return r

    dd=r['dict']
    dp=r['path']
    duoa_real=r['data_uoa']
    dname=r['data_name']

    nduoa=i.get('new_data_uoa','')

    if nduoa=='':
       xcids=i.get('xcids',[])
       if len(xcids)>0: 
          xcid=xcids[0]
          nduoa=xcid.get('data_uoa','')

    if nduoa=='':
       xcids=i.get('cids',[])
       if len(xcids)>0: 
          nduoa=xcids[0]

    if nduoa=='': 
       return {'return':1, 'error':'new repo name is not defined'}

    if nduoa=='': 
       return {'return':1, 'error':'new repo name is not defined'}

    if nduoa=='local' or nduoa=='default': 
       return {'return':1, 'error':'new repo name already exists'}

    # Check if such repo doesn't exist
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uid'],
                 'data_uoa':nduoa})
    if r['return']==0:
       return {'return':1, 'error':'repo already exists'}

    # Update .ckr.json
    dpp=dd.get('path','')
    if dpp!='':
       pckr=os.path.join(dpp,ck.cfg['repo_file'])

       r=ck.load_json_file({'json_file':pckr})
       if r['return']>0: return r

       dckr=r['dict']

       x=dckr.get('data_uoa','')
       if x!='' and x==duoa_real: dckr['data_uoa']=nduoa

       x=dckr.get('data_alias','')
       if x!='' and x==duoa_real: dckr['data_alias']=nduoa

       x=dckr.get('data_name','')
       if x!='' and x==duoa_real: dckr['data_name']=nduoa

       r=ck.save_json_to_file({'json_file':pckr, 'dict':dckr})
       if r['return']>0: return r

    # Rename repo entry using internal command
    r=ck.access({'action':'ren',
                 'module_uoa':work['self_module_uid'],
                 'data_uoa':duoa,
                 'new_data_uoa':nduoa,
                 'common_func':'yes'})
    if r['return']>0: return r

    # Recache repos
    r1=recache({'out':o})
    if r1['return']>0: return r1

    return r","['def' 'ren' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if' 'duoa'
 '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'repo is not defined'"" '}' 'r' '=' 'ck' '.' 'access' '(' '{' ""'action'""
 ':' ""'load'"" ',' ""'module_uoa'"" ':' 'work' '[' ""'self_module_uid'"" ']'
 ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' 'dd' '=' 'r' '[' ""'dict'"" ']' 'dp' '=' 'r' '[' ""'path'""
 ']' 'duoa_real' '=' 'r' '[' ""'data_uoa'"" ']' 'dname' '=' 'r' '['
 ""'data_name'"" ']' 'nduoa' '=' 'i' '.' 'get' '(' ""'new_data_uoa'"" ',' ""''""
 ')' 'if' 'nduoa' '==' ""''"" ':' 'xcids' '=' 'i' '.' 'get' '(' ""'xcids'""
 ',' '[' ']' ')' 'if' 'len' '(' 'xcids' ')' '>' '0' ':' 'xcid' '=' 'xcids'
 '[' '0' ']' 'nduoa' '=' 'xcid' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')'
 'if' 'nduoa' '==' ""''"" ':' 'xcids' '=' 'i' '.' 'get' '(' ""'cids'"" ',' '['
 ']' ')' 'if' 'len' '(' 'xcids' ')' '>' '0' ':' 'nduoa' '=' 'xcids' '['
 '0' ']' 'if' 'nduoa' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'new repo name is not defined'"" '}' 'if' 'nduoa' '==' ""''""
 ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'new repo name is not defined'"" '}' 'if' 'nduoa' '==' ""'local'"" 'or'
 'nduoa' '==' ""'default'"" ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'new repo name already exists'"" '}'
 ""# Check if such repo doesn't exist"" 'r' '=' 'ck' '.' 'access' '(' '{'
 ""'action'"" ':' ""'load'"" ',' ""'module_uoa'"" ':' 'work' '['
 ""'self_module_uid'"" ']' ',' ""'data_uoa'"" ':' 'nduoa' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '==' '0' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' ""'repo already exists'"" '}' '# Update .ckr.json' 'dpp' '=' 'dd' '.'
 'get' '(' ""'path'"" ',' ""''"" ')' 'if' 'dpp' '!=' ""''"" ':' 'pckr' '=' 'os'
 '.' 'path' '.' 'join' '(' 'dpp' ',' 'ck' '.' 'cfg' '[' ""'repo_file'"" ']'
 ')' 'r' '=' 'ck' '.' 'load_json_file' '(' '{' ""'json_file'"" ':' 'pckr'
 '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'dckr' '='
 'r' '[' ""'dict'"" ']' 'x' '=' 'dckr' '.' 'get' '(' ""'data_uoa'"" ',' ""''""
 ')' 'if' 'x' '!=' ""''"" 'and' 'x' '==' 'duoa_real' ':' 'dckr' '['
 ""'data_uoa'"" ']' '=' 'nduoa' 'x' '=' 'dckr' '.' 'get' '(' ""'data_alias'""
 ',' ""''"" ')' 'if' 'x' '!=' ""''"" 'and' 'x' '==' 'duoa_real' ':' 'dckr' '['
 ""'data_alias'"" ']' '=' 'nduoa' 'x' '=' 'dckr' '.' 'get' '(' ""'data_name'""
 ',' ""''"" ')' 'if' 'x' '!=' ""''"" 'and' 'x' '==' 'duoa_real' ':' 'dckr' '['
 ""'data_name'"" ']' '=' 'nduoa' 'r' '=' 'ck' '.' 'save_json_to_file' '('
 '{' ""'json_file'"" ':' 'pckr' ',' ""'dict'"" ':' 'dckr' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r'
 '# Rename repo entry using internal command' 'r' '=' 'ck' '.' 'access'
 '(' '{' ""'action'"" ':' ""'ren'"" ',' ""'module_uoa'"" ':' 'work' '['
 ""'self_module_uid'"" ']' ',' ""'data_uoa'"" ':' 'duoa' ',' ""'new_data_uoa'""
 ':' 'nduoa' ',' ""'common_func'"" ':' ""'yes'"" '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' '# Recache repos' 'r1' '='
 'recache' '(' '{' ""'out'"" ':' 'o' '}' ')' 'if' 'r1' '[' ""'return'"" ']'
 '>' '0' ':' 'return' 'r1' 'return' 'r']","Input:  {
              data_uoa  - repo UOA

              (new_data_uoa)
                 or
              xcids[0]           - {'data_uoa'} - new data UOA
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' 'data_uoa' '-' 'repo' 'UOA'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/repo/module.py#L2509-L2607
ctuning/ck,ck/repo/module/all/module.py,pull,"def pull(i):
    """"""
    Input:  {
              (kernel)  - if 'yes', pull kernel too (unless installed as a package)
              (install) - if 'yes', install CK kernel as python module (via python setup.py install)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    import os

    o=i.get('out','')

    kernel=i.get('kernel','')
    install=i.get('install','')

    if kernel=='yes' or install=='yes':
       ck_root=ck.work['env_root']

       if not os.path.isdir(ck_root):
          return {'return':1, 'error':'Can\'t find CK in '+ck_root+' - please check CK_ROOT env'}

       os.chdir(ck_root)

    if kernel=='yes':
       cont=True
       if not os.path.isdir(os.path.join(ck_root,'.git')) and i.get('force','')!='yes':
          ck.out('WARNING: seems like your CK_ROOT installation is not from GitHub - skipping kernel update ...')
          ck.out('')
          cont=False

       if cont:
          if o=='con':
             ck.out('Updating CK from GitHub ...')
             ck.out('')
             ck.out('  cd '+ck_root)
             ck.out('  git pull')
             ck.out('')

          rx=os.system('git pull')
          if rx>0: 
             return {'return':1, 'error':'CK update failed'}

          if o=='con':
             ck.out('')

    if install=='yes':
       c=ck.cfg['install_ck_as_lib']

       py=os.getenv('CK_PYTHON','')
       if py!='':
          c=c.replace('python ',py+' ')

       ck.out('')
       ck.out('Installing CK kernel as python module ...')

       ck.out('')
       ck.out('  cd '+ck_root)

       # Get OS
       r=ck.get_os_ck({})
       if r['return']>0: return r
       plat=r['platform']
       if plat!='win':
          c=ck.cfg.get('linux_sudo','')+' '+c

       ck.out('  '+c)
       ck.out('')
       os.system(c)

    return ck.access({'action':'pull',
                      'module_uoa':'repo',
                      'out':o})",python,"def pull(i):
    """"""
    Input:  {
              (kernel)  - if 'yes', pull kernel too (unless installed as a package)
              (install) - if 'yes', install CK kernel as python module (via python setup.py install)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    import os

    o=i.get('out','')

    kernel=i.get('kernel','')
    install=i.get('install','')

    if kernel=='yes' or install=='yes':
       ck_root=ck.work['env_root']

       if not os.path.isdir(ck_root):
          return {'return':1, 'error':'Can\'t find CK in '+ck_root+' - please check CK_ROOT env'}

       os.chdir(ck_root)

    if kernel=='yes':
       cont=True
       if not os.path.isdir(os.path.join(ck_root,'.git')) and i.get('force','')!='yes':
          ck.out('WARNING: seems like your CK_ROOT installation is not from GitHub - skipping kernel update ...')
          ck.out('')
          cont=False

       if cont:
          if o=='con':
             ck.out('Updating CK from GitHub ...')
             ck.out('')
             ck.out('  cd '+ck_root)
             ck.out('  git pull')
             ck.out('')

          rx=os.system('git pull')
          if rx>0: 
             return {'return':1, 'error':'CK update failed'}

          if o=='con':
             ck.out('')

    if install=='yes':
       c=ck.cfg['install_ck_as_lib']

       py=os.getenv('CK_PYTHON','')
       if py!='':
          c=c.replace('python ',py+' ')

       ck.out('')
       ck.out('Installing CK kernel as python module ...')

       ck.out('')
       ck.out('  cd '+ck_root)

       # Get OS
       r=ck.get_os_ck({})
       if r['return']>0: return r
       plat=r['platform']
       if plat!='win':
          c=ck.cfg.get('linux_sudo','')+' '+c

       ck.out('  '+c)
       ck.out('')
       os.system(c)

    return ck.access({'action':'pull',
                      'module_uoa':'repo',
                      'out':o})","['def' 'pull' '(' 'i' ')' ':' 'import' 'os' 'o' '=' 'i' '.' 'get' '('
 ""'out'"" ',' ""''"" ')' 'kernel' '=' 'i' '.' 'get' '(' ""'kernel'"" ',' ""''""
 ')' 'install' '=' 'i' '.' 'get' '(' ""'install'"" ',' ""''"" ')' 'if'
 'kernel' '==' ""'yes'"" 'or' 'install' '==' ""'yes'"" ':' 'ck_root' '=' 'ck'
 '.' 'work' '[' ""'env_root'"" ']' 'if' 'not' 'os' '.' 'path' '.' 'isdir'
 '(' 'ck_root' ')' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'Can\\'t find CK in '"" '+' 'ck_root' '+' ""' - please check CK_ROOT env'""
 '}' 'os' '.' 'chdir' '(' 'ck_root' ')' 'if' 'kernel' '==' ""'yes'"" ':'
 'cont' '=' 'True' 'if' 'not' 'os' '.' 'path' '.' 'isdir' '(' 'os' '.'
 'path' '.' 'join' '(' 'ck_root' ',' ""'.git'"" ')' ')' 'and' 'i' '.' 'get'
 '(' ""'force'"" ',' ""''"" ')' '!=' ""'yes'"" ':' 'ck' '.' 'out' '('
 ""'WARNING: seems like your CK_ROOT installation is not from GitHub - skipping kernel update ...'""
 ')' 'ck' '.' 'out' '(' ""''"" ')' 'cont' '=' 'False' 'if' 'cont' ':' 'if'
 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '(' ""'Updating CK from GitHub ...'""
 ')' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '(' ""'  cd '"" '+'
 'ck_root' ')' 'ck' '.' 'out' '(' ""'  git pull'"" ')' 'ck' '.' 'out' '('
 ""''"" ')' 'rx' '=' 'os' '.' 'system' '(' ""'git pull'"" ')' 'if' 'rx' '>'
 '0' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'CK update failed'"" '}' 'if' 'o' '==' ""'con'"" ':' 'ck' '.' 'out' '('
 ""''"" ')' 'if' 'install' '==' ""'yes'"" ':' 'c' '=' 'ck' '.' 'cfg' '['
 ""'install_ck_as_lib'"" ']' 'py' '=' 'os' '.' 'getenv' '(' ""'CK_PYTHON'""
 ',' ""''"" ')' 'if' 'py' '!=' ""''"" ':' 'c' '=' 'c' '.' 'replace' '('
 ""'python '"" ',' 'py' '+' ""' '"" ')' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.'
 'out' '(' ""'Installing CK kernel as python module ...'"" ')' 'ck' '.'
 'out' '(' ""''"" ')' 'ck' '.' 'out' '(' ""'  cd '"" '+' 'ck_root' ')'
 '# Get OS' 'r' '=' 'ck' '.' 'get_os_ck' '(' '{' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'plat' '=' 'r' '[' ""'platform'""
 ']' 'if' 'plat' '!=' ""'win'"" ':' 'c' '=' 'ck' '.' 'cfg' '.' 'get' '('
 ""'linux_sudo'"" ',' ""''"" ')' '+' ""' '"" '+' 'c' 'ck' '.' 'out' '(' ""'  '""
 '+' 'c' ')' 'ck' '.' 'out' '(' ""''"" ')' 'os' '.' 'system' '(' 'c' ')'
 'return' 'ck' '.' 'access' '(' '{' ""'action'"" ':' ""'pull'"" ','
 ""'module_uoa'"" ':' ""'repo'"" ',' ""'out'"" ':' 'o' '}' ')']","Input:  {
              (kernel)  - if 'yes', pull kernel too (unless installed as a package)
              (install) - if 'yes', install CK kernel as python module (via python setup.py install)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'kernel' ')' '-' 'if' 'yes' 'pull' 'kernel' 'too' '('
 'unless' 'installed' 'as' 'a' 'package' ')' '(' 'install' ')' '-' 'if'
 'yes' 'install' 'CK' 'kernel' 'as' 'python' 'module' '(' 'via' 'python'
 'setup' '.' 'py' 'install' ')' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/all/module.py#L36-L114
ctuning/ck,ck/kernel.py,out,"def out(s):
    """"""
    Input:  s - unicode string to print

    Output: Nothing
    """"""

    if allow_print: 
       if con_encoding=='':
          x=sys.stdin.encoding
          if x==None: 
             b=s.encode()
          else:
             b=s.encode(x, 'ignore')
       else:
          b=s.encode(con_encoding, 'ignore')

       if sys.version_info[0]>2:
          try: # We encountered issues on ipython with Anaconda
               # and hence made this work around
             sys.stdout.buffer.write(b)
             sys.stdout.buffer.write(b'\n')
          except Exception as e: 
             print(s)
             pass
       else:
          print(b)

    sys.stdout.flush()

    return None",python,"def out(s):
    """"""
    Input:  s - unicode string to print

    Output: Nothing
    """"""

    if allow_print: 
       if con_encoding=='':
          x=sys.stdin.encoding
          if x==None: 
             b=s.encode()
          else:
             b=s.encode(x, 'ignore')
       else:
          b=s.encode(con_encoding, 'ignore')

       if sys.version_info[0]>2:
          try: # We encountered issues on ipython with Anaconda
               # and hence made this work around
             sys.stdout.buffer.write(b)
             sys.stdout.buffer.write(b'\n')
          except Exception as e: 
             print(s)
             pass
       else:
          print(b)

    sys.stdout.flush()

    return None","['def' 'out' '(' 's' ')' ':' 'if' 'allow_print' ':' 'if' 'con_encoding'
 '==' ""''"" ':' 'x' '=' 'sys' '.' 'stdin' '.' 'encoding' 'if' 'x' '=='
 'None' ':' 'b' '=' 's' '.' 'encode' '(' ')' 'else' ':' 'b' '=' 's' '.'
 'encode' '(' 'x' ',' ""'ignore'"" ')' 'else' ':' 'b' '=' 's' '.' 'encode'
 '(' 'con_encoding' ',' ""'ignore'"" ')' 'if' 'sys' '.' 'version_info' '['
 '0' ']' '>' '2' ':' 'try' ':'
 '# We encountered issues on ipython with Anaconda'
 '# and hence made this work around' 'sys' '.' 'stdout' '.' 'buffer' '.'
 'write' '(' 'b' ')' 'sys' '.' 'stdout' '.' 'buffer' '.' 'write' '('
 ""b'\\n'"" ')' 'except' 'Exception' 'as' 'e' ':' 'print' '(' 's' ')' 'pass'
 'else' ':' 'print' '(' 'b' ')' 'sys' '.' 'stdout' '.' 'flush' '(' ')'
 'return' 'None']","Input:  s - unicode string to print

    Output: Nothing",['Input' ':' 's' '-' 'unicode' 'string' 'to' 'print'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L345-L375
ctuning/ck,ck/kernel.py,debug_out,"def debug_out(i):
    """"""
    Input:  i - dictionary

    Output: return = 0
    """"""

    import copy
    import json

    ii={}

    # Check main unprintable keys
    for k in i:
        try:
           s=json.dumps(i[k])
        except Exception as e: 
           pass
        else:
           ii[k]=i[k]

    # Dump
    out(json.dumps(ii, indent=2))

    return {'return':0}",python,"def debug_out(i):
    """"""
    Input:  i - dictionary

    Output: return = 0
    """"""

    import copy
    import json

    ii={}

    # Check main unprintable keys
    for k in i:
        try:
           s=json.dumps(i[k])
        except Exception as e: 
           pass
        else:
           ii[k]=i[k]

    # Dump
    out(json.dumps(ii, indent=2))

    return {'return':0}","['def' 'debug_out' '(' 'i' ')' ':' 'import' 'copy' 'import' 'json' 'ii'
 '=' '{' '}' '# Check main unprintable keys' 'for' 'k' 'in' 'i' ':' 'try'
 ':' 's' '=' 'json' '.' 'dumps' '(' 'i' '[' 'k' ']' ')' 'except'
 'Exception' 'as' 'e' ':' 'pass' 'else' ':' 'ii' '[' 'k' ']' '=' 'i' '['
 'k' ']' '# Dump' 'out' '(' 'json' '.' 'dumps' '(' 'ii' ',' 'indent' '='
 '2' ')' ')' 'return' '{' ""'return'"" ':' '0' '}']","Input:  i - dictionary

    Output: return = 0",['Input' ':' 'i' '-' 'dictionary'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L382-L406
ctuning/ck,ck/kernel.py,eout,"def eout(s):
    """"""
    Input:  s - unicode string to print

    Output: Nothing
    """"""

    if allow_print: 
       if con_encoding=='':
          x=sys.stdin.encoding
          if x==None: 
             b=s.encode()
          else:
             b=s.encode(x, 'ignore')
       else:
          b=s.encode(con_encoding, 'ignore')

       if sys.version_info[0]>2:
          try: # We encountered issues on ipython with Anaconda
               # and hence made this work around
             sys.stderr.buffer.write(b)
             sys.stderr.buffer.write(b'\n')
          except Exception as e: 
             sys.stderr.write(s)
             pass
       else:
          sys.stderr.write(b)

    sys.stderr.flush()

    return None",python,"def eout(s):
    """"""
    Input:  s - unicode string to print

    Output: Nothing
    """"""

    if allow_print: 
       if con_encoding=='':
          x=sys.stdin.encoding
          if x==None: 
             b=s.encode()
          else:
             b=s.encode(x, 'ignore')
       else:
          b=s.encode(con_encoding, 'ignore')

       if sys.version_info[0]>2:
          try: # We encountered issues on ipython with Anaconda
               # and hence made this work around
             sys.stderr.buffer.write(b)
             sys.stderr.buffer.write(b'\n')
          except Exception as e: 
             sys.stderr.write(s)
             pass
       else:
          sys.stderr.write(b)

    sys.stderr.flush()

    return None","['def' 'eout' '(' 's' ')' ':' 'if' 'allow_print' ':' 'if' 'con_encoding'
 '==' ""''"" ':' 'x' '=' 'sys' '.' 'stdin' '.' 'encoding' 'if' 'x' '=='
 'None' ':' 'b' '=' 's' '.' 'encode' '(' ')' 'else' ':' 'b' '=' 's' '.'
 'encode' '(' 'x' ',' ""'ignore'"" ')' 'else' ':' 'b' '=' 's' '.' 'encode'
 '(' 'con_encoding' ',' ""'ignore'"" ')' 'if' 'sys' '.' 'version_info' '['
 '0' ']' '>' '2' ':' 'try' ':'
 '# We encountered issues on ipython with Anaconda'
 '# and hence made this work around' 'sys' '.' 'stderr' '.' 'buffer' '.'
 'write' '(' 'b' ')' 'sys' '.' 'stderr' '.' 'buffer' '.' 'write' '('
 ""b'\\n'"" ')' 'except' 'Exception' 'as' 'e' ':' 'sys' '.' 'stderr' '.'
 'write' '(' 's' ')' 'pass' 'else' ':' 'sys' '.' 'stderr' '.' 'write' '('
 'b' ')' 'sys' '.' 'stderr' '.' 'flush' '(' ')' 'return' 'None']","Input:  s - unicode string to print

    Output: Nothing",['Input' ':' 's' '-' 'unicode' 'string' 'to' 'print'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L413-L443
ctuning/ck,ck/kernel.py,err,"def err(r):
    """"""
    Input:  {
              return - return code
              error - error text
            }

    Output: Nothing; quits program
    """"""

    import sys

    rc=r['return']
    re=r['error']

    out('Error: '+re)
    sys.exit(rc)",python,"def err(r):
    """"""
    Input:  {
              return - return code
              error - error text
            }

    Output: Nothing; quits program
    """"""

    import sys

    rc=r['return']
    re=r['error']

    out('Error: '+re)
    sys.exit(rc)","['def' 'err' '(' 'r' ')' ':' 'import' 'sys' 'rc' '=' 'r' '[' ""'return'""
 ']' 're' '=' 'r' '[' ""'error'"" ']' 'out' '(' ""'Error: '"" '+' 're' ')'
 'sys' '.' 'exit' '(' 'rc' ')']","Input:  {
              return - return code
              error - error text
            }

    Output: Nothing; quits program","['Input' ':' '{' 'return' '-' 'return' 'code' 'error' '-' 'error' 'text'
 '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L450-L466
ctuning/ck,ck/kernel.py,system_with_timeout,"def system_with_timeout(i):

    """"""
    Input:  {
              cmd       - command line
              (timeout) - timeout in seconds (granularity 0.01 sec) - may cause overheads ...
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
                                         =  8, if timeout
              (error)      - error text if return > 0

              return_code  - return code from app
            }
    """"""

    import subprocess
    import time

    cmd=i['cmd']

    rc=0

    to=i.get('timeout','')

    p=subprocess.Popen(cmd, shell=True)

    if to != '':
       xto=float(to)

       t0=time.time()
       t=0
       tx=float(i['timeout'])

       while p.poll() == None and t<xto:
          time.sleep(0.1)
          t=time.time()-t0

       if t>=xto and p.poll()==None:
          system_with_timeout_kill(p)
          return {'return':8, 'error':'process timed out and had been terminated'}
    else:
       p.wait()

    rc=p.returncode
    return {'return':0, 'return_code':rc}",python,"def system_with_timeout(i):

    """"""
    Input:  {
              cmd       - command line
              (timeout) - timeout in seconds (granularity 0.01 sec) - may cause overheads ...
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
                                         =  8, if timeout
              (error)      - error text if return > 0

              return_code  - return code from app
            }
    """"""

    import subprocess
    import time

    cmd=i['cmd']

    rc=0

    to=i.get('timeout','')

    p=subprocess.Popen(cmd, shell=True)

    if to != '':
       xto=float(to)

       t0=time.time()
       t=0
       tx=float(i['timeout'])

       while p.poll() == None and t<xto:
          time.sleep(0.1)
          t=time.time()-t0

       if t>=xto and p.poll()==None:
          system_with_timeout_kill(p)
          return {'return':8, 'error':'process timed out and had been terminated'}
    else:
       p.wait()

    rc=p.returncode
    return {'return':0, 'return_code':rc}","['def' 'system_with_timeout' '(' 'i' ')' ':' 'import' 'subprocess'
 'import' 'time' 'cmd' '=' 'i' '[' ""'cmd'"" ']' 'rc' '=' '0' 'to' '=' 'i'
 '.' 'get' '(' ""'timeout'"" ',' ""''"" ')' 'p' '=' 'subprocess' '.' 'Popen'
 '(' 'cmd' ',' 'shell' '=' 'True' ')' 'if' 'to' '!=' ""''"" ':' 'xto' '='
 'float' '(' 'to' ')' 't0' '=' 'time' '.' 'time' '(' ')' 't' '=' '0' 'tx'
 '=' 'float' '(' 'i' '[' ""'timeout'"" ']' ')' 'while' 'p' '.' 'poll' '('
 ')' '==' 'None' 'and' 't' '<' 'xto' ':' 'time' '.' 'sleep' '(' '0.1' ')'
 't' '=' 'time' '.' 'time' '(' ')' '-' 't0' 'if' 't' '>=' 'xto' 'and' 'p'
 '.' 'poll' '(' ')' '==' 'None' ':' 'system_with_timeout_kill' '(' 'p' ')'
 'return' '{' ""'return'"" ':' '8' ',' ""'error'"" ':'
 ""'process timed out and had been terminated'"" '}' 'else' ':' 'p' '.'
 'wait' '(' ')' 'rc' '=' 'p' '.' 'returncode' 'return' '{' ""'return'"" ':'
 '0' ',' ""'return_code'"" ':' 'rc' '}']","Input:  {
              cmd       - command line
              (timeout) - timeout in seconds (granularity 0.01 sec) - may cause overheads ...
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
                                         =  8, if timeout
              (error)      - error text if return > 0

              return_code  - return code from app
            }","['Input' ':' '{' 'cmd' '-' 'command' 'line' '(' 'timeout' ')' '-'
 'timeout' 'in' 'seconds' '(' 'granularity' '0' '.' '01' 'sec' ')' '-'
 'may' 'cause' 'overheads' '...' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L575-L622
ctuning/ck,ck/kernel.py,run_and_get_stdout,"def run_and_get_stdout(i):
  """"""
  Input:  {
            cmd       - list of command line arguments, starting with the command itself
            (shell)   - if 'yes', reuse shell environment
          }

  Output: {
            return       - return code =  0, if successful
                                       >  0, if error
                                       =  8, if timeout
            (error)      - error text if return > 0

            return_code  - return code from app

            stdout       - string, standard output of the command
          }
  """"""

  import subprocess
  import shlex
  import platform

  cmd=i['cmd']
  if type(cmd)!=list:
      # Split only on non-Windows platforms (since Windows takes a string in Popen)
      if not platform.system().lower().startswith('win'):
          cmd=shlex.split(cmd)

  xshell=False
  if i.get('shell','')=='yes':
      xshell=True

  p1 = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=xshell)
  output, error = p1.communicate()

  if sys.version_info[0]>2:
      output = output.decode(encoding='UTF-8')
      error = error.decode(encoding='UTF-8')

  return {'return':0, 'return_code':p1.returncode, 'stdout':output, 'stderr':error}",python,"def run_and_get_stdout(i):
  """"""
  Input:  {
            cmd       - list of command line arguments, starting with the command itself
            (shell)   - if 'yes', reuse shell environment
          }

  Output: {
            return       - return code =  0, if successful
                                       >  0, if error
                                       =  8, if timeout
            (error)      - error text if return > 0

            return_code  - return code from app

            stdout       - string, standard output of the command
          }
  """"""

  import subprocess
  import shlex
  import platform

  cmd=i['cmd']
  if type(cmd)!=list:
      # Split only on non-Windows platforms (since Windows takes a string in Popen)
      if not platform.system().lower().startswith('win'):
          cmd=shlex.split(cmd)

  xshell=False
  if i.get('shell','')=='yes':
      xshell=True

  p1 = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=xshell)
  output, error = p1.communicate()

  if sys.version_info[0]>2:
      output = output.decode(encoding='UTF-8')
      error = error.decode(encoding='UTF-8')

  return {'return':0, 'return_code':p1.returncode, 'stdout':output, 'stderr':error}","['def' 'run_and_get_stdout' '(' 'i' ')' ':' 'import' 'subprocess' 'import'
 'shlex' 'import' 'platform' 'cmd' '=' 'i' '[' ""'cmd'"" ']' 'if' 'type' '('
 'cmd' ')' '!=' 'list' ':'
 '# Split only on non-Windows platforms (since Windows takes a string in Popen)'
 'if' 'not' 'platform' '.' 'system' '(' ')' '.' 'lower' '(' ')' '.'
 'startswith' '(' ""'win'"" ')' ':' 'cmd' '=' 'shlex' '.' 'split' '(' 'cmd'
 ')' 'xshell' '=' 'False' 'if' 'i' '.' 'get' '(' ""'shell'"" ',' ""''"" ')'
 '==' ""'yes'"" ':' 'xshell' '=' 'True' 'p1' '=' 'subprocess' '.' 'Popen'
 '(' 'cmd' ',' 'stdout' '=' 'subprocess' '.' 'PIPE' ',' 'stderr' '='
 'subprocess' '.' 'PIPE' ',' 'shell' '=' 'xshell' ')' 'output' ',' 'error'
 '=' 'p1' '.' 'communicate' '(' ')' 'if' 'sys' '.' 'version_info' '[' '0'
 ']' '>' '2' ':' 'output' '=' 'output' '.' 'decode' '(' 'encoding' '='
 ""'UTF-8'"" ')' 'error' '=' 'error' '.' 'decode' '(' 'encoding' '='
 ""'UTF-8'"" ')' 'return' '{' ""'return'"" ':' '0' ',' ""'return_code'"" ':'
 'p1' '.' 'returncode' ',' ""'stdout'"" ':' 'output' ',' ""'stderr'"" ':'
 'error' '}']","Input:  {
            cmd       - list of command line arguments, starting with the command itself
            (shell)   - if 'yes', reuse shell environment
          }

  Output: {
            return       - return code =  0, if successful
                                       >  0, if error
                                       =  8, if timeout
            (error)      - error text if return > 0

            return_code  - return code from app

            stdout       - string, standard output of the command
          }","['Input' ':' '{' 'cmd' '-' 'list' 'of' 'command' 'line' 'arguments'
 'starting' 'with' 'the' 'command' 'itself' '(' 'shell' ')' '-' 'if' 'yes'
 'reuse' 'shell' 'environment' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L629-L669
ctuning/ck,ck/kernel.py,get_from_dicts,"def get_from_dicts(dict1, key, default_value, dict2, extra=''):
    """"""
    Input:  dict1         - first check in this dict (and remove if there)
            key           - key in dict1
            default_value - default value if not found
            dict2         - then check from here

    Output: value
    """"""

    value=default_value

    if key not in dict1:
       if dict2!=None:
          value=dict2.get(extra+key, default_value)
    else:
       value=dict1[key]
       del(dict1[key])

       if dict2!=None:
          dict2[extra+key]=value

    return value",python,"def get_from_dicts(dict1, key, default_value, dict2, extra=''):
    """"""
    Input:  dict1         - first check in this dict (and remove if there)
            key           - key in dict1
            default_value - default value if not found
            dict2         - then check from here

    Output: value
    """"""

    value=default_value

    if key not in dict1:
       if dict2!=None:
          value=dict2.get(extra+key, default_value)
    else:
       value=dict1[key]
       del(dict1[key])

       if dict2!=None:
          dict2[extra+key]=value

    return value","['def' 'get_from_dicts' '(' 'dict1' ',' 'key' ',' 'default_value' ','
 'dict2' ',' 'extra' '=' ""''"" ')' ':' 'value' '=' 'default_value' 'if'
 'key' 'not' 'in' 'dict1' ':' 'if' 'dict2' '!=' 'None' ':' 'value' '='
 'dict2' '.' 'get' '(' 'extra' '+' 'key' ',' 'default_value' ')' 'else'
 ':' 'value' '=' 'dict1' '[' 'key' ']' 'del' '(' 'dict1' '[' 'key' ']' ')'
 'if' 'dict2' '!=' 'None' ':' 'dict2' '[' 'extra' '+' 'key' ']' '='
 'value' 'return' 'value']","Input:  dict1         - first check in this dict (and remove if there)
            key           - key in dict1
            default_value - default value if not found
            dict2         - then check from here

    Output: value","['Input' ':' 'dict1' '-' 'first' 'check' 'in' 'this' 'dict' '(' 'and'
 'remove' 'if' 'there' ')' 'key' '-' 'key' 'in' 'dict1' 'default_value'
 '-' 'default' 'value' 'if' 'not' 'found' 'dict2' '-' 'then' 'check'
 'from' 'here']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L676-L698
ctuning/ck,ck/kernel.py,convert_iso_time,"def convert_iso_time(i):
    """"""
    Input:  {
              iso_datetime - iso date time
            }

    Output: { 
              return         - return code =  0, if successful
                                           >  0, if error
              (error)        - error text if return > 0
              (datetime_obj) - datetime object
            }
    """"""

    t=i['iso_datetime']

    import datetime
    import time

    dto=None

    ok=True

    try: dto=datetime.datetime.strptime(t, ""%Y-%m-%dT%H:%M:%S.%f"")
    except Exception as e: 
       ok=False
       pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m-%dT%H:%M:%S"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m-%dT%H:%M"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m-%dT%H"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m-%d"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y"")
       except Exception as e: 
          return {'return':1, 'error':'can\'t parse ISO date time: '+t}

    return {'return':0, 'datetime_obj':dto}",python,"def convert_iso_time(i):
    """"""
    Input:  {
              iso_datetime - iso date time
            }

    Output: { 
              return         - return code =  0, if successful
                                           >  0, if error
              (error)        - error text if return > 0
              (datetime_obj) - datetime object
            }
    """"""

    t=i['iso_datetime']

    import datetime
    import time

    dto=None

    ok=True

    try: dto=datetime.datetime.strptime(t, ""%Y-%m-%dT%H:%M:%S.%f"")
    except Exception as e: 
       ok=False
       pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m-%dT%H:%M:%S"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m-%dT%H:%M"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m-%dT%H"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m-%d"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y-%m"")
       except Exception as e: 
          ok=False
          pass

    if not ok:
       ok=True
       try: dto=datetime.datetime.strptime(t, ""%Y"")
       except Exception as e: 
          return {'return':1, 'error':'can\'t parse ISO date time: '+t}

    return {'return':0, 'datetime_obj':dto}","['def' 'convert_iso_time' '(' 'i' ')' ':' 't' '=' 'i' '[' ""'iso_datetime'""
 ']' 'import' 'datetime' 'import' 'time' 'dto' '=' 'None' 'ok' '=' 'True'
 'try' ':' 'dto' '=' 'datetime' '.' 'datetime' '.' 'strptime' '(' 't' ','
 '""%Y-%m-%dT%H:%M:%S.%f""' ')' 'except' 'Exception' 'as' 'e' ':' 'ok' '='
 'False' 'pass' 'if' 'not' 'ok' ':' 'ok' '=' 'True' 'try' ':' 'dto' '='
 'datetime' '.' 'datetime' '.' 'strptime' '(' 't' ','
 '""%Y-%m-%dT%H:%M:%S""' ')' 'except' 'Exception' 'as' 'e' ':' 'ok' '='
 'False' 'pass' 'if' 'not' 'ok' ':' 'ok' '=' 'True' 'try' ':' 'dto' '='
 'datetime' '.' 'datetime' '.' 'strptime' '(' 't' ',' '""%Y-%m-%dT%H:%M""'
 ')' 'except' 'Exception' 'as' 'e' ':' 'ok' '=' 'False' 'pass' 'if' 'not'
 'ok' ':' 'ok' '=' 'True' 'try' ':' 'dto' '=' 'datetime' '.' 'datetime'
 '.' 'strptime' '(' 't' ',' '""%Y-%m-%dT%H""' ')' 'except' 'Exception' 'as'
 'e' ':' 'ok' '=' 'False' 'pass' 'if' 'not' 'ok' ':' 'ok' '=' 'True' 'try'
 ':' 'dto' '=' 'datetime' '.' 'datetime' '.' 'strptime' '(' 't' ','
 '""%Y-%m-%d""' ')' 'except' 'Exception' 'as' 'e' ':' 'ok' '=' 'False'
 'pass' 'if' 'not' 'ok' ':' 'ok' '=' 'True' 'try' ':' 'dto' '=' 'datetime'
 '.' 'datetime' '.' 'strptime' '(' 't' ',' '""%Y-%m""' ')' 'except'
 'Exception' 'as' 'e' ':' 'ok' '=' 'False' 'pass' 'if' 'not' 'ok' ':' 'ok'
 '=' 'True' 'try' ':' 'dto' '=' 'datetime' '.' 'datetime' '.' 'strptime'
 '(' 't' ',' '""%Y""' ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':' ""'can\\'t parse ISO date time: '""
 '+' 't' '}' 'return' '{' ""'return'"" ':' '0' ',' ""'datetime_obj'"" ':'
 'dto' '}']","Input:  {
              iso_datetime - iso date time
            }

    Output: { 
              return         - return code =  0, if successful
                                           >  0, if error
              (error)        - error text if return > 0
              (datetime_obj) - datetime object
            }",['Input' ':' '{' 'iso_datetime' '-' 'iso' 'date' 'time' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L705-L774
ctuning/ck,ck/kernel.py,inp,"def inp(i):
    """"""
    Input:  {
              text - text to print
            }

    Output: {
              return       - return code =  0

              string       - input string
            }
    """"""

    t=i['text']

    if con_encoding=='':
       x=sys.stdin.encoding
       if x==None: 
          b=t.encode()
       else:
          b=t.encode(x, 'ignore')
    else:
       b=t.encode(con_encoding, 'ignore') # pragma: no cover 

    if sys.version_info[0]>2:
       try: b=b.decode(sys.stdin.encoding)
       except Exception as e: 
         try: b=b.decode('utf8')
         except Exception as e: pass

    if sys.version_info[0]>2:
       s=input(b)
    else:
       x=sys.stdin.encoding
       if x==None:
          x='utf8'
       s=raw_input(b).decode(x).encode('utf8')

    return {'return':0, 'string':s}",python,"def inp(i):
    """"""
    Input:  {
              text - text to print
            }

    Output: {
              return       - return code =  0

              string       - input string
            }
    """"""

    t=i['text']

    if con_encoding=='':
       x=sys.stdin.encoding
       if x==None: 
          b=t.encode()
       else:
          b=t.encode(x, 'ignore')
    else:
       b=t.encode(con_encoding, 'ignore') # pragma: no cover 

    if sys.version_info[0]>2:
       try: b=b.decode(sys.stdin.encoding)
       except Exception as e: 
         try: b=b.decode('utf8')
         except Exception as e: pass

    if sys.version_info[0]>2:
       s=input(b)
    else:
       x=sys.stdin.encoding
       if x==None:
          x='utf8'
       s=raw_input(b).decode(x).encode('utf8')

    return {'return':0, 'string':s}","['def' 'inp' '(' 'i' ')' ':' 't' '=' 'i' '[' ""'text'"" ']' 'if'
 'con_encoding' '==' ""''"" ':' 'x' '=' 'sys' '.' 'stdin' '.' 'encoding'
 'if' 'x' '==' 'None' ':' 'b' '=' 't' '.' 'encode' '(' ')' 'else' ':' 'b'
 '=' 't' '.' 'encode' '(' 'x' ',' ""'ignore'"" ')' 'else' ':' 'b' '=' 't'
 '.' 'encode' '(' 'con_encoding' ',' ""'ignore'"" ')' '# pragma: no cover '
 'if' 'sys' '.' 'version_info' '[' '0' ']' '>' '2' ':' 'try' ':' 'b' '='
 'b' '.' 'decode' '(' 'sys' '.' 'stdin' '.' 'encoding' ')' 'except'
 'Exception' 'as' 'e' ':' 'try' ':' 'b' '=' 'b' '.' 'decode' '(' ""'utf8'""
 ')' 'except' 'Exception' 'as' 'e' ':' 'pass' 'if' 'sys' '.'
 'version_info' '[' '0' ']' '>' '2' ':' 's' '=' 'input' '(' 'b' ')' 'else'
 ':' 'x' '=' 'sys' '.' 'stdin' '.' 'encoding' 'if' 'x' '==' 'None' ':' 'x'
 '=' ""'utf8'"" 's' '=' 'raw_input' '(' 'b' ')' '.' 'decode' '(' 'x' ')' '.'
 'encode' '(' ""'utf8'"" ')' 'return' '{' ""'return'"" ':' '0' ',' ""'string'""
 ':' 's' '}']","Input:  {
              text - text to print
            }

    Output: {
              return       - return code =  0

              string       - input string
            }",['Input' ':' '{' 'text' '-' 'text' 'to' 'print' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L792-L830
ctuning/ck,ck/kernel.py,select,"def select(i):
    """"""
    Input:  {
              dict             - dict with values being dicts with 'name' as string to display and 'sort' as int (for ordering)
              (title)          - print title
              (error_if_empty) - if 'yes' and Enter, make error
              (skip_sort)      - if 'yes', do not sort array
            }

    Output: {
              return       - return code =  0

              string       - selected dictionary key
            }
    """"""

    s=''

    title=i.get('title','')
    if title!='':
       out(title)
       out('')

    d=i['dict']
    if i.get('skip_sort','')!='yes':
       kd=sorted(d, key=lambda v: d[v].get('sort',0))
    else:
       kd=d

    j=0
    ks={}
    for k in kd:
        q=d[k]

        sj=str(j)
        ks[sj]=k

        qn=q.get('name','')

        out(sj+') '+qn)

        j+=1

    out('')
    rx=inp({'text':'Make your selection (or press Enter for 0): '})
    if rx['return']>0: return rx
    sx=rx['string'].strip()

    if sx=='':
       if i.get('error_if_empty','')=='yes':
          return {'return':1, 'error':'selection is empty'}

       s=kd[0]
    else:
       if sx not in ks:
          return {'return':1, 'error':'selection is not recognized'}
       s=ks[sx]

    return {'return':0, 'string':s}",python,"def select(i):
    """"""
    Input:  {
              dict             - dict with values being dicts with 'name' as string to display and 'sort' as int (for ordering)
              (title)          - print title
              (error_if_empty) - if 'yes' and Enter, make error
              (skip_sort)      - if 'yes', do not sort array
            }

    Output: {
              return       - return code =  0

              string       - selected dictionary key
            }
    """"""

    s=''

    title=i.get('title','')
    if title!='':
       out(title)
       out('')

    d=i['dict']
    if i.get('skip_sort','')!='yes':
       kd=sorted(d, key=lambda v: d[v].get('sort',0))
    else:
       kd=d

    j=0
    ks={}
    for k in kd:
        q=d[k]

        sj=str(j)
        ks[sj]=k

        qn=q.get('name','')

        out(sj+') '+qn)

        j+=1

    out('')
    rx=inp({'text':'Make your selection (or press Enter for 0): '})
    if rx['return']>0: return rx
    sx=rx['string'].strip()

    if sx=='':
       if i.get('error_if_empty','')=='yes':
          return {'return':1, 'error':'selection is empty'}

       s=kd[0]
    else:
       if sx not in ks:
          return {'return':1, 'error':'selection is not recognized'}
       s=ks[sx]

    return {'return':0, 'string':s}","['def' 'select' '(' 'i' ')' ':' 's' '=' ""''"" 'title' '=' 'i' '.' 'get' '('
 ""'title'"" ',' ""''"" ')' 'if' 'title' '!=' ""''"" ':' 'out' '(' 'title' ')'
 'out' '(' ""''"" ')' 'd' '=' 'i' '[' ""'dict'"" ']' 'if' 'i' '.' 'get' '('
 ""'skip_sort'"" ',' ""''"" ')' '!=' ""'yes'"" ':' 'kd' '=' 'sorted' '(' 'd' ','
 'key' '=' 'lambda' 'v' ':' 'd' '[' 'v' ']' '.' 'get' '(' ""'sort'"" ',' '0'
 ')' ')' 'else' ':' 'kd' '=' 'd' 'j' '=' '0' 'ks' '=' '{' '}' 'for' 'k'
 'in' 'kd' ':' 'q' '=' 'd' '[' 'k' ']' 'sj' '=' 'str' '(' 'j' ')' 'ks' '['
 'sj' ']' '=' 'k' 'qn' '=' 'q' '.' 'get' '(' ""'name'"" ',' ""''"" ')' 'out'
 '(' 'sj' '+' ""') '"" '+' 'qn' ')' 'j' '+=' '1' 'out' '(' ""''"" ')' 'rx' '='
 'inp' '(' '{' ""'text'"" ':'
 ""'Make your selection (or press Enter for 0): '"" '}' ')' 'if' 'rx' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'sx' '=' 'rx' '[' ""'string'"" ']'
 '.' 'strip' '(' ')' 'if' 'sx' '==' ""''"" ':' 'if' 'i' '.' 'get' '('
 ""'error_if_empty'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'selection is empty'"" '}' 's' '=' 'kd' '[' '0'
 ']' 'else' ':' 'if' 'sx' 'not' 'in' 'ks' ':' 'return' '{' ""'return'"" ':'
 '1' ',' ""'error'"" ':' ""'selection is not recognized'"" '}' 's' '=' 'ks'
 '[' 'sx' ']' 'return' '{' ""'return'"" ':' '0' ',' ""'string'"" ':' 's' '}']","Input:  {
              dict             - dict with values being dicts with 'name' as string to display and 'sort' as int (for ordering)
              (title)          - print title
              (error_if_empty) - if 'yes' and Enter, make error
              (skip_sort)      - if 'yes', do not sort array
            }

    Output: {
              return       - return code =  0

              string       - selected dictionary key
            }","['Input' ':' '{' 'dict' '-' 'dict' 'with' 'values' 'being' 'dicts' 'with'
 'name' 'as' 'string' 'to' 'display' 'and' 'sort' 'as' 'int' '(' 'for'
 'ordering' ')' '(' 'title' ')' '-' 'print' 'title' '(' 'error_if_empty'
 ')' '-' 'if' 'yes' 'and' 'Enter' 'make' 'error' '(' 'skip_sort' ')' '-'
 'if' 'yes' 'do' 'not' 'sort' 'array' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L837-L895
ctuning/ck,ck/kernel.py,select_uoa,"def select_uoa(i):
    """"""
    Input:  {
              choices      - list from search function
              (skip_enter) - if 'yes', do not select 0 when user presses Enter
              (skip_sort)  - if 'yes', do not sort array
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              choice  - data UOA
            }

    """"""

    se=i.get('skip_enter','')

    lst=i.get('choices',[])

    if i.get('skip_sort','')!='yes':
       klst=sorted(lst, key=lambda v: v['data_uoa'])
    else:
       klst=lst

    zz={}
    iz=0

    for z1 in klst:
        z=z1['data_uid']
        zu=z1['data_uoa']

        zs=str(iz)
        zz[zs]=z

        out(zs+') '+zu+' ('+z+')')

        iz+=1

    out('')
    y='Select UOA'
    if se!='yes': y+=' (or press Enter for 0)'
    y+=': '

    rx=inp({'text':y})
    x=rx['string'].strip()
    if x=='' and se!='yes': x='0' 

    if x not in zz:
       return {'return':1, 'error':'number is not recognized'}

    dduoa=zz[x]

    return {'return':0, 'choice':dduoa}",python,"def select_uoa(i):
    """"""
    Input:  {
              choices      - list from search function
              (skip_enter) - if 'yes', do not select 0 when user presses Enter
              (skip_sort)  - if 'yes', do not sort array
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              choice  - data UOA
            }

    """"""

    se=i.get('skip_enter','')

    lst=i.get('choices',[])

    if i.get('skip_sort','')!='yes':
       klst=sorted(lst, key=lambda v: v['data_uoa'])
    else:
       klst=lst

    zz={}
    iz=0

    for z1 in klst:
        z=z1['data_uid']
        zu=z1['data_uoa']

        zs=str(iz)
        zz[zs]=z

        out(zs+') '+zu+' ('+z+')')

        iz+=1

    out('')
    y='Select UOA'
    if se!='yes': y+=' (or press Enter for 0)'
    y+=': '

    rx=inp({'text':y})
    x=rx['string'].strip()
    if x=='' and se!='yes': x='0' 

    if x not in zz:
       return {'return':1, 'error':'number is not recognized'}

    dduoa=zz[x]

    return {'return':0, 'choice':dduoa}","['def' 'select_uoa' '(' 'i' ')' ':' 'se' '=' 'i' '.' 'get' '('
 ""'skip_enter'"" ',' ""''"" ')' 'lst' '=' 'i' '.' 'get' '(' ""'choices'"" ','
 '[' ']' ')' 'if' 'i' '.' 'get' '(' ""'skip_sort'"" ',' ""''"" ')' '!='
 ""'yes'"" ':' 'klst' '=' 'sorted' '(' 'lst' ',' 'key' '=' 'lambda' 'v' ':'
 'v' '[' ""'data_uoa'"" ']' ')' 'else' ':' 'klst' '=' 'lst' 'zz' '=' '{' '}'
 'iz' '=' '0' 'for' 'z1' 'in' 'klst' ':' 'z' '=' 'z1' '[' ""'data_uid'"" ']'
 'zu' '=' 'z1' '[' ""'data_uoa'"" ']' 'zs' '=' 'str' '(' 'iz' ')' 'zz' '['
 'zs' ']' '=' 'z' 'out' '(' 'zs' '+' ""') '"" '+' 'zu' '+' ""' ('"" '+' 'z'
 '+' ""')'"" ')' 'iz' '+=' '1' 'out' '(' ""''"" ')' 'y' '=' ""'Select UOA'""
 'if' 'se' '!=' ""'yes'"" ':' 'y' '+=' ""' (or press Enter for 0)'"" 'y' '+='
 ""': '"" 'rx' '=' 'inp' '(' '{' ""'text'"" ':' 'y' '}' ')' 'x' '=' 'rx' '['
 ""'string'"" ']' '.' 'strip' '(' ')' 'if' 'x' '==' ""''"" 'and' 'se' '!='
 ""'yes'"" ':' 'x' '=' ""'0'"" 'if' 'x' 'not' 'in' 'zz' ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':' ""'number is not recognized'"" '}'
 'dduoa' '=' 'zz' '[' 'x' ']' 'return' '{' ""'return'"" ':' '0' ','
 ""'choice'"" ':' 'dduoa' '}']","Input:  {
              choices      - list from search function
              (skip_enter) - if 'yes', do not select 0 when user presses Enter
              (skip_sort)  - if 'yes', do not sort array
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              choice  - data UOA
            }","['Input' ':' '{' 'choices' '-' 'list' 'from' 'search' 'function' '('
 'skip_enter' ')' '-' 'if' 'yes' 'do' 'not' 'select' '0' 'when' 'user'
 'presses' 'Enter' '(' 'skip_sort' ')' '-' 'if' 'yes' 'do' 'not' 'sort'
 'array' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L902-L956
ctuning/ck,ck/kernel.py,convert_str_tags_to_list,"def convert_str_tags_to_list(i):
    """"""
    Input:  either a list, or a string of comma-separated tags.

    Output: If i is a list, it's returned.
            If i is a string, the list of tags it represents is returned 
            (each tag is stripped of leading and trailing whitespace).

    """"""

    r=[]

    if type(i)==list:
       r=i
    else:
       ii=i.split(',')
       for q in ii:
           q=q.strip()
           if q!='':
              r.append(q)

    return r",python,"def convert_str_tags_to_list(i):
    """"""
    Input:  either a list, or a string of comma-separated tags.

    Output: If i is a list, it's returned.
            If i is a string, the list of tags it represents is returned 
            (each tag is stripped of leading and trailing whitespace).

    """"""

    r=[]

    if type(i)==list:
       r=i
    else:
       ii=i.split(',')
       for q in ii:
           q=q.strip()
           if q!='':
              r.append(q)

    return r","['def' 'convert_str_tags_to_list' '(' 'i' ')' ':' 'r' '=' '[' ']' 'if'
 'type' '(' 'i' ')' '==' 'list' ':' 'r' '=' 'i' 'else' ':' 'ii' '=' 'i'
 '.' 'split' '(' ""','"" ')' 'for' 'q' 'in' 'ii' ':' 'q' '=' 'q' '.' 'strip'
 '(' ')' 'if' 'q' '!=' ""''"" ':' 'r' '.' 'append' '(' 'q' ')' 'return' 'r']","Input:  either a list, or a string of comma-separated tags.

    Output: If i is a list, it's returned.
            If i is a string, the list of tags it represents is returned 
            (each tag is stripped of leading and trailing whitespace).","['Input' ':' 'either' 'a' 'list' 'or' 'a' 'string' 'of' 'comma' '-'
 'separated' 'tags' '.']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L963-L984
ctuning/ck,ck/kernel.py,check_writing,"def check_writing(i):
    """"""
    Input:  {
              (module_uoa)
              (module_uid)

              (repo_uoa)
              (repo_uid)
              (repo_dict)

              (delete)     - if 'yes', check if global delete operation is allowed
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
              (repo_dict)  - repo cfg if available
            }

    """"""

    dl=i.get('delete','')

    if dl=='yes' and cfg.get('forbid_global_delete','')=='yes':
       return {'return':1, 'error':'delete/rename operations are forbidden'}

    if cfg.get('forbid_global_writing','')=='yes':
       return {'return':1, 'error':'global writing is forbidden'}

    if len(i)==0: 
       return {'return':0} # Check only global writing

    if cfg.get('forbid_writing_modules','')=='yes':
       muoa=i.get('module_uoa','')
       muid=i.get('module_uid','')
       if muoa==cfg['module_name'] or (muid!='' and muid in cfg['module_uids']):
          return {'return':1, 'error':'writing/changing modules is forbidden'}

    ruoa=i.get('repo_uoa','')
    ruid=i.get('repo_uid','')

    if cfg.get('forbid_writing_to_default_repo','')=='yes':
       if ruoa==cfg['repo_name_default'] or ruid==cfg['repo_uid_default']:
          return {'return':1, 'error':'writing to default repo is forbidden'}

    if cfg.get('forbid_writing_to_local_repo','')=='yes':
       if ruoa==cfg['repo_name_local'] or ruid==cfg['repo_uid_local']:
          return {'return':1, 'error':'writing to local repo is forbidden'}

    rr={'return':0}

    # Load info about repo
    rd={}
    if ruoa!='':
       if 'repo_dict' in i:
          rd=i['repo_dict']
       else:
          rx=load_repo_info_from_cache({'repo_uoa':ruoa})
          if rx['return']>0: return rx
          rd=rx.get('dict',{})
       rr['repo_dict']=rd

    if cfg.get('allow_writing_only_to_allowed','')=='yes':
       if rd.get('allow_writing','')!='yes':
          return {'return':1, 'error':'writing to this repo is forbidden'}

    if rd.get('forbid_deleting','')=='yes' and dl=='yes':
       return {'return':1, 'error':'deleting in this repo is forbidden'}

    return rr",python,"def check_writing(i):
    """"""
    Input:  {
              (module_uoa)
              (module_uid)

              (repo_uoa)
              (repo_uid)
              (repo_dict)

              (delete)     - if 'yes', check if global delete operation is allowed
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
              (repo_dict)  - repo cfg if available
            }

    """"""

    dl=i.get('delete','')

    if dl=='yes' and cfg.get('forbid_global_delete','')=='yes':
       return {'return':1, 'error':'delete/rename operations are forbidden'}

    if cfg.get('forbid_global_writing','')=='yes':
       return {'return':1, 'error':'global writing is forbidden'}

    if len(i)==0: 
       return {'return':0} # Check only global writing

    if cfg.get('forbid_writing_modules','')=='yes':
       muoa=i.get('module_uoa','')
       muid=i.get('module_uid','')
       if muoa==cfg['module_name'] or (muid!='' and muid in cfg['module_uids']):
          return {'return':1, 'error':'writing/changing modules is forbidden'}

    ruoa=i.get('repo_uoa','')
    ruid=i.get('repo_uid','')

    if cfg.get('forbid_writing_to_default_repo','')=='yes':
       if ruoa==cfg['repo_name_default'] or ruid==cfg['repo_uid_default']:
          return {'return':1, 'error':'writing to default repo is forbidden'}

    if cfg.get('forbid_writing_to_local_repo','')=='yes':
       if ruoa==cfg['repo_name_local'] or ruid==cfg['repo_uid_local']:
          return {'return':1, 'error':'writing to local repo is forbidden'}

    rr={'return':0}

    # Load info about repo
    rd={}
    if ruoa!='':
       if 'repo_dict' in i:
          rd=i['repo_dict']
       else:
          rx=load_repo_info_from_cache({'repo_uoa':ruoa})
          if rx['return']>0: return rx
          rd=rx.get('dict',{})
       rr['repo_dict']=rd

    if cfg.get('allow_writing_only_to_allowed','')=='yes':
       if rd.get('allow_writing','')!='yes':
          return {'return':1, 'error':'writing to this repo is forbidden'}

    if rd.get('forbid_deleting','')=='yes' and dl=='yes':
       return {'return':1, 'error':'deleting in this repo is forbidden'}

    return rr","['def' 'check_writing' '(' 'i' ')' ':' 'dl' '=' 'i' '.' 'get' '('
 ""'delete'"" ',' ""''"" ')' 'if' 'dl' '==' ""'yes'"" 'and' 'cfg' '.' 'get' '('
 ""'forbid_global_delete'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'delete/rename operations are forbidden'"" '}' 'if' 'cfg' '.' 'get' '('
 ""'forbid_global_writing'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':' ""'global writing is forbidden'"" '}'
 'if' 'len' '(' 'i' ')' '==' '0' ':' 'return' '{' ""'return'"" ':' '0' '}'
 '# Check only global writing' 'if' 'cfg' '.' 'get' '('
 ""'forbid_writing_modules'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'muoa' '=' 'i'
 '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'muid' '=' 'i' '.' 'get' '('
 ""'module_uid'"" ',' ""''"" ')' 'if' 'muoa' '==' 'cfg' '[' ""'module_name'""
 ']' 'or' '(' 'muid' '!=' ""''"" 'and' 'muid' 'in' 'cfg' '[' ""'module_uids'""
 ']' ')' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'writing/changing modules is forbidden'"" '}' 'ruoa' '=' 'i' '.' 'get'
 '(' ""'repo_uoa'"" ',' ""''"" ')' 'ruid' '=' 'i' '.' 'get' '(' ""'repo_uid'""
 ',' ""''"" ')' 'if' 'cfg' '.' 'get' '(' ""'forbid_writing_to_default_repo'""
 ',' ""''"" ')' '==' ""'yes'"" ':' 'if' 'ruoa' '==' 'cfg' '['
 ""'repo_name_default'"" ']' 'or' 'ruid' '==' 'cfg' '[' ""'repo_uid_default'""
 ']' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'writing to default repo is forbidden'"" '}' 'if' 'cfg' '.' 'get' '('
 ""'forbid_writing_to_local_repo'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'if'
 'ruoa' '==' 'cfg' '[' ""'repo_name_local'"" ']' 'or' 'ruid' '==' 'cfg' '['
 ""'repo_uid_local'"" ']' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' ""'writing to local repo is forbidden'"" '}' 'rr' '=' '{' ""'return'""
 ':' '0' '}' '# Load info about repo' 'rd' '=' '{' '}' 'if' 'ruoa' '!='
 ""''"" ':' 'if' ""'repo_dict'"" 'in' 'i' ':' 'rd' '=' 'i' '[' ""'repo_dict'""
 ']' 'else' ':' 'rx' '=' 'load_repo_info_from_cache' '(' '{' ""'repo_uoa'""
 ':' 'ruoa' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx'
 'rd' '=' 'rx' '.' 'get' '(' ""'dict'"" ',' '{' '}' ')' 'rr' '['
 ""'repo_dict'"" ']' '=' 'rd' 'if' 'cfg' '.' 'get' '('
 ""'allow_writing_only_to_allowed'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'if' 'rd'
 '.' 'get' '(' ""'allow_writing'"" ',' ""''"" ')' '!=' ""'yes'"" ':' 'return'
 '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'writing to this repo is forbidden'"" '}' 'if' 'rd' '.' 'get' '('
 ""'forbid_deleting'"" ',' ""''"" ')' '==' ""'yes'"" 'and' 'dl' '==' ""'yes'"" ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'deleting in this repo is forbidden'"" '}' 'return' 'rr']","Input:  {
              (module_uoa)
              (module_uid)

              (repo_uoa)
              (repo_uid)
              (repo_dict)

              (delete)     - if 'yes', check if global delete operation is allowed
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
              (repo_dict)  - repo cfg if available
            }",['Input' ':' '{' '(' 'module_uoa' ')' '(' 'module_uid' ')'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L991-L1061
ctuning/ck,ck/kernel.py,get_version,"def get_version(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0

              version      - list starting from major version number
              version_str  - version string
            }

    """"""

    import copy

    s=''

    x=copy.deepcopy(cfg['version'])

    for q in x:
        if s!='': s+='.'
        s+=str(q)

    return {'return':0, 'version':x, 'version_str':s}",python,"def get_version(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0

              version      - list starting from major version number
              version_str  - version string
            }

    """"""

    import copy

    s=''

    x=copy.deepcopy(cfg['version'])

    for q in x:
        if s!='': s+='.'
        s+=str(q)

    return {'return':0, 'version':x, 'version_str':s}","['def' 'get_version' '(' 'i' ')' ':' 'import' 'copy' 's' '=' ""''"" 'x' '='
 'copy' '.' 'deepcopy' '(' 'cfg' '[' ""'version'"" ']' ')' 'for' 'q' 'in'
 'x' ':' 'if' 's' '!=' ""''"" ':' 's' '+=' ""'.'"" 's' '+=' 'str' '(' 'q' ')'
 'return' '{' ""'return'"" ':' '0' ',' ""'version'"" ':' 'x' ','
 ""'version_str'"" ':' 's' '}']","Input:  {}

    Output: {
              return       - return code =  0

              version      - list starting from major version number
              version_str  - version string
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1068-L1091
ctuning/ck,ck/kernel.py,gen_tmp_file,"def gen_tmp_file(i):
    """"""
    Input:  {
              (suffix)     - temp file suffix
              (prefix)     - temp file prefix
              (remove_dir) - if 'yes', remove dir
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              file_name    - temp file name 
            }

    """"""

    xs=i.get('suffix','')
    xp=i.get('prefix','')
    s=i.get('string','')

    import tempfile
    fd, fn=tempfile.mkstemp(suffix=xs, prefix=xp)
    os.close(fd)
    os.remove(fn)

    if i.get('remove_dir','')=='yes':
       fn=os.path.basename(fn)

    return {'return':0, 'file_name':fn}",python,"def gen_tmp_file(i):
    """"""
    Input:  {
              (suffix)     - temp file suffix
              (prefix)     - temp file prefix
              (remove_dir) - if 'yes', remove dir
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              file_name    - temp file name 
            }

    """"""

    xs=i.get('suffix','')
    xp=i.get('prefix','')
    s=i.get('string','')

    import tempfile
    fd, fn=tempfile.mkstemp(suffix=xs, prefix=xp)
    os.close(fd)
    os.remove(fn)

    if i.get('remove_dir','')=='yes':
       fn=os.path.basename(fn)

    return {'return':0, 'file_name':fn}","['def' 'gen_tmp_file' '(' 'i' ')' ':' 'xs' '=' 'i' '.' 'get' '('
 ""'suffix'"" ',' ""''"" ')' 'xp' '=' 'i' '.' 'get' '(' ""'prefix'"" ',' ""''""
 ')' 's' '=' 'i' '.' 'get' '(' ""'string'"" ',' ""''"" ')' 'import' 'tempfile'
 'fd' ',' 'fn' '=' 'tempfile' '.' 'mkstemp' '(' 'suffix' '=' 'xs' ','
 'prefix' '=' 'xp' ')' 'os' '.' 'close' '(' 'fd' ')' 'os' '.' 'remove' '('
 'fn' ')' 'if' 'i' '.' 'get' '(' ""'remove_dir'"" ',' ""''"" ')' '==' ""'yes'""
 ':' 'fn' '=' 'os' '.' 'path' '.' 'basename' '(' 'fn' ')' 'return' '{'
 ""'return'"" ':' '0' ',' ""'file_name'"" ':' 'fn' '}']","Input:  {
              (suffix)     - temp file suffix
              (prefix)     - temp file prefix
              (remove_dir) - if 'yes', remove dir
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              file_name    - temp file name 
            }","['Input' ':' '{' '(' 'suffix' ')' '-' 'temp' 'file' 'suffix' '(' 'prefix'
 ')' '-' 'temp' 'file' 'prefix' '(' 'remove_dir' ')' '-' 'if' 'yes'
 'remove' 'dir' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1098-L1128
ctuning/ck,ck/kernel.py,get_os_ck,"def get_os_ck(i):
    """"""
    Input:  {
              (bits)      - force OS bits
            }

    Output: {
              return      - return code =  0
              platform    - 'win' or 'linux'
              bits        - OS bits in string: 32 or 64
              python_bits - Python installation bits in string: 32 or 64

            }
    """"""

    import os
    import platform
    import struct

    pbits=str(8 * struct.calcsize(""P""))

    plat='linux'
    if platform.system().lower().startswith('win'): # pragma: no cover
       plat='win'

    obits=i.get('bits','')
    if obits=='':
       obits='32'
       if plat=='win':
          # Trying to get fast way to detect bits
          if os.environ.get('ProgramW6432','')!='' or os.environ.get('ProgramFiles(x86)','')!='': # pragma: no cover
             obits='64'
       else:
          # On Linux use first getconf LONG_BIT and if doesn't work use python bits

          obits=pbits

          r=gen_tmp_file({})
          if r['return']>0: return r
          fn=r['file_name']

          cmd='getconf LONG_BIT > '+fn
          rx=os.system(cmd)
          if rx==0:
             r=load_text_file({'text_file':fn, 
                               'delete_after_read':'yes'})
             if r['return']==0:
                s=r['string'].strip()
                if len(s)>0 and len(s)<4:
                   obits=s

    return {'return':0, 'platform':plat, 'bits':obits, 'python_bits':pbits}",python,"def get_os_ck(i):
    """"""
    Input:  {
              (bits)      - force OS bits
            }

    Output: {
              return      - return code =  0
              platform    - 'win' or 'linux'
              bits        - OS bits in string: 32 or 64
              python_bits - Python installation bits in string: 32 or 64

            }
    """"""

    import os
    import platform
    import struct

    pbits=str(8 * struct.calcsize(""P""))

    plat='linux'
    if platform.system().lower().startswith('win'): # pragma: no cover
       plat='win'

    obits=i.get('bits','')
    if obits=='':
       obits='32'
       if plat=='win':
          # Trying to get fast way to detect bits
          if os.environ.get('ProgramW6432','')!='' or os.environ.get('ProgramFiles(x86)','')!='': # pragma: no cover
             obits='64'
       else:
          # On Linux use first getconf LONG_BIT and if doesn't work use python bits

          obits=pbits

          r=gen_tmp_file({})
          if r['return']>0: return r
          fn=r['file_name']

          cmd='getconf LONG_BIT > '+fn
          rx=os.system(cmd)
          if rx==0:
             r=load_text_file({'text_file':fn, 
                               'delete_after_read':'yes'})
             if r['return']==0:
                s=r['string'].strip()
                if len(s)>0 and len(s)<4:
                   obits=s

    return {'return':0, 'platform':plat, 'bits':obits, 'python_bits':pbits}","['def' 'get_os_ck' '(' 'i' ')' ':' 'import' 'os' 'import' 'platform'
 'import' 'struct' 'pbits' '=' 'str' '(' '8' '*' 'struct' '.' 'calcsize'
 '(' '""P""' ')' ')' 'plat' '=' ""'linux'"" 'if' 'platform' '.' 'system' '('
 ')' '.' 'lower' '(' ')' '.' 'startswith' '(' ""'win'"" ')' ':'
 '# pragma: no cover' 'plat' '=' ""'win'"" 'obits' '=' 'i' '.' 'get' '('
 ""'bits'"" ',' ""''"" ')' 'if' 'obits' '==' ""''"" ':' 'obits' '=' ""'32'"" 'if'
 'plat' '==' ""'win'"" ':' '# Trying to get fast way to detect bits' 'if'
 'os' '.' 'environ' '.' 'get' '(' ""'ProgramW6432'"" ',' ""''"" ')' '!=' ""''""
 'or' 'os' '.' 'environ' '.' 'get' '(' ""'ProgramFiles(x86)'"" ',' ""''"" ')'
 '!=' ""''"" ':' '# pragma: no cover' 'obits' '=' ""'64'"" 'else' ':'
 ""# On Linux use first getconf LONG_BIT and if doesn't work use python bits""
 'obits' '=' 'pbits' 'r' '=' 'gen_tmp_file' '(' '{' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'fn' '=' 'r' '[' ""'file_name'""
 ']' 'cmd' '=' ""'getconf LONG_BIT > '"" '+' 'fn' 'rx' '=' 'os' '.' 'system'
 '(' 'cmd' ')' 'if' 'rx' '==' '0' ':' 'r' '=' 'load_text_file' '(' '{'
 ""'text_file'"" ':' 'fn' ',' ""'delete_after_read'"" ':' ""'yes'"" '}' ')' 'if'
 'r' '[' ""'return'"" ']' '==' '0' ':' 's' '=' 'r' '[' ""'string'"" ']' '.'
 'strip' '(' ')' 'if' 'len' '(' 's' ')' '>' '0' 'and' 'len' '(' 's' ')'
 '<' '4' ':' 'obits' '=' 's' 'return' '{' ""'return'"" ':' '0' ','
 ""'platform'"" ':' 'plat' ',' ""'bits'"" ':' 'obits' ',' ""'python_bits'"" ':'
 'pbits' '}']","Input:  {
              (bits)      - force OS bits
            }

    Output: {
              return      - return code =  0
              platform    - 'win' or 'linux'
              bits        - OS bits in string: 32 or 64
              python_bits - Python installation bits in string: 32 or 64

            }",['Input' ':' '{' '(' 'bits' ')' '-' 'force' 'OS' 'bits' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1135-L1186
ctuning/ck,ck/kernel.py,gen_uid,"def gen_uid(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              data_uid     - UID in string format (16 characters 0..9,a..f)
            }
    """"""

    import uuid
    import random

    uid=str(uuid.uuid4().hex)

    if len(uid)!=32:
       return {'return':1, 'error':'problem generating UID : len='+str(len(uid))+' !=32'} # pragma: no cover 

    random.seed

    x=random.randrange(0,16)
    return {'return':0, 'data_uid':uid[x:x+16]}",python,"def gen_uid(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              data_uid     - UID in string format (16 characters 0..9,a..f)
            }
    """"""

    import uuid
    import random

    uid=str(uuid.uuid4().hex)

    if len(uid)!=32:
       return {'return':1, 'error':'problem generating UID : len='+str(len(uid))+' !=32'} # pragma: no cover 

    random.seed

    x=random.randrange(0,16)
    return {'return':0, 'data_uid':uid[x:x+16]}","['def' 'gen_uid' '(' 'i' ')' ':' 'import' 'uuid' 'import' 'random' 'uid'
 '=' 'str' '(' 'uuid' '.' 'uuid4' '(' ')' '.' 'hex' ')' 'if' 'len' '('
 'uid' ')' '!=' '32' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem generating UID : len='"" '+' 'str' '(' 'len' '(' 'uid' ')' ')'
 '+' ""' !=32'"" '}' '# pragma: no cover ' 'random' '.' 'seed' 'x' '='
 'random' '.' 'randrange' '(' '0' ',' '16' ')' 'return' '{' ""'return'"" ':'
 '0' ',' ""'data_uid'"" ':' 'uid' '[' 'x' ':' 'x' '+' '16' ']' '}']","Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              data_uid     - UID in string format (16 characters 0..9,a..f)
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1193-L1217
ctuning/ck,ck/kernel.py,is_uid,"def is_uid(str):
    """"""
    Input:  string to check

    Output: True if UID, otherwise False
    """"""

    import re

    if len(str)!=16:
       return False

    pattern = r'[^\.a-f0-9]'
    if re.search(pattern, str.lower()):
        return False

    return True",python,"def is_uid(str):
    """"""
    Input:  string to check

    Output: True if UID, otherwise False
    """"""

    import re

    if len(str)!=16:
       return False

    pattern = r'[^\.a-f0-9]'
    if re.search(pattern, str.lower()):
        return False

    return True","['def' 'is_uid' '(' 'str' ')' ':' 'import' 're' 'if' 'len' '(' 'str' ')'
 '!=' '16' ':' 'return' 'False' 'pattern' '=' ""r'[^\\.a-f0-9]'"" 'if' 're'
 '.' 'search' '(' 'pattern' ',' 'str' '.' 'lower' '(' ')' ')' ':' 'return'
 'False' 'return' 'True']","Input:  string to check

    Output: True if UID, otherwise False",['Input' ':' 'string' 'to' 'check'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1224-L1240
ctuning/ck,ck/kernel.py,is_uoa,"def is_uoa(str):
    """"""
    Input:  string to check

    Output: True if allowed UOA, False otherwise
    """"""

    if str.find(cfg['detect_cur_cid'])>=0 or str.find(cfg['detect_cur_cid1'])>=0: return False
    if str.find('*')>=0: return False
    if str.find('?')>=0: return False

    return True",python,"def is_uoa(str):
    """"""
    Input:  string to check

    Output: True if allowed UOA, False otherwise
    """"""

    if str.find(cfg['detect_cur_cid'])>=0 or str.find(cfg['detect_cur_cid1'])>=0: return False
    if str.find('*')>=0: return False
    if str.find('?')>=0: return False

    return True","['def' 'is_uoa' '(' 'str' ')' ':' 'if' 'str' '.' 'find' '(' 'cfg' '['
 ""'detect_cur_cid'"" ']' ')' '>=' '0' 'or' 'str' '.' 'find' '(' 'cfg' '['
 ""'detect_cur_cid1'"" ']' ')' '>=' '0' ':' 'return' 'False' 'if' 'str' '.'
 'find' '(' ""'*'"" ')' '>=' '0' ':' 'return' 'False' 'if' 'str' '.' 'find'
 '(' ""'?'"" ')' '>=' '0' ':' 'return' 'False' 'return' 'True']","Input:  string to check

    Output: True if allowed UOA, False otherwise",['Input' ':' 'string' 'to' 'check'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1248-L1259
ctuning/ck,ck/kernel.py,prepare_special_info_about_entry,"def prepare_special_info_about_entry(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - dict with info
            }
    """"""

    # Add control info
    d={'engine':'CK',
       'version':cfg['version']}

    if cfg.get('default_developer','')!='':
       d['author']=cfg['default_developer']

    if cfg.get('default_developer_email','')!='':
       d['author_email']=cfg['default_developer_email']

    if cfg.get('default_developer_webpage','')!='':
       d['author_webpage']=cfg['default_developer_webpage']

    if cfg.get('default_license','')!='':
       d['license']=cfg['default_license']

    if cfg.get('default_copyright','')!='':
       d['copyright']=cfg['default_copyright']

    r=get_current_date_time({})
    d['iso_datetime']=r['iso_datetime']

    return {'return':0, 'dict': d}",python,"def prepare_special_info_about_entry(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - dict with info
            }
    """"""

    # Add control info
    d={'engine':'CK',
       'version':cfg['version']}

    if cfg.get('default_developer','')!='':
       d['author']=cfg['default_developer']

    if cfg.get('default_developer_email','')!='':
       d['author_email']=cfg['default_developer_email']

    if cfg.get('default_developer_webpage','')!='':
       d['author_webpage']=cfg['default_developer_webpage']

    if cfg.get('default_license','')!='':
       d['license']=cfg['default_license']

    if cfg.get('default_copyright','')!='':
       d['copyright']=cfg['default_copyright']

    r=get_current_date_time({})
    d['iso_datetime']=r['iso_datetime']

    return {'return':0, 'dict': d}","['def' 'prepare_special_info_about_entry' '(' 'i' ')' ':'
 '# Add control info' 'd' '=' '{' ""'engine'"" ':' ""'CK'"" ',' ""'version'""
 ':' 'cfg' '[' ""'version'"" ']' '}' 'if' 'cfg' '.' 'get' '('
 ""'default_developer'"" ',' ""''"" ')' '!=' ""''"" ':' 'd' '[' ""'author'"" ']'
 '=' 'cfg' '[' ""'default_developer'"" ']' 'if' 'cfg' '.' 'get' '('
 ""'default_developer_email'"" ',' ""''"" ')' '!=' ""''"" ':' 'd' '['
 ""'author_email'"" ']' '=' 'cfg' '[' ""'default_developer_email'"" ']' 'if'
 'cfg' '.' 'get' '(' ""'default_developer_webpage'"" ',' ""''"" ')' '!=' ""''""
 ':' 'd' '[' ""'author_webpage'"" ']' '=' 'cfg' '['
 ""'default_developer_webpage'"" ']' 'if' 'cfg' '.' 'get' '('
 ""'default_license'"" ',' ""''"" ')' '!=' ""''"" ':' 'd' '[' ""'license'"" ']'
 '=' 'cfg' '[' ""'default_license'"" ']' 'if' 'cfg' '.' 'get' '('
 ""'default_copyright'"" ',' ""''"" ')' '!=' ""''"" ':' 'd' '[' ""'copyright'""
 ']' '=' 'cfg' '[' ""'default_copyright'"" ']' 'r' '='
 'get_current_date_time' '(' '{' '}' ')' 'd' '[' ""'iso_datetime'"" ']' '='
 'r' '[' ""'iso_datetime'"" ']' 'return' '{' ""'return'"" ':' '0' ',' ""'dict'""
 ':' 'd' '}']","Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - dict with info
            }",['Input' ':' '{' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1266-L1302
ctuning/ck,ck/kernel.py,convert_json_str_to_dict,"def convert_json_str_to_dict(i):
    """"""
    Input:  {
              str                      - string (use ' instead of "", i.e. {'a':'b'} 
                                         to avoid issues in CMD in Windows and Linux!)

              (skip_quote_replacement) - if 'yes', do not make above replacement
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - dict from json file
            }
    """"""

    s=i['str']

    if i.get('skip_quote_replacement','')!='yes':
       s=s.replace('""', '\\""')
       s=s.replace('\'', '""')

    try:
       d=json.loads(s, encoding='utf8')
    except Exception as e:
       return {'return':1, 'error':'problem converting text to json ('+format(e)+')'}

    return {'return':0, 'dict': d}",python,"def convert_json_str_to_dict(i):
    """"""
    Input:  {
              str                      - string (use ' instead of "", i.e. {'a':'b'} 
                                         to avoid issues in CMD in Windows and Linux!)

              (skip_quote_replacement) - if 'yes', do not make above replacement
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - dict from json file
            }
    """"""

    s=i['str']

    if i.get('skip_quote_replacement','')!='yes':
       s=s.replace('""', '\\""')
       s=s.replace('\'', '""')

    try:
       d=json.loads(s, encoding='utf8')
    except Exception as e:
       return {'return':1, 'error':'problem converting text to json ('+format(e)+')'}

    return {'return':0, 'dict': d}","['def' 'convert_json_str_to_dict' '(' 'i' ')' ':' 's' '=' 'i' '[' ""'str'""
 ']' 'if' 'i' '.' 'get' '(' ""'skip_quote_replacement'"" ',' ""''"" ')' '!='
 ""'yes'"" ':' 's' '=' 's' '.' 'replace' '(' '\'""\'' ',' '\'\\\\""\'' ')' 's'
 '=' 's' '.' 'replace' '(' ""'\\''"" ',' '\'""\'' ')' 'try' ':' 'd' '='
 'json' '.' 'loads' '(' 's' ',' 'encoding' '=' ""'utf8'"" ')' 'except'
 'Exception' 'as' 'e' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' ""'problem converting text to json ('"" '+' 'format' '(' 'e' ')' '+'
 ""')'"" '}' 'return' '{' ""'return'"" ':' '0' ',' ""'dict'"" ':' 'd' '}']","Input:  {
              str                      - string (use ' instead of "", i.e. {'a':'b'} 
                                         to avoid issues in CMD in Windows and Linux!)

              (skip_quote_replacement) - if 'yes', do not make above replacement
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - dict from json file
            }","['Input' ':' '{' 'str' '-' 'string' '(' 'use' 'instead' 'of' 'i' '.' 'e'
 '.' '{' 'a' ':' 'b' '}' 'to' 'avoid' 'issues' 'in' 'CMD' 'in' 'Windows'
 'and' 'Linux!' ')']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1309-L1338
ctuning/ck,ck/kernel.py,load_json_file,"def load_json_file(i):
    """"""
    Input:  {
              json_file - name of file with json
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found (may be warning)
                                         >  0, if error
              (error)  - error text if return > 0

              dict     - dict from json file
            }
    """"""

    fn=i['json_file']

    try:
      if sys.version_info[0]>2:
         f=open(fn, 'r', encoding='utf8')
      else:
         f=open(fn, 'r')
    except Exception as e:
       return {'return':16, 'error':'problem opening json file='+fn+' ('+format(e)+')'}

    try:
      s=f.read()
    except Exception as e:
       f.close()
       return {'return':1, 'error':'problem reading json file='+fn+' ('+format(e)+')'}

    f.close()

    try:
      if sys.version_info[0]>2:
         d=json.loads(s)
      else:
         d=json.loads(s, encoding='utf8')
    except Exception as e:
       return {'return':1, 'error':'problem parsing json from file='+fn+' ('+format(e)+')'}

    return {'return':0, 'dict': d}",python,"def load_json_file(i):
    """"""
    Input:  {
              json_file - name of file with json
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found (may be warning)
                                         >  0, if error
              (error)  - error text if return > 0

              dict     - dict from json file
            }
    """"""

    fn=i['json_file']

    try:
      if sys.version_info[0]>2:
         f=open(fn, 'r', encoding='utf8')
      else:
         f=open(fn, 'r')
    except Exception as e:
       return {'return':16, 'error':'problem opening json file='+fn+' ('+format(e)+')'}

    try:
      s=f.read()
    except Exception as e:
       f.close()
       return {'return':1, 'error':'problem reading json file='+fn+' ('+format(e)+')'}

    f.close()

    try:
      if sys.version_info[0]>2:
         d=json.loads(s)
      else:
         d=json.loads(s, encoding='utf8')
    except Exception as e:
       return {'return':1, 'error':'problem parsing json from file='+fn+' ('+format(e)+')'}

    return {'return':0, 'dict': d}","['def' 'load_json_file' '(' 'i' ')' ':' 'fn' '=' 'i' '[' ""'json_file'"" ']'
 'try' ':' 'if' 'sys' '.' 'version_info' '[' '0' ']' '>' '2' ':' 'f' '='
 'open' '(' 'fn' ',' ""'r'"" ',' 'encoding' '=' ""'utf8'"" ')' 'else' ':' 'f'
 '=' 'open' '(' 'fn' ',' ""'r'"" ')' 'except' 'Exception' 'as' 'e' ':'
 'return' '{' ""'return'"" ':' '16' ',' ""'error'"" ':'
 ""'problem opening json file='"" '+' 'fn' '+' ""' ('"" '+' 'format' '(' 'e'
 ')' '+' ""')'"" '}' 'try' ':' 's' '=' 'f' '.' 'read' '(' ')' 'except'
 'Exception' 'as' 'e' ':' 'f' '.' 'close' '(' ')' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'problem reading json file='"" '+' 'fn' '+'
 ""' ('"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}' 'f' '.' 'close' '(' ')'
 'try' ':' 'if' 'sys' '.' 'version_info' '[' '0' ']' '>' '2' ':' 'd' '='
 'json' '.' 'loads' '(' 's' ')' 'else' ':' 'd' '=' 'json' '.' 'loads' '('
 's' ',' 'encoding' '=' ""'utf8'"" ')' 'except' 'Exception' 'as' 'e' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem parsing json from file='"" '+' 'fn' '+' ""' ('"" '+' 'format' '('
 'e' ')' '+' ""')'"" '}' 'return' '{' ""'return'"" ':' '0' ',' ""'dict'"" ':'
 'd' '}']","Input:  {
              json_file - name of file with json
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found (may be warning)
                                         >  0, if error
              (error)  - error text if return > 0

              dict     - dict from json file
            }",['Input' ':' '{' 'json_file' '-' 'name' 'of' 'file' 'with' 'json' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1345-L1387
ctuning/ck,ck/kernel.py,load_yaml_file,"def load_yaml_file(i):
    """"""
    Input:  {
              yaml_file - name of YAML file
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found (may be warning)
                                         >  0, if error
              (error)  - error text if return > 0

              dict     - dict from YAML file
            }
    """"""

    import yaml

    fn=i['yaml_file']

    try:
      if sys.version_info[0]>2:
         f=open(fn, 'r', encoding='utf8')
      else:
         f=open(fn, 'r')
    except Exception as e:
       return {'return':16, 'error':'problem opening YAML file='+fn+' ('+format(e)+')'}

    try:
      s=f.read()
    except Exception as e:
       f.close()
       return {'return':1, 'error':'problem reading YAML file='+fn+' ('+format(e)+')'}

    f.close()

    try:
      d=yaml.load(s)
    except Exception as e:
       return {'return':1, 'error':'problem parsing YAML from file='+fn+' ('+format(e)+')'}

    return {'return':0, 'dict': d}",python,"def load_yaml_file(i):
    """"""
    Input:  {
              yaml_file - name of YAML file
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found (may be warning)
                                         >  0, if error
              (error)  - error text if return > 0

              dict     - dict from YAML file
            }
    """"""

    import yaml

    fn=i['yaml_file']

    try:
      if sys.version_info[0]>2:
         f=open(fn, 'r', encoding='utf8')
      else:
         f=open(fn, 'r')
    except Exception as e:
       return {'return':16, 'error':'problem opening YAML file='+fn+' ('+format(e)+')'}

    try:
      s=f.read()
    except Exception as e:
       f.close()
       return {'return':1, 'error':'problem reading YAML file='+fn+' ('+format(e)+')'}

    f.close()

    try:
      d=yaml.load(s)
    except Exception as e:
       return {'return':1, 'error':'problem parsing YAML from file='+fn+' ('+format(e)+')'}

    return {'return':0, 'dict': d}","['def' 'load_yaml_file' '(' 'i' ')' ':' 'import' 'yaml' 'fn' '=' 'i' '['
 ""'yaml_file'"" ']' 'try' ':' 'if' 'sys' '.' 'version_info' '[' '0' ']' '>'
 '2' ':' 'f' '=' 'open' '(' 'fn' ',' ""'r'"" ',' 'encoding' '=' ""'utf8'"" ')'
 'else' ':' 'f' '=' 'open' '(' 'fn' ',' ""'r'"" ')' 'except' 'Exception'
 'as' 'e' ':' 'return' '{' ""'return'"" ':' '16' ',' ""'error'"" ':'
 ""'problem opening YAML file='"" '+' 'fn' '+' ""' ('"" '+' 'format' '(' 'e'
 ')' '+' ""')'"" '}' 'try' ':' 's' '=' 'f' '.' 'read' '(' ')' 'except'
 'Exception' 'as' 'e' ':' 'f' '.' 'close' '(' ')' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'problem reading YAML file='"" '+' 'fn' '+'
 ""' ('"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}' 'f' '.' 'close' '(' ')'
 'try' ':' 'd' '=' 'yaml' '.' 'load' '(' 's' ')' 'except' 'Exception' 'as'
 'e' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem parsing YAML from file='"" '+' 'fn' '+' ""' ('"" '+' 'format' '('
 'e' ')' '+' ""')'"" '}' 'return' '{' ""'return'"" ':' '0' ',' ""'dict'"" ':'
 'd' '}']","Input:  {
              yaml_file - name of YAML file
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found (may be warning)
                                         >  0, if error
              (error)  - error text if return > 0

              dict     - dict from YAML file
            }",['Input' ':' '{' 'yaml_file' '-' 'name' 'of' 'YAML' 'file' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1394-L1435
ctuning/ck,ck/kernel.py,load_text_file,"def load_text_file(i):
    """"""
    Input:  {
              text_file           - name of text file
              (keep_as_bin)       - if 'yes', return only bin
              (encoding)          - by default 'utf8', however sometimes we use utf16

              (split_to_list)     - if 'yes', split to list

              (convert_to_dict)   - if 'yes', split to list and convert to dict
              (str_split)         - if !='', use as separator of keys/values when converting to dict
              (remove_quotes)     - if 'yes', remove quotes from values when converting to dict

              (delete_after_read) - if 'yes', delete file after read (useful when reading tmp files)
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found (may be warning)
                                         >  0, if error
              (error)  - error text if return > 0

              bin      - bin
              (string) - loaded text (with removed \r)
              (lst)    - if split_to_list=='yes', return as list
              (dict)   - if convert_to_dict=='yes', return as dict
            }
    """"""

    fn=i['text_file']

    en=i.get('encoding','')
    if en=='' or en==None: en='utf8'

    try:
       f=open(fn, 'rb')
    except Exception as e:
       return {'return':16, 'error':'problem opening text file='+fn+' ('+format(e)+')'}

    try:
       b=f.read()
    except Exception as e:
       f.close()
       return {'return':1, 'error':'problem reading text file='+fn+' ('+format(e)+')'}

    f.close()

    r={'return':0, 'bin':b}

    if i.get('delete_after_read','')=='yes':
       import os
       os.remove(fn)

    if i.get('keep_as_bin','')!='yes':
       s=b.decode(en).replace('\r','') # decode into Python string (unicode in Python3)
       r['string']=s

       cl=i.get('split_to_list','')
       cd=i.get('convert_to_dict','')

       if cl=='yes' or cd=='yes':
          lst=s.split('\n')
          r['lst']=lst

          if cd=='yes':
             dd={}

             ss=i.get('str_split','')
             rq=i.get('remove_quotes','')
             if ss=='': ss=':'

             for q in lst:
                 qq=q.strip()
                 ix=qq.find(ss)
                 if ix>0:
                    k=qq[0:ix].strip()
                    v=''
                    if ix+1<len(qq):
                       v=qq[ix+1:].strip()
                    if v!='' and rq=='yes':
                       if v.startswith('""'): v=v[1:]
                       if v.endswith('""'): v=v[:-1]
                    dd[k]=v

             r['dict']=dd

    return r",python,"def load_text_file(i):
    """"""
    Input:  {
              text_file           - name of text file
              (keep_as_bin)       - if 'yes', return only bin
              (encoding)          - by default 'utf8', however sometimes we use utf16

              (split_to_list)     - if 'yes', split to list

              (convert_to_dict)   - if 'yes', split to list and convert to dict
              (str_split)         - if !='', use as separator of keys/values when converting to dict
              (remove_quotes)     - if 'yes', remove quotes from values when converting to dict

              (delete_after_read) - if 'yes', delete file after read (useful when reading tmp files)
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found (may be warning)
                                         >  0, if error
              (error)  - error text if return > 0

              bin      - bin
              (string) - loaded text (with removed \r)
              (lst)    - if split_to_list=='yes', return as list
              (dict)   - if convert_to_dict=='yes', return as dict
            }
    """"""

    fn=i['text_file']

    en=i.get('encoding','')
    if en=='' or en==None: en='utf8'

    try:
       f=open(fn, 'rb')
    except Exception as e:
       return {'return':16, 'error':'problem opening text file='+fn+' ('+format(e)+')'}

    try:
       b=f.read()
    except Exception as e:
       f.close()
       return {'return':1, 'error':'problem reading text file='+fn+' ('+format(e)+')'}

    f.close()

    r={'return':0, 'bin':b}

    if i.get('delete_after_read','')=='yes':
       import os
       os.remove(fn)

    if i.get('keep_as_bin','')!='yes':
       s=b.decode(en).replace('\r','') # decode into Python string (unicode in Python3)
       r['string']=s

       cl=i.get('split_to_list','')
       cd=i.get('convert_to_dict','')

       if cl=='yes' or cd=='yes':
          lst=s.split('\n')
          r['lst']=lst

          if cd=='yes':
             dd={}

             ss=i.get('str_split','')
             rq=i.get('remove_quotes','')
             if ss=='': ss=':'

             for q in lst:
                 qq=q.strip()
                 ix=qq.find(ss)
                 if ix>0:
                    k=qq[0:ix].strip()
                    v=''
                    if ix+1<len(qq):
                       v=qq[ix+1:].strip()
                    if v!='' and rq=='yes':
                       if v.startswith('""'): v=v[1:]
                       if v.endswith('""'): v=v[:-1]
                    dd[k]=v

             r['dict']=dd

    return r","['def' 'load_text_file' '(' 'i' ')' ':' 'fn' '=' 'i' '[' ""'text_file'"" ']'
 'en' '=' 'i' '.' 'get' '(' ""'encoding'"" ',' ""''"" ')' 'if' 'en' '==' ""''""
 'or' 'en' '==' 'None' ':' 'en' '=' ""'utf8'"" 'try' ':' 'f' '=' 'open' '('
 'fn' ',' ""'rb'"" ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{'
 ""'return'"" ':' '16' ',' ""'error'"" ':' ""'problem opening text file='"" '+'
 'fn' '+' ""' ('"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}' 'try' ':' 'b' '='
 'f' '.' 'read' '(' ')' 'except' 'Exception' 'as' 'e' ':' 'f' '.' 'close'
 '(' ')' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem reading text file='"" '+' 'fn' '+' ""' ('"" '+' 'format' '(' 'e'
 ')' '+' ""')'"" '}' 'f' '.' 'close' '(' ')' 'r' '=' '{' ""'return'"" ':' '0'
 ',' ""'bin'"" ':' 'b' '}' 'if' 'i' '.' 'get' '(' ""'delete_after_read'"" ','
 ""''"" ')' '==' ""'yes'"" ':' 'import' 'os' 'os' '.' 'remove' '(' 'fn' ')'
 'if' 'i' '.' 'get' '(' ""'keep_as_bin'"" ',' ""''"" ')' '!=' ""'yes'"" ':' 's'
 '=' 'b' '.' 'decode' '(' 'en' ')' '.' 'replace' '(' ""'\\r'"" ',' ""''"" ')'
 '# decode into Python string (unicode in Python3)' 'r' '[' ""'string'"" ']'
 '=' 's' 'cl' '=' 'i' '.' 'get' '(' ""'split_to_list'"" ',' ""''"" ')' 'cd'
 '=' 'i' '.' 'get' '(' ""'convert_to_dict'"" ',' ""''"" ')' 'if' 'cl' '=='
 ""'yes'"" 'or' 'cd' '==' ""'yes'"" ':' 'lst' '=' 's' '.' 'split' '(' ""'\\n'""
 ')' 'r' '[' ""'lst'"" ']' '=' 'lst' 'if' 'cd' '==' ""'yes'"" ':' 'dd' '=' '{'
 '}' 'ss' '=' 'i' '.' 'get' '(' ""'str_split'"" ',' ""''"" ')' 'rq' '=' 'i'
 '.' 'get' '(' ""'remove_quotes'"" ',' ""''"" ')' 'if' 'ss' '==' ""''"" ':' 'ss'
 '=' ""':'"" 'for' 'q' 'in' 'lst' ':' 'qq' '=' 'q' '.' 'strip' '(' ')' 'ix'
 '=' 'qq' '.' 'find' '(' 'ss' ')' 'if' 'ix' '>' '0' ':' 'k' '=' 'qq' '['
 '0' ':' 'ix' ']' '.' 'strip' '(' ')' 'v' '=' ""''"" 'if' 'ix' '+' '1' '<'
 'len' '(' 'qq' ')' ':' 'v' '=' 'qq' '[' 'ix' '+' '1' ':' ']' '.' 'strip'
 '(' ')' 'if' 'v' '!=' ""''"" 'and' 'rq' '==' ""'yes'"" ':' 'if' 'v' '.'
 'startswith' '(' '\'""\'' ')' ':' 'v' '=' 'v' '[' '1' ':' ']' 'if' 'v' '.'
 'endswith' '(' '\'""\'' ')' ':' 'v' '=' 'v' '[' ':' '-' '1' ']' 'dd' '['
 'k' ']' '=' 'v' 'r' '[' ""'dict'"" ']' '=' 'dd' 'return' 'r']","Input:  {
              text_file           - name of text file
              (keep_as_bin)       - if 'yes', return only bin
              (encoding)          - by default 'utf8', however sometimes we use utf16

              (split_to_list)     - if 'yes', split to list

              (convert_to_dict)   - if 'yes', split to list and convert to dict
              (str_split)         - if !='', use as separator of keys/values when converting to dict
              (remove_quotes)     - if 'yes', remove quotes from values when converting to dict

              (delete_after_read) - if 'yes', delete file after read (useful when reading tmp files)
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found (may be warning)
                                         >  0, if error
              (error)  - error text if return > 0

              bin      - bin
              (string) - loaded text (with removed \r)
              (lst)    - if split_to_list=='yes', return as list
              (dict)   - if convert_to_dict=='yes', return as dict
            }","['Input' ':' '{' 'text_file' '-' 'name' 'of' 'text' 'file' '('
 'keep_as_bin' ')' '-' 'if' 'yes' 'return' 'only' 'bin' '(' 'encoding' ')'
 '-' 'by' 'default' 'utf8' 'however' 'sometimes' 'we' 'use' 'utf16']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1442-L1528
ctuning/ck,ck/kernel.py,substitute_str_in_file,"def substitute_str_in_file(i):
    """"""
    Input:  {
              filename - file
              string1  - string to be replaced
              string2  - replace string
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found
                                         >  0, if error
              (error)  - error text if return > 0
            }
    """"""

    fn=i['filename']
    s1=i['string1']
    s2=i['string2']

    # Load text file (unicode)
    r=load_text_file({'text_file':fn})
    if r['return']>0: return r

    # Replace
    x=r['string']
    x=x.replace(s1,s2)

    # Save text file (unicode)
    r=save_text_file({'text_file':fn, 'string':x})
    if r['return']>0: return r

    return {'return':0}",python,"def substitute_str_in_file(i):
    """"""
    Input:  {
              filename - file
              string1  - string to be replaced
              string2  - replace string
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found
                                         >  0, if error
              (error)  - error text if return > 0
            }
    """"""

    fn=i['filename']
    s1=i['string1']
    s2=i['string2']

    # Load text file (unicode)
    r=load_text_file({'text_file':fn})
    if r['return']>0: return r

    # Replace
    x=r['string']
    x=x.replace(s1,s2)

    # Save text file (unicode)
    r=save_text_file({'text_file':fn, 'string':x})
    if r['return']>0: return r

    return {'return':0}","['def' 'substitute_str_in_file' '(' 'i' ')' ':' 'fn' '=' 'i' '['
 ""'filename'"" ']' 's1' '=' 'i' '[' ""'string1'"" ']' 's2' '=' 'i' '['
 ""'string2'"" ']' '# Load text file (unicode)' 'r' '=' 'load_text_file' '('
 '{' ""'text_file'"" ':' 'fn' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' '# Replace' 'x' '=' 'r' '[' ""'string'"" ']' 'x' '=' 'x'
 '.' 'replace' '(' 's1' ',' 's2' ')' '# Save text file (unicode)' 'r' '='
 'save_text_file' '(' '{' ""'text_file'"" ':' 'fn' ',' ""'string'"" ':' 'x'
 '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'return' '{'
 ""'return'"" ':' '0' '}']","Input:  {
              filename - file
              string1  - string to be replaced
              string2  - replace string
            }

    Output: {
              return       - return code =  0, if successful
                                         = 16, if file not found
                                         >  0, if error
              (error)  - error text if return > 0
            }","['Input' ':' '{' 'filename' '-' 'file' 'string1' '-' 'string' 'to' 'be'
 'replaced' 'string2' '-' 'replace' 'string' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1535-L1567
ctuning/ck,ck/kernel.py,dump_json,"def dump_json(i):
    """"""
    Input:  {
              dict          - dictionary
              (skip_indent) - if 'yes', skip indent
              (sort_keys)   - if 'yes', sort keys
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error

              string       - json string (in utf8)
            }
    """"""

    d=i['dict']
    si=i.get('skip_indent','')

    sk=False
    if i.get('sort_keys','')=='yes': sk=True

    try:
       if sys.version_info[0]>2:
          if si=='yes': s=json.dumps(d, ensure_ascii=False, sort_keys=sk)
          else:         s=json.dumps(d, indent=2, ensure_ascii=False, sort_keys=sk)
       else:
          if si=='yes': s=json.dumps(d, ensure_ascii=False, encoding='utf8', sort_keys=sk)
          else:         s=json.dumps(d, indent=2, ensure_ascii=False, encoding='utf8', sort_keys=sk)
    except Exception as e:
       return {'return':1, 'error':'problem converting dict to json ('+format(e)+')'}

    return {'return':0, 'string':s}",python,"def dump_json(i):
    """"""
    Input:  {
              dict          - dictionary
              (skip_indent) - if 'yes', skip indent
              (sort_keys)   - if 'yes', sort keys
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error

              string       - json string (in utf8)
            }
    """"""

    d=i['dict']
    si=i.get('skip_indent','')

    sk=False
    if i.get('sort_keys','')=='yes': sk=True

    try:
       if sys.version_info[0]>2:
          if si=='yes': s=json.dumps(d, ensure_ascii=False, sort_keys=sk)
          else:         s=json.dumps(d, indent=2, ensure_ascii=False, sort_keys=sk)
       else:
          if si=='yes': s=json.dumps(d, ensure_ascii=False, encoding='utf8', sort_keys=sk)
          else:         s=json.dumps(d, indent=2, ensure_ascii=False, encoding='utf8', sort_keys=sk)
    except Exception as e:
       return {'return':1, 'error':'problem converting dict to json ('+format(e)+')'}

    return {'return':0, 'string':s}","['def' 'dump_json' '(' 'i' ')' ':' 'd' '=' 'i' '[' ""'dict'"" ']' 'si' '='
 'i' '.' 'get' '(' ""'skip_indent'"" ',' ""''"" ')' 'sk' '=' 'False' 'if' 'i'
 '.' 'get' '(' ""'sort_keys'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'sk' '=' 'True'
 'try' ':' 'if' 'sys' '.' 'version_info' '[' '0' ']' '>' '2' ':' 'if' 'si'
 '==' ""'yes'"" ':' 's' '=' 'json' '.' 'dumps' '(' 'd' ',' 'ensure_ascii'
 '=' 'False' ',' 'sort_keys' '=' 'sk' ')' 'else' ':' 's' '=' 'json' '.'
 'dumps' '(' 'd' ',' 'indent' '=' '2' ',' 'ensure_ascii' '=' 'False' ','
 'sort_keys' '=' 'sk' ')' 'else' ':' 'if' 'si' '==' ""'yes'"" ':' 's' '='
 'json' '.' 'dumps' '(' 'd' ',' 'ensure_ascii' '=' 'False' ',' 'encoding'
 '=' ""'utf8'"" ',' 'sort_keys' '=' 'sk' ')' 'else' ':' 's' '=' 'json' '.'
 'dumps' '(' 'd' ',' 'indent' '=' '2' ',' 'ensure_ascii' '=' 'False' ','
 'encoding' '=' ""'utf8'"" ',' 'sort_keys' '=' 'sk' ')' 'except' 'Exception'
 'as' 'e' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem converting dict to json ('"" '+' 'format' '(' 'e' ')' '+' ""')'""
 '}' 'return' '{' ""'return'"" ':' '0' ',' ""'string'"" ':' 's' '}']","Input:  {
              dict          - dictionary
              (skip_indent) - if 'yes', skip indent
              (sort_keys)   - if 'yes', sort keys
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error

              string       - json string (in utf8)
            }","['Input' ':' '{' 'dict' '-' 'dictionary' '(' 'skip_indent' ')' '-' 'if'
 'yes' 'skip' 'indent' '(' 'sort_keys' ')' '-' 'if' 'yes' 'sort' 'keys'
 '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1597-L1629
ctuning/ck,ck/kernel.py,save_json_to_file,"def save_json_to_file(i):
    """"""
    Input:  {
              json_file    - file name
              dict         - dict to save
              (sort_keys)  - if 'yes', sort keys
              (safe)       - if 'yes', ignore non-JSON values (only for Debugging - changes original dict!)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    fn=i['json_file']

    if i.get('safe','')=='yes':
       d=i['dict']

       sd={}

       # Check main unprintable keys
       for k in d:
           try:
              json.dumps(d[k])
           except Exception as e: 
              pass
           else:
              sd[k]=d[k]

       i['dict']=sd

    r=dumps_json(i)
    if r['return']>0: return r
    s=r['string'].replace('\r','')+'\n'

    return save_text_file({'text_file':fn, 'string':s})",python,"def save_json_to_file(i):
    """"""
    Input:  {
              json_file    - file name
              dict         - dict to save
              (sort_keys)  - if 'yes', sort keys
              (safe)       - if 'yes', ignore non-JSON values (only for Debugging - changes original dict!)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    fn=i['json_file']

    if i.get('safe','')=='yes':
       d=i['dict']

       sd={}

       # Check main unprintable keys
       for k in d:
           try:
              json.dumps(d[k])
           except Exception as e: 
              pass
           else:
              sd[k]=d[k]

       i['dict']=sd

    r=dumps_json(i)
    if r['return']>0: return r
    s=r['string'].replace('\r','')+'\n'

    return save_text_file({'text_file':fn, 'string':s})","['def' 'save_json_to_file' '(' 'i' ')' ':' 'fn' '=' 'i' '[' ""'json_file'""
 ']' 'if' 'i' '.' 'get' '(' ""'safe'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'd' '='
 'i' '[' ""'dict'"" ']' 'sd' '=' '{' '}' '# Check main unprintable keys'
 'for' 'k' 'in' 'd' ':' 'try' ':' 'json' '.' 'dumps' '(' 'd' '[' 'k' ']'
 ')' 'except' 'Exception' 'as' 'e' ':' 'pass' 'else' ':' 'sd' '[' 'k' ']'
 '=' 'd' '[' 'k' ']' 'i' '[' ""'dict'"" ']' '=' 'sd' 'r' '=' 'dumps_json'
 '(' 'i' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 's' '='
 'r' '[' ""'string'"" ']' '.' 'replace' '(' ""'\\r'"" ',' ""''"" ')' '+' ""'\\n'""
 'return' 'save_text_file' '(' '{' ""'text_file'"" ':' 'fn' ',' ""'string'""
 ':' 's' '}' ')']","Input:  {
              json_file    - file name
              dict         - dict to save
              (sort_keys)  - if 'yes', sort keys
              (safe)       - if 'yes', ignore non-JSON values (only for Debugging - changes original dict!)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' 'json_file' '-' 'file' 'name' 'dict' '-' 'dict' 'to'
 'save' '(' 'sort_keys' ')' '-' 'if' 'yes' 'sort' 'keys' '(' 'safe' ')'
 '-' 'if' 'yes' 'ignore' 'non' '-' 'JSON' 'values' '(' 'only' 'for'
 'Debugging' '-' 'changes' 'original' 'dict!' ')' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1636-L1674
ctuning/ck,ck/kernel.py,save_yaml_to_file,"def save_yaml_to_file(i):
    """"""
    Input:  {
              yaml_file   - file name
              dict        - dict to save
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    import yaml

    fn=i['yaml_file']
    d=i['dict']

    try:
       # If using just dump and keys are in unicode, 
       # pyyaml adds warning and makes produced yaml unparsable
       s=yaml.safe_dump(d) 
    except Exception as e:
       return {'return':1, 'error':'problem converting dict to YAML ('+format(e)+')'}

    return save_text_file({'text_file':fn, 'string':s})",python,"def save_yaml_to_file(i):
    """"""
    Input:  {
              yaml_file   - file name
              dict        - dict to save
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    import yaml

    fn=i['yaml_file']
    d=i['dict']

    try:
       # If using just dump and keys are in unicode, 
       # pyyaml adds warning and makes produced yaml unparsable
       s=yaml.safe_dump(d) 
    except Exception as e:
       return {'return':1, 'error':'problem converting dict to YAML ('+format(e)+')'}

    return save_text_file({'text_file':fn, 'string':s})","['def' 'save_yaml_to_file' '(' 'i' ')' ':' 'import' 'yaml' 'fn' '=' 'i'
 '[' ""'yaml_file'"" ']' 'd' '=' 'i' '[' ""'dict'"" ']' 'try' ':'
 '# If using just dump and keys are in unicode, '
 '# pyyaml adds warning and makes produced yaml unparsable' 's' '=' 'yaml'
 '.' 'safe_dump' '(' 'd' ')' 'except' 'Exception' 'as' 'e' ':' 'return'
 '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem converting dict to YAML ('"" '+' 'format' '(' 'e' ')' '+' ""')'""
 '}' 'return' 'save_text_file' '(' '{' ""'text_file'"" ':' 'fn' ','
 ""'string'"" ':' 's' '}' ')']","Input:  {
              yaml_file   - file name
              dict        - dict to save
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' 'yaml_file' '-' 'file' 'name' 'dict' '-' 'dict' 'to'
 'save' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1681-L1707
ctuning/ck,ck/kernel.py,save_text_file,"def save_text_file(i):
    """"""
    Input:  {
              text_file - name of text file
              string    - string to write (with removed \r)
              (append)  - if 'yes', append
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)  - error text if return > 0
            }
    """"""

    fn=i['text_file']

    s=i['string']

    try:
      s=s.replace('\r','')
    except Exception as e:
       pass

    try:
      s=s.replace(b'\r',b'')
    except Exception as e:
       pass

    m='w'
    if i.get('append','')=='yes': m='a'

    try:
       s=s.encode('utf8')
    except Exception as e:
       pass

    try:
#      if sys.version_info[0]>2:
#         f=open(fn, m+'b')
#         f.write(s)
#      else:
      f=open(fn, m+'b')
      f.write(s)
    except Exception as e:
       return {'return':1, 'error':'problem writing text file='+fn+' ('+format(e)+')'}

    f.close()

    return {'return':0}",python,"def save_text_file(i):
    """"""
    Input:  {
              text_file - name of text file
              string    - string to write (with removed \r)
              (append)  - if 'yes', append
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)  - error text if return > 0
            }
    """"""

    fn=i['text_file']

    s=i['string']

    try:
      s=s.replace('\r','')
    except Exception as e:
       pass

    try:
      s=s.replace(b'\r',b'')
    except Exception as e:
       pass

    m='w'
    if i.get('append','')=='yes': m='a'

    try:
       s=s.encode('utf8')
    except Exception as e:
       pass

    try:
#      if sys.version_info[0]>2:
#         f=open(fn, m+'b')
#         f.write(s)
#      else:
      f=open(fn, m+'b')
      f.write(s)
    except Exception as e:
       return {'return':1, 'error':'problem writing text file='+fn+' ('+format(e)+')'}

    f.close()

    return {'return':0}","['def' 'save_text_file' '(' 'i' ')' ':' 'fn' '=' 'i' '[' ""'text_file'"" ']'
 's' '=' 'i' '[' ""'string'"" ']' 'try' ':' 's' '=' 's' '.' 'replace' '('
 ""'\\r'"" ',' ""''"" ')' 'except' 'Exception' 'as' 'e' ':' 'pass' 'try' ':'
 's' '=' 's' '.' 'replace' '(' ""b'\\r'"" ',' ""b''"" ')' 'except' 'Exception'
 'as' 'e' ':' 'pass' 'm' '=' ""'w'"" 'if' 'i' '.' 'get' '(' ""'append'"" ','
 ""''"" ')' '==' ""'yes'"" ':' 'm' '=' ""'a'"" 'try' ':' 's' '=' 's' '.'
 'encode' '(' ""'utf8'"" ')' 'except' 'Exception' 'as' 'e' ':' 'pass' 'try'
 ':' '#      if sys.version_info[0]>2:' ""#         f=open(fn, m+'b')""
 '#         f.write(s)' '#      else:' 'f' '=' 'open' '(' 'fn' ',' 'm' '+'
 ""'b'"" ')' 'f' '.' 'write' '(' 's' ')' 'except' 'Exception' 'as' 'e' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem writing text file='"" '+' 'fn' '+' ""' ('"" '+' 'format' '(' 'e'
 ')' '+' ""')'"" '}' 'f' '.' 'close' '(' ')' 'return' '{' ""'return'"" ':' '0'
 '}']","Input:  {
              text_file - name of text file
              string    - string to write (with removed \r)
              (append)  - if 'yes', append
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)  - error text if return > 0
            }","['Input' ':' '{' 'text_file' '-' 'name' 'of' 'text' 'file' 'string' '-'
 'string' 'to' 'write' '(' 'with' 'removed' '\\' 'r' ')' '(' 'append' ')'
 '-' 'if' 'yes' 'append' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1714-L1763
ctuning/ck,ck/kernel.py,copy_to_clipboard,"def copy_to_clipboard(i): # pragma: no cover 
    """"""
    Input:  {
              string - string to copy

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    s=i['string']

    failed=False
    ee=''

    # Try to load pyperclip (seems to work fine on Windows)
    try:
       import pyperclip
    except Exception as e:
       ee=format(e)
       failed=True
       pass

    if not failed:
       pyperclip.copy(s)
    else:
       failed=False

       # Try to load Tkinter
       try:
          from Tkinter import Tk
       except ImportError as e:
          ee=format(e)
          failed=True
          pass

       if failed:
          failed=False
          try:
             from tkinter import Tk
          except ImportError as e:
             ee=format(e)
             failed=True
             pass

       if failed:
          return {'return':1, 'error':'none of pyperclip/Tkinter/tkinter packages is installed'}

       # Copy to clipboard
       try:
          r = Tk()
          r.withdraw()
          r.clipboard_clear()
          r.clipboard_append(s)
          r.destroy()
       except Exception as e:
          return {'return':1, 'error':'problem copying string to clipboard ('+format(e)+')'}

    return {'return':0}",python,"def copy_to_clipboard(i): # pragma: no cover 
    """"""
    Input:  {
              string - string to copy

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    s=i['string']

    failed=False
    ee=''

    # Try to load pyperclip (seems to work fine on Windows)
    try:
       import pyperclip
    except Exception as e:
       ee=format(e)
       failed=True
       pass

    if not failed:
       pyperclip.copy(s)
    else:
       failed=False

       # Try to load Tkinter
       try:
          from Tkinter import Tk
       except ImportError as e:
          ee=format(e)
          failed=True
          pass

       if failed:
          failed=False
          try:
             from tkinter import Tk
          except ImportError as e:
             ee=format(e)
             failed=True
             pass

       if failed:
          return {'return':1, 'error':'none of pyperclip/Tkinter/tkinter packages is installed'}

       # Copy to clipboard
       try:
          r = Tk()
          r.withdraw()
          r.clipboard_clear()
          r.clipboard_append(s)
          r.destroy()
       except Exception as e:
          return {'return':1, 'error':'problem copying string to clipboard ('+format(e)+')'}

    return {'return':0}","['def' 'copy_to_clipboard' '(' 'i' ')' ':' '# pragma: no cover ' 's' '='
 'i' '[' ""'string'"" ']' 'failed' '=' 'False' 'ee' '=' ""''""
 '# Try to load pyperclip (seems to work fine on Windows)' 'try' ':'
 'import' 'pyperclip' 'except' 'Exception' 'as' 'e' ':' 'ee' '=' 'format'
 '(' 'e' ')' 'failed' '=' 'True' 'pass' 'if' 'not' 'failed' ':'
 'pyperclip' '.' 'copy' '(' 's' ')' 'else' ':' 'failed' '=' 'False'
 '# Try to load Tkinter' 'try' ':' 'from' 'Tkinter' 'import' 'Tk' 'except'
 'ImportError' 'as' 'e' ':' 'ee' '=' 'format' '(' 'e' ')' 'failed' '='
 'True' 'pass' 'if' 'failed' ':' 'failed' '=' 'False' 'try' ':' 'from'
 'tkinter' 'import' 'Tk' 'except' 'ImportError' 'as' 'e' ':' 'ee' '='
 'format' '(' 'e' ')' 'failed' '=' 'True' 'pass' 'if' 'failed' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'none of pyperclip/Tkinter/tkinter packages is installed'"" '}'
 '# Copy to clipboard' 'try' ':' 'r' '=' 'Tk' '(' ')' 'r' '.' 'withdraw'
 '(' ')' 'r' '.' 'clipboard_clear' '(' ')' 'r' '.' 'clipboard_append' '('
 's' ')' 'r' '.' 'destroy' '(' ')' 'except' 'Exception' 'as' 'e' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem copying string to clipboard ('"" '+' 'format' '(' 'e' ')' '+'
 ""')'"" '}' 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              string - string to copy

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' 'string' '-' 'string' 'to' 'copy'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1770-L1830
ctuning/ck,ck/kernel.py,merge_dicts,"def merge_dicts(i):
    """"""
    Input:  {
              dict1 - merge this dict with dict2 (will be directly modified!)
              dict2 - dict

    Output: {
              return       - return code =  0, if successful

              dict1        - output dict
            }
    """"""

    a=i['dict1']
    b=i['dict2']

    for k in b:
        v=b[k]
        if type(v) is dict:
           if k not in a:
              a.update({k:b[k]})
           elif type(a[k])==dict:
              merge_dicts({'dict1':a[k], 'dict2':b[k]})
           else:
              a[k]=b[k]
        elif type(v) is list:
           a[k]=[]
           for y in v:
               a[k].append(y)
        else:
           a[k]=b[k]

    return {'return':0, 'dict1':a}",python,"def merge_dicts(i):
    """"""
    Input:  {
              dict1 - merge this dict with dict2 (will be directly modified!)
              dict2 - dict

    Output: {
              return       - return code =  0, if successful

              dict1        - output dict
            }
    """"""

    a=i['dict1']
    b=i['dict2']

    for k in b:
        v=b[k]
        if type(v) is dict:
           if k not in a:
              a.update({k:b[k]})
           elif type(a[k])==dict:
              merge_dicts({'dict1':a[k], 'dict2':b[k]})
           else:
              a[k]=b[k]
        elif type(v) is list:
           a[k]=[]
           for y in v:
               a[k].append(y)
        else:
           a[k]=b[k]

    return {'return':0, 'dict1':a}","['def' 'merge_dicts' '(' 'i' ')' ':' 'a' '=' 'i' '[' ""'dict1'"" ']' 'b' '='
 'i' '[' ""'dict2'"" ']' 'for' 'k' 'in' 'b' ':' 'v' '=' 'b' '[' 'k' ']' 'if'
 'type' '(' 'v' ')' 'is' 'dict' ':' 'if' 'k' 'not' 'in' 'a' ':' 'a' '.'
 'update' '(' '{' 'k' ':' 'b' '[' 'k' ']' '}' ')' 'elif' 'type' '(' 'a'
 '[' 'k' ']' ')' '==' 'dict' ':' 'merge_dicts' '(' '{' ""'dict1'"" ':' 'a'
 '[' 'k' ']' ',' ""'dict2'"" ':' 'b' '[' 'k' ']' '}' ')' 'else' ':' 'a' '['
 'k' ']' '=' 'b' '[' 'k' ']' 'elif' 'type' '(' 'v' ')' 'is' 'list' ':' 'a'
 '[' 'k' ']' '=' '[' ']' 'for' 'y' 'in' 'v' ':' 'a' '[' 'k' ']' '.'
 'append' '(' 'y' ')' 'else' ':' 'a' '[' 'k' ']' '=' 'b' '[' 'k' ']'
 'return' '{' ""'return'"" ':' '0' ',' ""'dict1'"" ':' 'a' '}']","Input:  {
              dict1 - merge this dict with dict2 (will be directly modified!)
              dict2 - dict

    Output: {
              return       - return code =  0, if successful

              dict1        - output dict
            }","['Input' ':' '{' 'dict1' '-' 'merge' 'this' 'dict' 'with' 'dict2' '('
 'will' 'be' 'directly' 'modified!' ')' 'dict2' '-' 'dict']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1837-L1869
ctuning/ck,ck/kernel.py,convert_file_to_upload_string,"def convert_file_to_upload_string(i):
    """"""
    Input:  {
              filename - file name to convert
            }

    Output: {
              return              - return code =  0, if successful
                                                >  0, if error
              (error)             - error text if return > 0
              file_content_base64 - string that can be transmitted through Internet
            }
    """"""

    import base64

    fn=i['filename']

    if not os.path.isfile(fn):
       return {'return':1, 'error':'file '+fn+' not found'}

    s=b''
    try:
       f=open(fn, 'rb')
       while True:
          x = f.read(32768);
          if not x: break
          s+=x
       f.close()
    except Exception as e:
       return {'return':1, 'error':'error reading file ('+format(e)+')'}

    s=base64.urlsafe_b64encode(s).decode('utf8')

    return {'return':0, 'file_content_base64': s}",python,"def convert_file_to_upload_string(i):
    """"""
    Input:  {
              filename - file name to convert
            }

    Output: {
              return              - return code =  0, if successful
                                                >  0, if error
              (error)             - error text if return > 0
              file_content_base64 - string that can be transmitted through Internet
            }
    """"""

    import base64

    fn=i['filename']

    if not os.path.isfile(fn):
       return {'return':1, 'error':'file '+fn+' not found'}

    s=b''
    try:
       f=open(fn, 'rb')
       while True:
          x = f.read(32768);
          if not x: break
          s+=x
       f.close()
    except Exception as e:
       return {'return':1, 'error':'error reading file ('+format(e)+')'}

    s=base64.urlsafe_b64encode(s).decode('utf8')

    return {'return':0, 'file_content_base64': s}","['def' 'convert_file_to_upload_string' '(' 'i' ')' ':' 'import' 'base64'
 'fn' '=' 'i' '[' ""'filename'"" ']' 'if' 'not' 'os' '.' 'path' '.' 'isfile'
 '(' 'fn' ')' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'file '"" '+' 'fn' '+' ""' not found'"" '}' 's' '=' ""b''"" 'try' ':' 'f' '='
 'open' '(' 'fn' ',' ""'rb'"" ')' 'while' 'True' ':' 'x' '=' 'f' '.' 'read'
 '(' '32768' ')' 'if' 'not' 'x' ':' 'break' 's' '+=' 'x' 'f' '.' 'close'
 '(' ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{' ""'return'"" ':' '1'
 ',' ""'error'"" ':' ""'error reading file ('"" '+' 'format' '(' 'e' ')' '+'
 ""')'"" '}' 's' '=' 'base64' '.' 'urlsafe_b64encode' '(' 's' ')' '.'
 'decode' '(' ""'utf8'"" ')' 'return' '{' ""'return'"" ':' '0' ','
 ""'file_content_base64'"" ':' 's' '}']","Input:  {
              filename - file name to convert
            }

    Output: {
              return              - return code =  0, if successful
                                                >  0, if error
              (error)             - error text if return > 0
              file_content_base64 - string that can be transmitted through Internet
            }",['Input' ':' '{' 'filename' '-' 'file' 'name' 'to' 'convert' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1876-L1910
ctuning/ck,ck/kernel.py,convert_upload_string_to_file,"def convert_upload_string_to_file(i):
    """"""
    Input:  {
              file_content_base64 - string transmitted through Internet
              (filename)          - file name to write (if empty, generate tmp file)
            }

    Output: {
              return              - return code =  0, if successful
                                                >  0, if error
              (error)             - error text if return > 0
              filename            - filename with full path
              filename_ext        - filename extension
            }
    """"""

    import base64

    x=i['file_content_base64']

    fc=base64.urlsafe_b64decode(str(x)) # convert from unicode to str since base64 works on strings
                                        # should be safe in Python 2.x and 3.x

    fn=i.get('filename','')

    if fn=='':
       rx=gen_tmp_file({'prefix':'tmp-'})
       if rx['return']>0: return rx
       px=rx['file_name']
    else:
       px=fn

    fn1, fne = os.path.splitext(px)

    if os.path.isfile(px):
       return {'return':1, 'error':'file already exists in the current directory'}
    try:
       fx=open(px, 'wb')
       fx.write(fc)
       fx.close()
    except Exception as e:
       return {'return':1, 'error':'problem writing file='+px+' ('+format(e)+')'}

    return {'return':0, 'filename':px, 'filename_ext': fne}",python,"def convert_upload_string_to_file(i):
    """"""
    Input:  {
              file_content_base64 - string transmitted through Internet
              (filename)          - file name to write (if empty, generate tmp file)
            }

    Output: {
              return              - return code =  0, if successful
                                                >  0, if error
              (error)             - error text if return > 0
              filename            - filename with full path
              filename_ext        - filename extension
            }
    """"""

    import base64

    x=i['file_content_base64']

    fc=base64.urlsafe_b64decode(str(x)) # convert from unicode to str since base64 works on strings
                                        # should be safe in Python 2.x and 3.x

    fn=i.get('filename','')

    if fn=='':
       rx=gen_tmp_file({'prefix':'tmp-'})
       if rx['return']>0: return rx
       px=rx['file_name']
    else:
       px=fn

    fn1, fne = os.path.splitext(px)

    if os.path.isfile(px):
       return {'return':1, 'error':'file already exists in the current directory'}
    try:
       fx=open(px, 'wb')
       fx.write(fc)
       fx.close()
    except Exception as e:
       return {'return':1, 'error':'problem writing file='+px+' ('+format(e)+')'}

    return {'return':0, 'filename':px, 'filename_ext': fne}","['def' 'convert_upload_string_to_file' '(' 'i' ')' ':' 'import' 'base64'
 'x' '=' 'i' '[' ""'file_content_base64'"" ']' 'fc' '=' 'base64' '.'
 'urlsafe_b64decode' '(' 'str' '(' 'x' ')' ')'
 '# convert from unicode to str since base64 works on strings'
 '# should be safe in Python 2.x and 3.x' 'fn' '=' 'i' '.' 'get' '('
 ""'filename'"" ',' ""''"" ')' 'if' 'fn' '==' ""''"" ':' 'rx' '=' 'gen_tmp_file'
 '(' '{' ""'prefix'"" ':' ""'tmp-'"" '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'rx' 'px' '=' 'rx' '[' ""'file_name'"" ']' 'else' ':' 'px'
 '=' 'fn' 'fn1' ',' 'fne' '=' 'os' '.' 'path' '.' 'splitext' '(' 'px' ')'
 'if' 'os' '.' 'path' '.' 'isfile' '(' 'px' ')' ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'file already exists in the current directory'"" '}' 'try' ':' 'fx' '='
 'open' '(' 'px' ',' ""'wb'"" ')' 'fx' '.' 'write' '(' 'fc' ')' 'fx' '.'
 'close' '(' ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'problem writing file='"" '+' 'px' '+' ""' ('""
 '+' 'format' '(' 'e' ')' '+' ""')'"" '}' 'return' '{' ""'return'"" ':' '0'
 ',' ""'filename'"" ':' 'px' ',' ""'filename_ext'"" ':' 'fne' '}']","Input:  {
              file_content_base64 - string transmitted through Internet
              (filename)          - file name to write (if empty, generate tmp file)
            }

    Output: {
              return              - return code =  0, if successful
                                                >  0, if error
              (error)             - error text if return > 0
              filename            - filename with full path
              filename_ext        - filename extension
            }","['Input' ':' '{' 'file_content_base64' '-' 'string' 'transmitted'
 'through' 'Internet' '(' 'filename' ')' '-' 'file' 'name' 'to' 'write'
 '(' 'if' 'empty' 'generate' 'tmp' 'file' ')' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1917-L1960
ctuning/ck,ck/kernel.py,input_json,"def input_json(i):
    """"""
    Input:  {
              text - text to print
            }

    Output: {
              return              - return code =  0, if successful
                                                >  0, if error
              (error)             - error text if return > 0

              string
              dict                - parsed JSON
            }
    """"""


    t=i['text']

    out(t)

    s=''

    while True:
       r=inp({'text':''})
       if r['return']>0: return r
       ss=r['string'].strip()
       if ss=='': break
       s+=ss

    s=s.strip()

    if s=='': s='{}' # empty json
    else:
       if not s.startswith('{'): s='{'+s
       if not s.endswith('}'): s+='}'

    r=convert_json_str_to_dict({'str':s, 'skip_quote_replacement':'yes'})
    if r['return']>0: return r

    d=r['dict']

    return {'return':0, 'string': s, 'dict':d}",python,"def input_json(i):
    """"""
    Input:  {
              text - text to print
            }

    Output: {
              return              - return code =  0, if successful
                                                >  0, if error
              (error)             - error text if return > 0

              string
              dict                - parsed JSON
            }
    """"""


    t=i['text']

    out(t)

    s=''

    while True:
       r=inp({'text':''})
       if r['return']>0: return r
       ss=r['string'].strip()
       if ss=='': break
       s+=ss

    s=s.strip()

    if s=='': s='{}' # empty json
    else:
       if not s.startswith('{'): s='{'+s
       if not s.endswith('}'): s+='}'

    r=convert_json_str_to_dict({'str':s, 'skip_quote_replacement':'yes'})
    if r['return']>0: return r

    d=r['dict']

    return {'return':0, 'string': s, 'dict':d}","['def' 'input_json' '(' 'i' ')' ':' 't' '=' 'i' '[' ""'text'"" ']' 'out' '('
 't' ')' 's' '=' ""''"" 'while' 'True' ':' 'r' '=' 'inp' '(' '{' ""'text'""
 ':' ""''"" '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r'
 'ss' '=' 'r' '[' ""'string'"" ']' '.' 'strip' '(' ')' 'if' 'ss' '==' ""''""
 ':' 'break' 's' '+=' 'ss' 's' '=' 's' '.' 'strip' '(' ')' 'if' 's' '=='
 ""''"" ':' 's' '=' ""'{}'"" '# empty json' 'else' ':' 'if' 'not' 's' '.'
 'startswith' '(' ""'{'"" ')' ':' 's' '=' ""'{'"" '+' 's' 'if' 'not' 's' '.'
 'endswith' '(' ""'}'"" ')' ':' 's' '+=' ""'}'"" 'r' '='
 'convert_json_str_to_dict' '(' '{' ""'str'"" ':' 's' ','
 ""'skip_quote_replacement'"" ':' ""'yes'"" '}' ')' 'if' 'r' '[' ""'return'""
 ']' '>' '0' ':' 'return' 'r' 'd' '=' 'r' '[' ""'dict'"" ']' 'return' '{'
 ""'return'"" ':' '0' ',' ""'string'"" ':' 's' ',' ""'dict'"" ':' 'd' '}']","Input:  {
              text - text to print
            }

    Output: {
              return              - return code =  0, if successful
                                                >  0, if error
              (error)             - error text if return > 0

              string
              dict                - parsed JSON
            }",['Input' ':' '{' 'text' '-' 'text' 'to' 'print' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L1967-L2009
ctuning/ck,ck/kernel.py,convert_ck_list_to_dict,"def convert_ck_list_to_dict(i):
    """"""
    Input:  [ 
              CK list: see 'action' function from this kernel
            ]

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              ck_dict      - {
                               ""action"":action
                               ""cid"":module_uoa or CID (x means that it may not be really CID 
                                       and has to be processed specially
                               ""cids"":[cid1, cid2, cid3, ...]
                               ""key1"":value1
                               ""key2"":value2
                               ...
                               ""key10"":""""
                               ""key11"":value11
                               keys/values from file_json; if file extension is .tmp, 
                                                           it will be deleted after read!
                               keys/values from cmd_json
                               ""unparsed"":unparsed_cmd
                             }

    """"""
    obj={}
    obj['cids']=[]

    l=len(i)

    if l>0: obj['action']=i[0]

    module_uoa_or_cid=''

    # Parsing
    cx=True # Start first processing CIDs and then turn it off when something else is encountered

    if l>1:
       for x in range(1, len(i)):
           p=i[x].rstrip()

           #####################################
           if p=='--':
              cx=False
              p2=i[x+1:]
              obj['unparsed']=p2
              break

           #####################################
           elif p.startswith('--'):
              cx=False

              p=p[2:]
              p1=p 
              p2='yes'
              q=p.find(""="")
              if q>0:
                 p1=p[0:q]
                 if len(p)>q:
                   p2=p[q+1:]
              obj[p1]=p2

           #####################################
           elif p.startswith('-'):
              cx=False

              p=p[1:]
              p1=p 
              p2='yes'
              q=p.find(""="")
              if q>0:
                 p1=p[0:q]
                 if len(p)>q:
                   p2=p[q+1:]
              obj[p1]=p2

           #####################################
           elif p.startswith(""@@@""):
              cx=False
              jd=p[3:]
              if len(jd)<3:
                 return {'return':1, 'error':'can\'t parse command line option '+p}

              y=convert_json_str_to_dict({'str':jd})
              if y['return']>0: return y

              merge_dicts({'dict1':obj, 'dict2':y['dict']})

           #####################################
           elif p.startswith(""@@""):
              cx=False
              key=p[2:]

              x='Add JSON to input'
              if key!='': x+=' for key ""'+key+'""'
              x+=' (double Enter to stop):\n'

              rx=input_json({'text':x})
              if rx['return']>0: return rx

              dy=rx['dict']

              dx=obj
              if key!='':
                 if key not in obj: obj[key]={}
                 dx=obj[key]

              merge_dicts({'dict1':dx, 'dict2':dy})

           #####################################
           elif p.startswith(""@""):
              cx=False

              name=p[1:]
              if len(name)<2:
                 return {'return':1, 'error':'can\'t parse command line option '+p}

              y=load_json_file({'json_file':name})
              if y['return']>0: return y

              if name.endswith('.tmp'):
                 os.remove(name)   

              merge_dicts({'dict1':obj, 'dict2':y['dict']})

           #####################################
           elif p.find('=')>=0:
              cx=False

              p1=p 
              p2=''
              q=p.find(""="")
              if q>0:
                 p1=p[0:q]
                 if len(p)>q:
                   p2=p[q+1:]
              obj[p1]=p2
           #####################################
           else:
              # If no module_uoa_or_cid -> set it
              if module_uoa_or_cid=='': 
                 module_uoa_or_cid=p
              else:
                 # Otherwise add to CIDs
                 obj['cids'].append(p)

    if module_uoa_or_cid!='': obj['cid']=module_uoa_or_cid

    return {'return':0, 'ck_dict':obj}",python,"def convert_ck_list_to_dict(i):
    """"""
    Input:  [ 
              CK list: see 'action' function from this kernel
            ]

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              ck_dict      - {
                               ""action"":action
                               ""cid"":module_uoa or CID (x means that it may not be really CID 
                                       and has to be processed specially
                               ""cids"":[cid1, cid2, cid3, ...]
                               ""key1"":value1
                               ""key2"":value2
                               ...
                               ""key10"":""""
                               ""key11"":value11
                               keys/values from file_json; if file extension is .tmp, 
                                                           it will be deleted after read!
                               keys/values from cmd_json
                               ""unparsed"":unparsed_cmd
                             }

    """"""
    obj={}
    obj['cids']=[]

    l=len(i)

    if l>0: obj['action']=i[0]

    module_uoa_or_cid=''

    # Parsing
    cx=True # Start first processing CIDs and then turn it off when something else is encountered

    if l>1:
       for x in range(1, len(i)):
           p=i[x].rstrip()

           #####################################
           if p=='--':
              cx=False
              p2=i[x+1:]
              obj['unparsed']=p2
              break

           #####################################
           elif p.startswith('--'):
              cx=False

              p=p[2:]
              p1=p 
              p2='yes'
              q=p.find(""="")
              if q>0:
                 p1=p[0:q]
                 if len(p)>q:
                   p2=p[q+1:]
              obj[p1]=p2

           #####################################
           elif p.startswith('-'):
              cx=False

              p=p[1:]
              p1=p 
              p2='yes'
              q=p.find(""="")
              if q>0:
                 p1=p[0:q]
                 if len(p)>q:
                   p2=p[q+1:]
              obj[p1]=p2

           #####################################
           elif p.startswith(""@@@""):
              cx=False
              jd=p[3:]
              if len(jd)<3:
                 return {'return':1, 'error':'can\'t parse command line option '+p}

              y=convert_json_str_to_dict({'str':jd})
              if y['return']>0: return y

              merge_dicts({'dict1':obj, 'dict2':y['dict']})

           #####################################
           elif p.startswith(""@@""):
              cx=False
              key=p[2:]

              x='Add JSON to input'
              if key!='': x+=' for key ""'+key+'""'
              x+=' (double Enter to stop):\n'

              rx=input_json({'text':x})
              if rx['return']>0: return rx

              dy=rx['dict']

              dx=obj
              if key!='':
                 if key not in obj: obj[key]={}
                 dx=obj[key]

              merge_dicts({'dict1':dx, 'dict2':dy})

           #####################################
           elif p.startswith(""@""):
              cx=False

              name=p[1:]
              if len(name)<2:
                 return {'return':1, 'error':'can\'t parse command line option '+p}

              y=load_json_file({'json_file':name})
              if y['return']>0: return y

              if name.endswith('.tmp'):
                 os.remove(name)   

              merge_dicts({'dict1':obj, 'dict2':y['dict']})

           #####################################
           elif p.find('=')>=0:
              cx=False

              p1=p 
              p2=''
              q=p.find(""="")
              if q>0:
                 p1=p[0:q]
                 if len(p)>q:
                   p2=p[q+1:]
              obj[p1]=p2
           #####################################
           else:
              # If no module_uoa_or_cid -> set it
              if module_uoa_or_cid=='': 
                 module_uoa_or_cid=p
              else:
                 # Otherwise add to CIDs
                 obj['cids'].append(p)

    if module_uoa_or_cid!='': obj['cid']=module_uoa_or_cid

    return {'return':0, 'ck_dict':obj}","['def' 'convert_ck_list_to_dict' '(' 'i' ')' ':' 'obj' '=' '{' '}' 'obj'
 '[' ""'cids'"" ']' '=' '[' ']' 'l' '=' 'len' '(' 'i' ')' 'if' 'l' '>' '0'
 ':' 'obj' '[' ""'action'"" ']' '=' 'i' '[' '0' ']' 'module_uoa_or_cid' '='
 ""''"" '# Parsing' 'cx' '=' 'True'
 '# Start first processing CIDs and then turn it off when something else is encountered'
 'if' 'l' '>' '1' ':' 'for' 'x' 'in' 'range' '(' '1' ',' 'len' '(' 'i' ')'
 ')' ':' 'p' '=' 'i' '[' 'x' ']' '.' 'rstrip' '(' ')'
 '#####################################' 'if' 'p' '==' ""'--'"" ':' 'cx' '='
 'False' 'p2' '=' 'i' '[' 'x' '+' '1' ':' ']' 'obj' '[' ""'unparsed'"" ']'
 '=' 'p2' 'break' '#####################################' 'elif' 'p' '.'
 'startswith' '(' ""'--'"" ')' ':' 'cx' '=' 'False' 'p' '=' 'p' '[' '2' ':'
 ']' 'p1' '=' 'p' 'p2' '=' ""'yes'"" 'q' '=' 'p' '.' 'find' '(' '""=""' ')'
 'if' 'q' '>' '0' ':' 'p1' '=' 'p' '[' '0' ':' 'q' ']' 'if' 'len' '(' 'p'
 ')' '>' 'q' ':' 'p2' '=' 'p' '[' 'q' '+' '1' ':' ']' 'obj' '[' 'p1' ']'
 '=' 'p2' '#####################################' 'elif' 'p' '.'
 'startswith' '(' ""'-'"" ')' ':' 'cx' '=' 'False' 'p' '=' 'p' '[' '1' ':'
 ']' 'p1' '=' 'p' 'p2' '=' ""'yes'"" 'q' '=' 'p' '.' 'find' '(' '""=""' ')'
 'if' 'q' '>' '0' ':' 'p1' '=' 'p' '[' '0' ':' 'q' ']' 'if' 'len' '(' 'p'
 ')' '>' 'q' ':' 'p2' '=' 'p' '[' 'q' '+' '1' ':' ']' 'obj' '[' 'p1' ']'
 '=' 'p2' '#####################################' 'elif' 'p' '.'
 'startswith' '(' '""@@@""' ')' ':' 'cx' '=' 'False' 'jd' '=' 'p' '[' '3'
 ':' ']' 'if' 'len' '(' 'jd' ')' '<' '3' ':' 'return' '{' ""'return'"" ':'
 '1' ',' ""'error'"" ':' ""'can\\'t parse command line option '"" '+' 'p' '}'
 'y' '=' 'convert_json_str_to_dict' '(' '{' ""'str'"" ':' 'jd' '}' ')' 'if'
 'y' '[' ""'return'"" ']' '>' '0' ':' 'return' 'y' 'merge_dicts' '(' '{'
 ""'dict1'"" ':' 'obj' ',' ""'dict2'"" ':' 'y' '[' ""'dict'"" ']' '}' ')'
 '#####################################' 'elif' 'p' '.' 'startswith' '('
 '""@@""' ')' ':' 'cx' '=' 'False' 'key' '=' 'p' '[' '2' ':' ']' 'x' '='
 ""'Add JSON to input'"" 'if' 'key' '!=' ""''"" ':' 'x' '+=' '\' for key ""\''
 '+' 'key' '+' '\'""\'' 'x' '+=' ""' (double Enter to stop):\\n'"" 'rx' '='
 'input_json' '(' '{' ""'text'"" ':' 'x' '}' ')' 'if' 'rx' '[' ""'return'""
 ']' '>' '0' ':' 'return' 'rx' 'dy' '=' 'rx' '[' ""'dict'"" ']' 'dx' '='
 'obj' 'if' 'key' '!=' ""''"" ':' 'if' 'key' 'not' 'in' 'obj' ':' 'obj' '['
 'key' ']' '=' '{' '}' 'dx' '=' 'obj' '[' 'key' ']' 'merge_dicts' '(' '{'
 ""'dict1'"" ':' 'dx' ',' ""'dict2'"" ':' 'dy' '}' ')'
 '#####################################' 'elif' 'p' '.' 'startswith' '('
 '""@""' ')' ':' 'cx' '=' 'False' 'name' '=' 'p' '[' '1' ':' ']' 'if' 'len'
 '(' 'name' ')' '<' '2' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' ""'can\\'t parse command line option '"" '+' 'p' '}' 'y' '='
 'load_json_file' '(' '{' ""'json_file'"" ':' 'name' '}' ')' 'if' 'y' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'y' 'if' 'name' '.' 'endswith' '('
 ""'.tmp'"" ')' ':' 'os' '.' 'remove' '(' 'name' ')' 'merge_dicts' '(' '{'
 ""'dict1'"" ':' 'obj' ',' ""'dict2'"" ':' 'y' '[' ""'dict'"" ']' '}' ')'
 '#####################################' 'elif' 'p' '.' 'find' '(' ""'='""
 ')' '>=' '0' ':' 'cx' '=' 'False' 'p1' '=' 'p' 'p2' '=' ""''"" 'q' '=' 'p'
 '.' 'find' '(' '""=""' ')' 'if' 'q' '>' '0' ':' 'p1' '=' 'p' '[' '0' ':'
 'q' ']' 'if' 'len' '(' 'p' ')' '>' 'q' ':' 'p2' '=' 'p' '[' 'q' '+' '1'
 ':' ']' 'obj' '[' 'p1' ']' '=' 'p2'
 '#####################################' 'else' ':'
 '# If no module_uoa_or_cid -> set it' 'if' 'module_uoa_or_cid' '==' ""''""
 ':' 'module_uoa_or_cid' '=' 'p' 'else' ':' '# Otherwise add to CIDs'
 'obj' '[' ""'cids'"" ']' '.' 'append' '(' 'p' ')' 'if' 'module_uoa_or_cid'
 '!=' ""''"" ':' 'obj' '[' ""'cid'"" ']' '=' 'module_uoa_or_cid' 'return' '{'
 ""'return'"" ':' '0' ',' ""'ck_dict'"" ':' 'obj' '}']","Input:  [ 
              CK list: see 'action' function from this kernel
            ]

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              ck_dict      - {
                               ""action"":action
                               ""cid"":module_uoa or CID (x means that it may not be really CID 
                                       and has to be processed specially
                               ""cids"":[cid1, cid2, cid3, ...]
                               ""key1"":value1
                               ""key2"":value2
                               ...
                               ""key10"":""""
                               ""key11"":value11
                               keys/values from file_json; if file extension is .tmp, 
                                                           it will be deleted after read!
                               keys/values from cmd_json
                               ""unparsed"":unparsed_cmd
                             }","['Input' ':' '[' 'CK' 'list' ':' 'see' 'action' 'function' 'from' 'this'
 'kernel' ']']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2016-L2167
ctuning/ck,ck/kernel.py,init,"def init(i): # pragma: no cover
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    global cfg, work, initialized, paths_repos, type_long, string_io

    if initialized:
       return {'return':0}

    # Split version
    cfg['version']=__version__.split('.')

    # Default URL. FIXME: should be formed from wfe_host and wfe_port when they are known.
    # cfg['wfe_url_prefix'] = 'http://%s:%s/web?' % (cfg['default_host'], cfg['default_port'])

    # Check long/int types
    try:
       x=long
    except Exception as e:
       type_long=int
    else:
       type_long=long

    # Import StringIO
    if sys.version_info[0]>2:
       import io
       string_io=io.StringIO
    else:
       from StringIO import StringIO
       string_io=StringIO

    # Check where are repos (to keep compatibility with past CK < V1.5)
    p=''

    import inspect
    pxx=os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
    px=os.path.dirname(pxx)
    py=os.path.join(pxx, cfg['subdir_default_repo'])
    if os.path.isdir(py):
       p=py

    if p=='':
       from distutils.sysconfig import get_python_lib
       px=get_python_lib()
       py=os.path.join(px, cfg['kernel_dir'], cfg['subdir_default_repo'])
       if os.path.isdir(py):
          p=py

    if p=='':
       import site
       for px in site.getsitepackages():
           py=os.path.join(px, cfg['kernel_dir'],cfg['subdir_default_repo'])
           if os.path.isdir(py):
              p=py
              break

    # Check CK_ROOT environment variable
    s=os.environ.get(cfg['env_key_root'],'').strip()
    if s!='':
       work['env_root']=os.path.realpath(s)

       for px in cfg['kernel_dirs']:
           py=os.path.join(work['env_root'], px, cfg['subdir_default_repo'])
           if os.path.isdir(py):
              p=py
              break
    elif px!='':
      work['env_root']=px

    if p=='':
       return {'return':1, 'error':'Internal CK error (can\'t find default repo) - please report to authors'}

    # Check default repo
    work['dir_default_repo']=p
    work['dir_default_repo_path']=os.path.join(work['dir_default_repo'], cfg['module_repo_name'], cfg['repo_name_default'])
    work['dir_default_kernel']=os.path.join(work['dir_default_repo'], cfg['subdir_kernel'])
    work['dir_default_cfg']=os.path.join(work['dir_default_kernel'], cfg['subdir_kernel_default'], cfg['subdir_ck_ext'], cfg['file_meta'])

    work['dir_work_repo']=work['dir_default_repo']
    work['dir_work_repo_path']=work['dir_default_repo_path']
    work['dir_work_kernel']=work['dir_default_kernel']
    work['dir_work_cfg']=work['dir_default_cfg']

    work['repo_name_work']=cfg['repo_name_default']
    work['repo_uid_work']=cfg['repo_uid_default']

    # Check external repos
    rps=os.environ.get(cfg['env_key_repos'],'').strip()
    if rps=='': 
       # Get home user directory
       from os.path import expanduser
       home = expanduser(""~"")

       # In the original version, if path to repos was not defined, I was using CK path,
       # however, when installed as root, it will fail
       # rps=os.path.join(work['env_root'],cfg['subdir_default_repos'])
       # hence I changed to <user home dir>/CK
       rps=os.path.join(home, cfg['user_home_dir_ext'])
       if not os.path.isdir(rps):
          os.makedirs(rps)

    work['dir_repos']=rps

    # Check CK_LOCAL_REPO environment variable - if doesn't exist, create in user space
    s=os.environ.get(cfg['env_key_local_repo'],'').strip()

    if s=='':
       # Set up local default repository
       s=os.path.join(rps, cfg['repo_name_local'])
       if not os.path.isdir(s):
          os.makedirs(s)

          # Create description
          rq=save_json_to_file({'json_file':os.path.join(s,cfg['repo_file']),
                                'dict':{'data_alias':cfg['repo_name_local'],
                                        'data_uoa':cfg['repo_name_local'],
                                        'data_name':cfg['repo_name_local'],
                                        'data_uid':cfg['repo_uid_local']},
                                'sort_keys':'yes'})
          if rq['return']>0: return rq

    if s!='':
       work['local_kernel_uoa']=cfg['subdir_kernel_default']
       x=os.environ.get(cfg['env_key_local_kernel_uoa'],'').strip()
       if x!='': work['local_kernel_uoa']=x

       work['dir_local_repo']=os.path.realpath(s)
       work['dir_local_repo_path']=os.path.join(work['dir_local_repo'], cfg['module_repo_name'], cfg['repo_name_local'])
       work['dir_local_kernel']=os.path.join(work['dir_local_repo'], cfg['subdir_kernel'])
       work['dir_local_cfg']=os.path.join(work['dir_local_kernel'], work['local_kernel_uoa'], cfg['subdir_ck_ext'], cfg['file_meta'])

       # Update work repo!
       work['dir_work_repo']=work['dir_local_repo']
       work['dir_work_repo_path']=work['dir_local_repo_path']
       work['dir_work_kernel']=work['dir_local_kernel']
       work['dir_work_cfg']=work['dir_local_cfg']

       work['repo_name_work']=cfg['repo_name_local']
       work['repo_uid_work']=cfg['repo_uid_local']

       paths_repos.append({'path':work['dir_local_repo'],
                           'repo_uoa':cfg['repo_name_local'],
                           'repo_uid':cfg['repo_uid_local'],
                           'repo_alias':cfg['repo_name_local']})

    paths_repos.append({'path':work['dir_default_repo'],
                        'repo_uoa':cfg['repo_name_default'],
                        'repo_uid':cfg['repo_uid_default'],
                        'repo_alias':cfg['repo_name_default']})

    # Prepare repo cache
    work['dir_cache_repo_uoa']=os.path.join(work['dir_work_repo'],cfg['file_cache_repo_uoa'])
    work['dir_cache_repo_info']=os.path.join(work['dir_work_repo'],cfg['file_cache_repo_info'])

    # Check if first time and then copy local cache files (with remote-ck)
    if not os.path.isfile(work['dir_cache_repo_uoa']) and not os.path.isfile(work['dir_cache_repo_info']):
       rx=load_text_file({'text_file':os.path.join(work['dir_default_repo'],cfg['file_cache_repo_uoa'])})
       if rx['return']>0: return rx
       x1=rx['string']

       rx=load_text_file({'text_file':os.path.join(work['dir_default_repo'],cfg['file_cache_repo_info'])})
       if rx['return']>0: return rx
       x2=rx['string']

       rx=save_text_file({'text_file':work['dir_cache_repo_info'], 'string':x2})
       if rx['return']>0: return rx

       rx=save_text_file({'text_file':work['dir_cache_repo_uoa'], 'string':x1})
       if rx['return']>0: return rx

    # Check if local configuration exists, and if not, create it
    if not os.path.isfile(work['dir_local_cfg']):
       # Create empty local configuration
       rx=add({'repo_uoa':cfg['repo_name_local'],
               'module_uoa':cfg['subdir_kernel'],
               'data_uoa':work['local_kernel_uoa']})
       if rx['return']>0:
          return {'return':rx['return'],
                  'error':'can\'t create local configuration entry'}

    # Read kernel configuration (if exists)
    if os.path.isfile(work['dir_work_cfg']):
       r=load_json_file({'json_file':work['dir_work_cfg']})
       if r['return']>0: return r
       cfg1=r['dict']

       # Update cfg
       r=merge_dicts({'dict1':cfg, 'dict2':cfg1})
       if r['return']>0: return r

    initialized=True

    return {'return':0}",python,"def init(i): # pragma: no cover
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    global cfg, work, initialized, paths_repos, type_long, string_io

    if initialized:
       return {'return':0}

    # Split version
    cfg['version']=__version__.split('.')

    # Default URL. FIXME: should be formed from wfe_host and wfe_port when they are known.
    # cfg['wfe_url_prefix'] = 'http://%s:%s/web?' % (cfg['default_host'], cfg['default_port'])

    # Check long/int types
    try:
       x=long
    except Exception as e:
       type_long=int
    else:
       type_long=long

    # Import StringIO
    if sys.version_info[0]>2:
       import io
       string_io=io.StringIO
    else:
       from StringIO import StringIO
       string_io=StringIO

    # Check where are repos (to keep compatibility with past CK < V1.5)
    p=''

    import inspect
    pxx=os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
    px=os.path.dirname(pxx)
    py=os.path.join(pxx, cfg['subdir_default_repo'])
    if os.path.isdir(py):
       p=py

    if p=='':
       from distutils.sysconfig import get_python_lib
       px=get_python_lib()
       py=os.path.join(px, cfg['kernel_dir'], cfg['subdir_default_repo'])
       if os.path.isdir(py):
          p=py

    if p=='':
       import site
       for px in site.getsitepackages():
           py=os.path.join(px, cfg['kernel_dir'],cfg['subdir_default_repo'])
           if os.path.isdir(py):
              p=py
              break

    # Check CK_ROOT environment variable
    s=os.environ.get(cfg['env_key_root'],'').strip()
    if s!='':
       work['env_root']=os.path.realpath(s)

       for px in cfg['kernel_dirs']:
           py=os.path.join(work['env_root'], px, cfg['subdir_default_repo'])
           if os.path.isdir(py):
              p=py
              break
    elif px!='':
      work['env_root']=px

    if p=='':
       return {'return':1, 'error':'Internal CK error (can\'t find default repo) - please report to authors'}

    # Check default repo
    work['dir_default_repo']=p
    work['dir_default_repo_path']=os.path.join(work['dir_default_repo'], cfg['module_repo_name'], cfg['repo_name_default'])
    work['dir_default_kernel']=os.path.join(work['dir_default_repo'], cfg['subdir_kernel'])
    work['dir_default_cfg']=os.path.join(work['dir_default_kernel'], cfg['subdir_kernel_default'], cfg['subdir_ck_ext'], cfg['file_meta'])

    work['dir_work_repo']=work['dir_default_repo']
    work['dir_work_repo_path']=work['dir_default_repo_path']
    work['dir_work_kernel']=work['dir_default_kernel']
    work['dir_work_cfg']=work['dir_default_cfg']

    work['repo_name_work']=cfg['repo_name_default']
    work['repo_uid_work']=cfg['repo_uid_default']

    # Check external repos
    rps=os.environ.get(cfg['env_key_repos'],'').strip()
    if rps=='': 
       # Get home user directory
       from os.path import expanduser
       home = expanduser(""~"")

       # In the original version, if path to repos was not defined, I was using CK path,
       # however, when installed as root, it will fail
       # rps=os.path.join(work['env_root'],cfg['subdir_default_repos'])
       # hence I changed to <user home dir>/CK
       rps=os.path.join(home, cfg['user_home_dir_ext'])
       if not os.path.isdir(rps):
          os.makedirs(rps)

    work['dir_repos']=rps

    # Check CK_LOCAL_REPO environment variable - if doesn't exist, create in user space
    s=os.environ.get(cfg['env_key_local_repo'],'').strip()

    if s=='':
       # Set up local default repository
       s=os.path.join(rps, cfg['repo_name_local'])
       if not os.path.isdir(s):
          os.makedirs(s)

          # Create description
          rq=save_json_to_file({'json_file':os.path.join(s,cfg['repo_file']),
                                'dict':{'data_alias':cfg['repo_name_local'],
                                        'data_uoa':cfg['repo_name_local'],
                                        'data_name':cfg['repo_name_local'],
                                        'data_uid':cfg['repo_uid_local']},
                                'sort_keys':'yes'})
          if rq['return']>0: return rq

    if s!='':
       work['local_kernel_uoa']=cfg['subdir_kernel_default']
       x=os.environ.get(cfg['env_key_local_kernel_uoa'],'').strip()
       if x!='': work['local_kernel_uoa']=x

       work['dir_local_repo']=os.path.realpath(s)
       work['dir_local_repo_path']=os.path.join(work['dir_local_repo'], cfg['module_repo_name'], cfg['repo_name_local'])
       work['dir_local_kernel']=os.path.join(work['dir_local_repo'], cfg['subdir_kernel'])
       work['dir_local_cfg']=os.path.join(work['dir_local_kernel'], work['local_kernel_uoa'], cfg['subdir_ck_ext'], cfg['file_meta'])

       # Update work repo!
       work['dir_work_repo']=work['dir_local_repo']
       work['dir_work_repo_path']=work['dir_local_repo_path']
       work['dir_work_kernel']=work['dir_local_kernel']
       work['dir_work_cfg']=work['dir_local_cfg']

       work['repo_name_work']=cfg['repo_name_local']
       work['repo_uid_work']=cfg['repo_uid_local']

       paths_repos.append({'path':work['dir_local_repo'],
                           'repo_uoa':cfg['repo_name_local'],
                           'repo_uid':cfg['repo_uid_local'],
                           'repo_alias':cfg['repo_name_local']})

    paths_repos.append({'path':work['dir_default_repo'],
                        'repo_uoa':cfg['repo_name_default'],
                        'repo_uid':cfg['repo_uid_default'],
                        'repo_alias':cfg['repo_name_default']})

    # Prepare repo cache
    work['dir_cache_repo_uoa']=os.path.join(work['dir_work_repo'],cfg['file_cache_repo_uoa'])
    work['dir_cache_repo_info']=os.path.join(work['dir_work_repo'],cfg['file_cache_repo_info'])

    # Check if first time and then copy local cache files (with remote-ck)
    if not os.path.isfile(work['dir_cache_repo_uoa']) and not os.path.isfile(work['dir_cache_repo_info']):
       rx=load_text_file({'text_file':os.path.join(work['dir_default_repo'],cfg['file_cache_repo_uoa'])})
       if rx['return']>0: return rx
       x1=rx['string']

       rx=load_text_file({'text_file':os.path.join(work['dir_default_repo'],cfg['file_cache_repo_info'])})
       if rx['return']>0: return rx
       x2=rx['string']

       rx=save_text_file({'text_file':work['dir_cache_repo_info'], 'string':x2})
       if rx['return']>0: return rx

       rx=save_text_file({'text_file':work['dir_cache_repo_uoa'], 'string':x1})
       if rx['return']>0: return rx

    # Check if local configuration exists, and if not, create it
    if not os.path.isfile(work['dir_local_cfg']):
       # Create empty local configuration
       rx=add({'repo_uoa':cfg['repo_name_local'],
               'module_uoa':cfg['subdir_kernel'],
               'data_uoa':work['local_kernel_uoa']})
       if rx['return']>0:
          return {'return':rx['return'],
                  'error':'can\'t create local configuration entry'}

    # Read kernel configuration (if exists)
    if os.path.isfile(work['dir_work_cfg']):
       r=load_json_file({'json_file':work['dir_work_cfg']})
       if r['return']>0: return r
       cfg1=r['dict']

       # Update cfg
       r=merge_dicts({'dict1':cfg, 'dict2':cfg1})
       if r['return']>0: return r

    initialized=True

    return {'return':0}",['def' 'init' '(' ... ':' '0' '}'],"Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2174-L2373
ctuning/ck,ck/kernel.py,list_all_files,"def list_all_files(i):
    """"""
    Input:  {
              path               - top level path
              (file_name)        - search for a specific file name
              (pattern)          - return only files with this pattern
              (path_ext)         - path extension (needed for recursion)
              (limit)            - limit number of files (if directories with a large number of files)
              (number)           - current number of files
              (all)              - if 'yes' do not ignore special directories (like .cm)
              (ignore_names)     - list of names to ignore
              (ignore_symb_dirs) - if 'yes', ignore symbolically linked dirs 
                                   (to avoid recursion such as in LLVM)
              (add_path)         - if 'yes', add path
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              list         - dictionary of all files:
                               {""file_with_full_path"":{""size"":.., ""path"":..}
              sizes        - sizes of files (the same order)
              number       - number of files in a current directory (needed for recursion)
            }
    """"""

    number=0
    if i.get('number','')!='': 
       number=int(i['number'])

    inames=i.get('ignore_names',[])

    fname=i.get('file_name','')

    limit=-1
    if i.get('limit','')!='': 
       limit=int(i['limit'])

    a={} 

    iall=i.get('all','')

    pe=''
    if i.get('path_ext','')!='': 
       pe=i['path_ext']

    po=i.get('path','')
    if sys.version_info[0]<3: po=unicode(po)

    pattern=i.get('pattern','')
    if pattern!='':
       import fnmatch

    xisd=i.get('ignore_symb_dirs','')
    isd=False
    if xisd=='yes': isd=True

    ap=i.get('add_path','')

    try:
       dirList=os.listdir(po)
    except Exception as e:
        None
    else:
        for fn in dirList:
            p=os.path.join(po, fn)
            if iall=='yes' or fn not in cfg['special_directories']:
               if len(inames)==0 or fn not in inames:
                  if os.path.isdir(p):
                     if not isd or os.path.realpath(p)==p:
                        r=list_all_files({'path':p, 'all':iall, 'path_ext':os.path.join(pe, fn),
                                          'number':str(number), 'ignore_names':inames, 'pattern':pattern,
                                          'file_name':fname, 'ignore_symb_dirs':xisd, 'add_path':ap, 'limit': limit})
                        if r['return']>0: return r
                        a.update(r['list'])
                  else:
                     add=True

                     if fname!='' and fname!=fn:
                        add=False

                     if pattern!='' and not fnmatch.fnmatch(fn, pattern):
                        add=False

                     if add:
                        pg=os.path.join(pe, fn)
                        if os.path.isfile(p):
                           a[pg]={'size':os.stat(p).st_size}

                           if ap=='yes': a[pg]['path']=po

                  number=len(a)
                  if limit!=-1 and number>=limit:
                     break

    return {'return':0, 'list':a, 'number':str(number)}",python,"def list_all_files(i):
    """"""
    Input:  {
              path               - top level path
              (file_name)        - search for a specific file name
              (pattern)          - return only files with this pattern
              (path_ext)         - path extension (needed for recursion)
              (limit)            - limit number of files (if directories with a large number of files)
              (number)           - current number of files
              (all)              - if 'yes' do not ignore special directories (like .cm)
              (ignore_names)     - list of names to ignore
              (ignore_symb_dirs) - if 'yes', ignore symbolically linked dirs 
                                   (to avoid recursion such as in LLVM)
              (add_path)         - if 'yes', add path
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              list         - dictionary of all files:
                               {""file_with_full_path"":{""size"":.., ""path"":..}
              sizes        - sizes of files (the same order)
              number       - number of files in a current directory (needed for recursion)
            }
    """"""

    number=0
    if i.get('number','')!='': 
       number=int(i['number'])

    inames=i.get('ignore_names',[])

    fname=i.get('file_name','')

    limit=-1
    if i.get('limit','')!='': 
       limit=int(i['limit'])

    a={} 

    iall=i.get('all','')

    pe=''
    if i.get('path_ext','')!='': 
       pe=i['path_ext']

    po=i.get('path','')
    if sys.version_info[0]<3: po=unicode(po)

    pattern=i.get('pattern','')
    if pattern!='':
       import fnmatch

    xisd=i.get('ignore_symb_dirs','')
    isd=False
    if xisd=='yes': isd=True

    ap=i.get('add_path','')

    try:
       dirList=os.listdir(po)
    except Exception as e:
        None
    else:
        for fn in dirList:
            p=os.path.join(po, fn)
            if iall=='yes' or fn not in cfg['special_directories']:
               if len(inames)==0 or fn not in inames:
                  if os.path.isdir(p):
                     if not isd or os.path.realpath(p)==p:
                        r=list_all_files({'path':p, 'all':iall, 'path_ext':os.path.join(pe, fn),
                                          'number':str(number), 'ignore_names':inames, 'pattern':pattern,
                                          'file_name':fname, 'ignore_symb_dirs':xisd, 'add_path':ap, 'limit': limit})
                        if r['return']>0: return r
                        a.update(r['list'])
                  else:
                     add=True

                     if fname!='' and fname!=fn:
                        add=False

                     if pattern!='' and not fnmatch.fnmatch(fn, pattern):
                        add=False

                     if add:
                        pg=os.path.join(pe, fn)
                        if os.path.isfile(p):
                           a[pg]={'size':os.stat(p).st_size}

                           if ap=='yes': a[pg]['path']=po

                  number=len(a)
                  if limit!=-1 and number>=limit:
                     break

    return {'return':0, 'list':a, 'number':str(number)}","['def' 'list_all_files' '(' 'i' ')' ':' 'number' '=' '0' 'if' 'i' '.'
 'get' '(' ""'number'"" ',' ""''"" ')' '!=' ""''"" ':' 'number' '=' 'int' '('
 'i' '[' ""'number'"" ']' ')' 'inames' '=' 'i' '.' 'get' '('
 ""'ignore_names'"" ',' '[' ']' ')' 'fname' '=' 'i' '.' 'get' '('
 ""'file_name'"" ',' ""''"" ')' 'limit' '=' '-' '1' 'if' 'i' '.' 'get' '('
 ""'limit'"" ',' ""''"" ')' '!=' ""''"" ':' 'limit' '=' 'int' '(' 'i' '['
 ""'limit'"" ']' ')' 'a' '=' '{' '}' 'iall' '=' 'i' '.' 'get' '(' ""'all'""
 ',' ""''"" ')' 'pe' '=' ""''"" 'if' 'i' '.' 'get' '(' ""'path_ext'"" ',' ""''""
 ')' '!=' ""''"" ':' 'pe' '=' 'i' '[' ""'path_ext'"" ']' 'po' '=' 'i' '.'
 'get' '(' ""'path'"" ',' ""''"" ')' 'if' 'sys' '.' 'version_info' '[' '0' ']'
 '<' '3' ':' 'po' '=' 'unicode' '(' 'po' ')' 'pattern' '=' 'i' '.' 'get'
 '(' ""'pattern'"" ',' ""''"" ')' 'if' 'pattern' '!=' ""''"" ':' 'import'
 'fnmatch' 'xisd' '=' 'i' '.' 'get' '(' ""'ignore_symb_dirs'"" ',' ""''"" ')'
 'isd' '=' 'False' 'if' 'xisd' '==' ""'yes'"" ':' 'isd' '=' 'True' 'ap' '='
 'i' '.' 'get' '(' ""'add_path'"" ',' ""''"" ')' 'try' ':' 'dirList' '=' 'os'
 '.' 'listdir' '(' 'po' ')' 'except' 'Exception' 'as' 'e' ':' 'None'
 'else' ':' 'for' 'fn' 'in' 'dirList' ':' 'p' '=' 'os' '.' 'path' '.'
 'join' '(' 'po' ',' 'fn' ')' 'if' 'iall' '==' ""'yes'"" 'or' 'fn' 'not'
 'in' 'cfg' '[' ""'special_directories'"" ']' ':' 'if' 'len' '(' 'inames'
 ')' '==' '0' 'or' 'fn' 'not' 'in' 'inames' ':' 'if' 'os' '.' 'path' '.'
 'isdir' '(' 'p' ')' ':' 'if' 'not' 'isd' 'or' 'os' '.' 'path' '.'
 'realpath' '(' 'p' ')' '==' 'p' ':' 'r' '=' 'list_all_files' '(' '{'
 ""'path'"" ':' 'p' ',' ""'all'"" ':' 'iall' ',' ""'path_ext'"" ':' 'os' '.'
 'path' '.' 'join' '(' 'pe' ',' 'fn' ')' ',' ""'number'"" ':' 'str' '('
 'number' ')' ',' ""'ignore_names'"" ':' 'inames' ',' ""'pattern'"" ':'
 'pattern' ',' ""'file_name'"" ':' 'fname' ',' ""'ignore_symb_dirs'"" ':'
 'xisd' ',' ""'add_path'"" ':' 'ap' ',' ""'limit'"" ':' 'limit' '}' ')' 'if'
 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'a' '.' 'update' '(' 'r'
 '[' ""'list'"" ']' ')' 'else' ':' 'add' '=' 'True' 'if' 'fname' '!=' ""''""
 'and' 'fname' '!=' 'fn' ':' 'add' '=' 'False' 'if' 'pattern' '!=' ""''""
 'and' 'not' 'fnmatch' '.' 'fnmatch' '(' 'fn' ',' 'pattern' ')' ':' 'add'
 '=' 'False' 'if' 'add' ':' 'pg' '=' 'os' '.' 'path' '.' 'join' '(' 'pe'
 ',' 'fn' ')' 'if' 'os' '.' 'path' '.' 'isfile' '(' 'p' ')' ':' 'a' '['
 'pg' ']' '=' '{' ""'size'"" ':' 'os' '.' 'stat' '(' 'p' ')' '.' 'st_size'
 '}' 'if' 'ap' '==' ""'yes'"" ':' 'a' '[' 'pg' ']' '[' ""'path'"" ']' '=' 'po'
 'number' '=' 'len' '(' 'a' ')' 'if' 'limit' '!=' '-' '1' 'and' 'number'
 '>=' 'limit' ':' 'break' 'return' '{' ""'return'"" ':' '0' ',' ""'list'"" ':'
 'a' ',' ""'number'"" ':' 'str' '(' 'number' ')' '}']","Input:  {
              path               - top level path
              (file_name)        - search for a specific file name
              (pattern)          - return only files with this pattern
              (path_ext)         - path extension (needed for recursion)
              (limit)            - limit number of files (if directories with a large number of files)
              (number)           - current number of files
              (all)              - if 'yes' do not ignore special directories (like .cm)
              (ignore_names)     - list of names to ignore
              (ignore_symb_dirs) - if 'yes', ignore symbolically linked dirs 
                                   (to avoid recursion such as in LLVM)
              (add_path)         - if 'yes', add path
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              list         - dictionary of all files:
                               {""file_with_full_path"":{""size"":.., ""path"":..}
              sizes        - sizes of files (the same order)
              number       - number of files in a current directory (needed for recursion)
            }","['Input' ':' '{' 'path' '-' 'top' 'level' 'path' '(' 'file_name' ')' '-'
 'search' 'for' 'a' 'specific' 'file' 'name' '(' 'pattern' ')' '-'
 'return' 'only' 'files' 'with' 'this' 'pattern' '(' 'path_ext' ')' '-'
 'path' 'extension' '(' 'needed' 'for' 'recursion' ')' '(' 'limit' ')' '-'
 'limit' 'number' 'of' 'files' '(' 'if' 'directories' 'with' 'a' 'large'
 'number' 'of' 'files' ')' '(' 'number' ')' '-' 'current' 'number' 'of'
 'files' '(' 'all' ')' '-' 'if' 'yes' 'do' 'not' 'ignore' 'special'
 'directories' '(' 'like' '.' 'cm' ')' '(' 'ignore_names' ')' '-' 'list'
 'of' 'names' 'to' 'ignore' '(' 'ignore_symb_dirs' ')' '-' 'if' 'yes'
 'ignore' 'symbolically' 'linked' 'dirs' '(' 'to' 'avoid' 'recursion'
 'such' 'as' 'in' 'LLVM' ')' '(' 'add_path' ')' '-' 'if' 'yes' 'add'
 'path' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2380-L2477
ctuning/ck,ck/kernel.py,reload_repo_cache,"def reload_repo_cache(i):
    """"""
    Input:  {
              (force)      - if 'yes', force recaching
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    global cache_repo_uoa, cache_repo_info, paths_repos_all, cache_repo_init

    if i.get('force','')=='yes': # pragma: no cover
       cache_repo_init=False
       paths_repos_all=[]

    if not cache_repo_init:
       # Load repo UOA -> UID disambiguator
       r=load_json_file({'json_file':work['dir_cache_repo_uoa']})
       if r['return']!=16 and r['return']>0: return r
       cache_repo_uoa=r.get('dict',{})

       # Load cached repo info
       r=load_json_file({'json_file':work['dir_cache_repo_info']})
       if r['return']!=16 and r['return']>0: return r
       cache_repo_info=r.get('dict',{})

       # Prepare all paths
       for q in cache_repo_info:
           qq=cache_repo_info[q]
           dd=qq['dict']
           p=dd.get('path','')
           if p!='':
              paths_repos_all.append({'path':os.path.normpath(p),
                                      'repo_uoa':qq['data_uoa'],
                                      'repo_uid':qq['data_uid'],
                                      'repo_alias':qq['data_alias']})

    cache_repo_init=True

    return {'return':0}",python,"def reload_repo_cache(i):
    """"""
    Input:  {
              (force)      - if 'yes', force recaching
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    global cache_repo_uoa, cache_repo_info, paths_repos_all, cache_repo_init

    if i.get('force','')=='yes': # pragma: no cover
       cache_repo_init=False
       paths_repos_all=[]

    if not cache_repo_init:
       # Load repo UOA -> UID disambiguator
       r=load_json_file({'json_file':work['dir_cache_repo_uoa']})
       if r['return']!=16 and r['return']>0: return r
       cache_repo_uoa=r.get('dict',{})

       # Load cached repo info
       r=load_json_file({'json_file':work['dir_cache_repo_info']})
       if r['return']!=16 and r['return']>0: return r
       cache_repo_info=r.get('dict',{})

       # Prepare all paths
       for q in cache_repo_info:
           qq=cache_repo_info[q]
           dd=qq['dict']
           p=dd.get('path','')
           if p!='':
              paths_repos_all.append({'path':os.path.normpath(p),
                                      'repo_uoa':qq['data_uoa'],
                                      'repo_uid':qq['data_uid'],
                                      'repo_alias':qq['data_alias']})

    cache_repo_init=True

    return {'return':0}","['def' 'reload_repo_cache' '(' 'i' ')' ':' 'global' 'cache_repo_uoa' ','
 'cache_repo_info' ',' 'paths_repos_all' ',' 'cache_repo_init' 'if' 'i'
 '.' 'get' '(' ""'force'"" ',' ""''"" ')' '==' ""'yes'"" ':'
 '# pragma: no cover' 'cache_repo_init' '=' 'False' 'paths_repos_all' '='
 '[' ']' 'if' 'not' 'cache_repo_init' ':'
 '# Load repo UOA -> UID disambiguator' 'r' '=' 'load_json_file' '(' '{'
 ""'json_file'"" ':' 'work' '[' ""'dir_cache_repo_uoa'"" ']' '}' ')' 'if' 'r'
 '[' ""'return'"" ']' '!=' '16' 'and' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'cache_repo_uoa' '=' 'r' '.' 'get' '(' ""'dict'"" ',' '{' '}'
 ')' '# Load cached repo info' 'r' '=' 'load_json_file' '(' '{'
 ""'json_file'"" ':' 'work' '[' ""'dir_cache_repo_info'"" ']' '}' ')' 'if' 'r'
 '[' ""'return'"" ']' '!=' '16' 'and' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'cache_repo_info' '=' 'r' '.' 'get' '(' ""'dict'"" ',' '{' '}'
 ')' '# Prepare all paths' 'for' 'q' 'in' 'cache_repo_info' ':' 'qq' '='
 'cache_repo_info' '[' 'q' ']' 'dd' '=' 'qq' '[' ""'dict'"" ']' 'p' '=' 'dd'
 '.' 'get' '(' ""'path'"" ',' ""''"" ')' 'if' 'p' '!=' ""''"" ':'
 'paths_repos_all' '.' 'append' '(' '{' ""'path'"" ':' 'os' '.' 'path' '.'
 'normpath' '(' 'p' ')' ',' ""'repo_uoa'"" ':' 'qq' '[' ""'data_uoa'"" ']' ','
 ""'repo_uid'"" ':' 'qq' '[' ""'data_uid'"" ']' ',' ""'repo_alias'"" ':' 'qq'
 '[' ""'data_alias'"" ']' '}' ')' 'cache_repo_init' '=' 'True' 'return' '{'
 ""'return'"" ':' '0' '}']","Input:  {
              (force)      - if 'yes', force recaching
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' '(' 'force' ')' '-' 'if' 'yes' 'force' 'recaching' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2484-L2527
ctuning/ck,ck/kernel.py,save_repo_cache,"def save_repo_cache(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    r=save_json_to_file({'json_file':work['dir_cache_repo_uoa'], 'dict':cache_repo_uoa})
    if r['return']>0: return r

    r=save_json_to_file({'json_file':work['dir_cache_repo_info'], 'dict':cache_repo_info})
    if r['return']>0: return r

    return {'return':0}",python,"def save_repo_cache(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    r=save_json_to_file({'json_file':work['dir_cache_repo_uoa'], 'dict':cache_repo_uoa})
    if r['return']>0: return r

    r=save_json_to_file({'json_file':work['dir_cache_repo_info'], 'dict':cache_repo_info})
    if r['return']>0: return r

    return {'return':0}","['def' 'save_repo_cache' '(' 'i' ')' ':' 'r' '=' 'save_json_to_file' '('
 '{' ""'json_file'"" ':' 'work' '[' ""'dir_cache_repo_uoa'"" ']' ',' ""'dict'""
 ':' 'cache_repo_uoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'r' '=' 'save_json_to_file' '(' '{' ""'json_file'"" ':' 'work'
 '[' ""'dir_cache_repo_info'"" ']' ',' ""'dict'"" ':' 'cache_repo_info' '}'
 ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'return' '{'
 ""'return'"" ':' '0' '}']","Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2534-L2551
ctuning/ck,ck/kernel.py,load_repo_info_from_cache,"def load_repo_info_from_cache(i):
    """"""
    Input:  {
              repo_uoa - repo_uoa
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if repo not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              repo_uoa     - repo UOA
              repo_uid     - repo UID
              repo_alias   - repo alias

              all other info from repo dict
            }
    """"""

    ruoa=i['repo_uoa']
    ruid=ruoa

    if ruoa==cfg['repo_name_default'] or ruoa==cfg['repo_uid_default']:
       d={}
       d[""path_to_repo_desc""]=work['dir_default_repo_path']
       d[""data_uid""]=cfg['repo_uid_default']
       d[""data_alias""]=cfg['repo_name_default']
       d[""data_uoa""]=cfg['repo_name_default']
       d[""dict""]={""default"":""yes""}
    elif ruoa==cfg['repo_name_local'] or ruoa==cfg['repo_uid_local']:
       d={}
       d[""path_to_repo_desc""]=work['dir_local_repo_path']
       d[""data_uid""]=cfg['repo_uid_local']
       d[""data_alias""]=cfg['repo_name_local']
       d[""data_uoa""]=cfg['repo_name_local']
       d[""dict""]={""default"":""yes""}
    else:
       r=reload_repo_cache({}) # Ignore errors
       if r['return']>0: return r

       if not is_uid(ruoa): 
          ruid=cache_repo_uoa.get(ruoa,'')
          if ruid=='':
             return {'return':1, 'error':'repository ""'+ruoa+'"" is not found in the cache. Check if repository exists or try ""ck recache repo""'}

       d=cache_repo_info.get(ruid,{})
       if len(d)==0:
          return {'return':1, 'error':'repository is not found in the cache'}

    r={'return':0}
    r.update(d)

    return r",python,"def load_repo_info_from_cache(i):
    """"""
    Input:  {
              repo_uoa - repo_uoa
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if repo not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              repo_uoa     - repo UOA
              repo_uid     - repo UID
              repo_alias   - repo alias

              all other info from repo dict
            }
    """"""

    ruoa=i['repo_uoa']
    ruid=ruoa

    if ruoa==cfg['repo_name_default'] or ruoa==cfg['repo_uid_default']:
       d={}
       d[""path_to_repo_desc""]=work['dir_default_repo_path']
       d[""data_uid""]=cfg['repo_uid_default']
       d[""data_alias""]=cfg['repo_name_default']
       d[""data_uoa""]=cfg['repo_name_default']
       d[""dict""]={""default"":""yes""}
    elif ruoa==cfg['repo_name_local'] or ruoa==cfg['repo_uid_local']:
       d={}
       d[""path_to_repo_desc""]=work['dir_local_repo_path']
       d[""data_uid""]=cfg['repo_uid_local']
       d[""data_alias""]=cfg['repo_name_local']
       d[""data_uoa""]=cfg['repo_name_local']
       d[""dict""]={""default"":""yes""}
    else:
       r=reload_repo_cache({}) # Ignore errors
       if r['return']>0: return r

       if not is_uid(ruoa): 
          ruid=cache_repo_uoa.get(ruoa,'')
          if ruid=='':
             return {'return':1, 'error':'repository ""'+ruoa+'"" is not found in the cache. Check if repository exists or try ""ck recache repo""'}

       d=cache_repo_info.get(ruid,{})
       if len(d)==0:
          return {'return':1, 'error':'repository is not found in the cache'}

    r={'return':0}
    r.update(d)

    return r","['def' 'load_repo_info_from_cache' '(' 'i' ')' ':' 'ruoa' '=' 'i' '['
 ""'repo_uoa'"" ']' 'ruid' '=' 'ruoa' 'if' 'ruoa' '==' 'cfg' '['
 ""'repo_name_default'"" ']' 'or' 'ruoa' '==' 'cfg' '[' ""'repo_uid_default'""
 ']' ':' 'd' '=' '{' '}' 'd' '[' '""path_to_repo_desc""' ']' '=' 'work' '['
 ""'dir_default_repo_path'"" ']' 'd' '[' '""data_uid""' ']' '=' 'cfg' '['
 ""'repo_uid_default'"" ']' 'd' '[' '""data_alias""' ']' '=' 'cfg' '['
 ""'repo_name_default'"" ']' 'd' '[' '""data_uoa""' ']' '=' 'cfg' '['
 ""'repo_name_default'"" ']' 'd' '[' '""dict""' ']' '=' '{' '""default""' ':'
 '""yes""' '}' 'elif' 'ruoa' '==' 'cfg' '[' ""'repo_name_local'"" ']' 'or'
 'ruoa' '==' 'cfg' '[' ""'repo_uid_local'"" ']' ':' 'd' '=' '{' '}' 'd' '['
 '""path_to_repo_desc""' ']' '=' 'work' '[' ""'dir_local_repo_path'"" ']' 'd'
 '[' '""data_uid""' ']' '=' 'cfg' '[' ""'repo_uid_local'"" ']' 'd' '['
 '""data_alias""' ']' '=' 'cfg' '[' ""'repo_name_local'"" ']' 'd' '['
 '""data_uoa""' ']' '=' 'cfg' '[' ""'repo_name_local'"" ']' 'd' '[' '""dict""'
 ']' '=' '{' '""default""' ':' '""yes""' '}' 'else' ':' 'r' '='
 'reload_repo_cache' '(' '{' '}' ')' '# Ignore errors' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'if' 'not' 'is_uid' '(' 'ruoa'
 ')' ':' 'ruid' '=' 'cache_repo_uoa' '.' 'get' '(' 'ruoa' ',' ""''"" ')'
 'if' 'ruid' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' '\'repository ""\'' '+' 'ruoa' '+'
 '\'"" is not found in the cache. Check if repository exists or try ""ck recache repo""\''
 '}' 'd' '=' 'cache_repo_info' '.' 'get' '(' 'ruid' ',' '{' '}' ')' 'if'
 'len' '(' 'd' ')' '==' '0' ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'repository is not found in the cache'"" '}' 'r' '=' '{'
 ""'return'"" ':' '0' '}' 'r' '.' 'update' '(' 'd' ')' 'return' 'r']","Input:  {
              repo_uoa - repo_uoa
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if repo not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              repo_uoa     - repo UOA
              repo_uid     - repo UID
              repo_alias   - repo alias

              all other info from repo dict
            }",['Input' ':' '{' 'repo_uoa' '-' 'repo_uoa' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2558-L2611
ctuning/ck,ck/kernel.py,find_repo_by_path,"def find_repo_by_path(i):
    """"""
    Input:  {
              path - path to repo
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if repo not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              repo_uoa     - repo UOA
              repo_uid     - repo UID
              repo_alias   - repo alias
            }
    """"""

    p=i['path']
    if p!='': p=os.path.normpath(p)

    found=False
    if p==work['dir_default_repo']:
       uoa=cfg['repo_name_default']
       uid=cfg['repo_uid_default']
       alias=uoa
       found=True
    elif p==work['dir_local_repo']:
       uoa=cfg['repo_name_local']
       uid=cfg['repo_uid_local']
       alias=uoa
       found=True
    else:
       r=reload_repo_cache({}) # Ignore errors
       if r['return']>0: return r

       for q in cache_repo_info:
           qq=cache_repo_info[q]
           if p==qq['dict'].get('path',''):
              uoa=qq['data_uoa']
              uid=qq['data_uid']
              alias=uid
              if not is_uid(uoa): alias=uoa
              found=True
              break

    if not found:
       return {'return':16, 'error': 'repository not found in this path'}

    return {'return':0, 'repo_uoa': uoa, 'repo_uid': uid, 'repo_alias':alias}",python,"def find_repo_by_path(i):
    """"""
    Input:  {
              path - path to repo
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if repo not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              repo_uoa     - repo UOA
              repo_uid     - repo UID
              repo_alias   - repo alias
            }
    """"""

    p=i['path']
    if p!='': p=os.path.normpath(p)

    found=False
    if p==work['dir_default_repo']:
       uoa=cfg['repo_name_default']
       uid=cfg['repo_uid_default']
       alias=uoa
       found=True
    elif p==work['dir_local_repo']:
       uoa=cfg['repo_name_local']
       uid=cfg['repo_uid_local']
       alias=uoa
       found=True
    else:
       r=reload_repo_cache({}) # Ignore errors
       if r['return']>0: return r

       for q in cache_repo_info:
           qq=cache_repo_info[q]
           if p==qq['dict'].get('path',''):
              uoa=qq['data_uoa']
              uid=qq['data_uid']
              alias=uid
              if not is_uid(uoa): alias=uoa
              found=True
              break

    if not found:
       return {'return':16, 'error': 'repository not found in this path'}

    return {'return':0, 'repo_uoa': uoa, 'repo_uid': uid, 'repo_alias':alias}","['def' 'find_repo_by_path' '(' 'i' ')' ':' 'p' '=' 'i' '[' ""'path'"" ']'
 'if' 'p' '!=' ""''"" ':' 'p' '=' 'os' '.' 'path' '.' 'normpath' '(' 'p' ')'
 'found' '=' 'False' 'if' 'p' '==' 'work' '[' ""'dir_default_repo'"" ']' ':'
 'uoa' '=' 'cfg' '[' ""'repo_name_default'"" ']' 'uid' '=' 'cfg' '['
 ""'repo_uid_default'"" ']' 'alias' '=' 'uoa' 'found' '=' 'True' 'elif' 'p'
 '==' 'work' '[' ""'dir_local_repo'"" ']' ':' 'uoa' '=' 'cfg' '['
 ""'repo_name_local'"" ']' 'uid' '=' 'cfg' '[' ""'repo_uid_local'"" ']'
 'alias' '=' 'uoa' 'found' '=' 'True' 'else' ':' 'r' '='
 'reload_repo_cache' '(' '{' '}' ')' '# Ignore errors' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'for' 'q' 'in' 'cache_repo_info'
 ':' 'qq' '=' 'cache_repo_info' '[' 'q' ']' 'if' 'p' '==' 'qq' '['
 ""'dict'"" ']' '.' 'get' '(' ""'path'"" ',' ""''"" ')' ':' 'uoa' '=' 'qq' '['
 ""'data_uoa'"" ']' 'uid' '=' 'qq' '[' ""'data_uid'"" ']' 'alias' '=' 'uid'
 'if' 'not' 'is_uid' '(' 'uoa' ')' ':' 'alias' '=' 'uoa' 'found' '='
 'True' 'break' 'if' 'not' 'found' ':' 'return' '{' ""'return'"" ':' '16'
 ',' ""'error'"" ':' ""'repository not found in this path'"" '}' 'return' '{'
 ""'return'"" ':' '0' ',' ""'repo_uoa'"" ':' 'uoa' ',' ""'repo_uid'"" ':' 'uid'
 ',' ""'repo_alias'"" ':' 'alias' '}']","Input:  {
              path - path to repo
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if repo not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              repo_uoa     - repo UOA
              repo_uid     - repo UID
              repo_alias   - repo alias
            }",['Input' ':' '{' 'path' '-' 'path' 'to' 'repo' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2618-L2667
ctuning/ck,ck/kernel.py,find_path_to_repo,"def find_path_to_repo(i):
    """"""
    Input:  {
              (repo_uoa) - repo UOA; if empty, get the default repo
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if repo not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - dict from cache
              path         - path to repo

              repo_uoa     - repo UOA
              repo_uid     - repo UID
              repo_alias   - repo alias
            }
    """"""

    a=i.get('repo_uoa','')
    ai=a

    pr=''
    if a!='':
       if a==cfg['repo_name_default'] or a==cfg['repo_uid_default']:
          pr=work['dir_default_repo']
          uoa=cfg['repo_name_default']
          uid=cfg['repo_uid_default']
          alias=uoa
          dt={}
       elif a==cfg['repo_name_local'] or a==cfg['repo_uid_local']:
          pr=work['dir_local_repo']
          uoa=cfg['repo_name_local']
          uid=cfg['repo_uid_local']
          alias=uoa
          dt={}
       else:
          # Reload cache if not initialized
          r=reload_repo_cache({}) # Ignore errors
          if r['return']>0: return r

          if not is_uid(a):
             ai=cache_repo_uoa.get(a,'')
             if ai=='':
                return {'return':1, 'error':'repository ""'+a+'"" was not found in cache'}

          cri=cache_repo_info.get(ai, {})
          if len(cri)==0:
             return {'return':1, 'error':'repository ""'+ai+'"" was not found in cache'}

          dt=cri.get('dict',{})
          pr=dt.get('path','')

          uoa=cri['data_uoa']
          uid=cri['data_uid']
          alias=cri['data_alias']

    else:
       # Get current repo path
       pr=work['dir_work_repo']
       uoa=work['repo_name_work']
       uid=work['repo_uid_work']
       alias=uoa
       dt={}

    return {'return':0, 'path':pr, 'repo_uoa':uoa, 'repo_uid':uid, 'repo_alias':alias, 'dict':dt}",python,"def find_path_to_repo(i):
    """"""
    Input:  {
              (repo_uoa) - repo UOA; if empty, get the default repo
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if repo not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - dict from cache
              path         - path to repo

              repo_uoa     - repo UOA
              repo_uid     - repo UID
              repo_alias   - repo alias
            }
    """"""

    a=i.get('repo_uoa','')
    ai=a

    pr=''
    if a!='':
       if a==cfg['repo_name_default'] or a==cfg['repo_uid_default']:
          pr=work['dir_default_repo']
          uoa=cfg['repo_name_default']
          uid=cfg['repo_uid_default']
          alias=uoa
          dt={}
       elif a==cfg['repo_name_local'] or a==cfg['repo_uid_local']:
          pr=work['dir_local_repo']
          uoa=cfg['repo_name_local']
          uid=cfg['repo_uid_local']
          alias=uoa
          dt={}
       else:
          # Reload cache if not initialized
          r=reload_repo_cache({}) # Ignore errors
          if r['return']>0: return r

          if not is_uid(a):
             ai=cache_repo_uoa.get(a,'')
             if ai=='':
                return {'return':1, 'error':'repository ""'+a+'"" was not found in cache'}

          cri=cache_repo_info.get(ai, {})
          if len(cri)==0:
             return {'return':1, 'error':'repository ""'+ai+'"" was not found in cache'}

          dt=cri.get('dict',{})
          pr=dt.get('path','')

          uoa=cri['data_uoa']
          uid=cri['data_uid']
          alias=cri['data_alias']

    else:
       # Get current repo path
       pr=work['dir_work_repo']
       uoa=work['repo_name_work']
       uid=work['repo_uid_work']
       alias=uoa
       dt={}

    return {'return':0, 'path':pr, 'repo_uoa':uoa, 'repo_uid':uid, 'repo_alias':alias, 'dict':dt}","['def' 'find_path_to_repo' '(' 'i' ')' ':' 'a' '=' 'i' '.' 'get' '('
 ""'repo_uoa'"" ',' ""''"" ')' 'ai' '=' 'a' 'pr' '=' ""''"" 'if' 'a' '!=' ""''""
 ':' 'if' 'a' '==' 'cfg' '[' ""'repo_name_default'"" ']' 'or' 'a' '==' 'cfg'
 '[' ""'repo_uid_default'"" ']' ':' 'pr' '=' 'work' '[' ""'dir_default_repo'""
 ']' 'uoa' '=' 'cfg' '[' ""'repo_name_default'"" ']' 'uid' '=' 'cfg' '['
 ""'repo_uid_default'"" ']' 'alias' '=' 'uoa' 'dt' '=' '{' '}' 'elif' 'a'
 '==' 'cfg' '[' ""'repo_name_local'"" ']' 'or' 'a' '==' 'cfg' '['
 ""'repo_uid_local'"" ']' ':' 'pr' '=' 'work' '[' ""'dir_local_repo'"" ']'
 'uoa' '=' 'cfg' '[' ""'repo_name_local'"" ']' 'uid' '=' 'cfg' '['
 ""'repo_uid_local'"" ']' 'alias' '=' 'uoa' 'dt' '=' '{' '}' 'else' ':'
 '# Reload cache if not initialized' 'r' '=' 'reload_repo_cache' '(' '{'
 '}' ')' '# Ignore errors' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'if' 'not' 'is_uid' '(' 'a' ')' ':' 'ai' '='
 'cache_repo_uoa' '.' 'get' '(' 'a' ',' ""''"" ')' 'if' 'ai' '==' ""''"" ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':' '\'repository ""\'' '+'
 'a' '+' '\'"" was not found in cache\'' '}' 'cri' '=' 'cache_repo_info'
 '.' 'get' '(' 'ai' ',' '{' '}' ')' 'if' 'len' '(' 'cri' ')' '==' '0' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':' '\'repository ""\'' '+'
 'ai' '+' '\'"" was not found in cache\'' '}' 'dt' '=' 'cri' '.' 'get' '('
 ""'dict'"" ',' '{' '}' ')' 'pr' '=' 'dt' '.' 'get' '(' ""'path'"" ',' ""''""
 ')' 'uoa' '=' 'cri' '[' ""'data_uoa'"" ']' 'uid' '=' 'cri' '[' ""'data_uid'""
 ']' 'alias' '=' 'cri' '[' ""'data_alias'"" ']' 'else' ':'
 '# Get current repo path' 'pr' '=' 'work' '[' ""'dir_work_repo'"" ']' 'uoa'
 '=' 'work' '[' ""'repo_name_work'"" ']' 'uid' '=' 'work' '['
 ""'repo_uid_work'"" ']' 'alias' '=' 'uoa' 'dt' '=' '{' '}' 'return' '{'
 ""'return'"" ':' '0' ',' ""'path'"" ':' 'pr' ',' ""'repo_uoa'"" ':' 'uoa' ','
 ""'repo_uid'"" ':' 'uid' ',' ""'repo_alias'"" ':' 'alias' ',' ""'dict'"" ':'
 'dt' '}']","Input:  {
              (repo_uoa) - repo UOA; if empty, get the default repo
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if repo not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - dict from cache
              path         - path to repo

              repo_uoa     - repo UOA
              repo_uid     - repo UID
              repo_alias   - repo alias
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' ';' 'if' 'empty'
 'get' 'the' 'default' 'repo' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2674-L2741
ctuning/ck,ck/kernel.py,find_path_to_data,"def find_path_to_data(i):
    """"""
    Input:  {
              (repo_uoa) - repo UOA
              module_uoa - module UOA
              data_uoa   - data UOA
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if data not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0
              path         - path to data
              path_module  - path to module entry with this entry
              path_repo    - path to the repository of this entry
              repo_uoa     - repo UOA 
              repo_uid     - repo UID
              repo_alias   - repo alias
              module_uoa   - module UOA 
              module_uid   - module UID
              module_alias - module alias
              uoa          - data UOA
              uid          - data UID
              alias        - data alias
            }
    """"""
    muoa=i['module_uoa']
    muid='?'
    duoa=i['data_uoa']
    duid='?'

    ruoa=i.get('repo_uoa','')
    ruid=''
    ralias=''
    if ruoa!='':
       r=find_path_to_repo({'repo_uoa':ruoa})
       if r['return']>0: return r
       ps=[r]
       qmax=1
    else:
       ps=paths_repos
       qmax=2

    # Search
    found=False

    pr=''
    pm=''
    pd=''

    for q in range(0,qmax):
        if found: break

        if q==1:
           # Check / reload all repos
           r=reload_repo_cache({}) # Ignore errors
           if r['return']>0: return r
           ps=paths_repos_all

        for prx in ps:
            pr=prx['path']
            ruoa=prx['repo_uoa']
            ruid=prx['repo_uid']
            ralias=prx['repo_alias']
            r=find_path_to_entry({'path':pr, 'data_uoa':muoa})
            if r['return']>0 and r['return']!=16: return r
            elif r['return']==0:
               muoa=r['data_uoa']
               muid=r['data_uid']
               malias=r['data_alias']
               pm=r['path']
               r1=find_path_to_entry({'path':pm, 'data_uoa':duoa})
               if r1['return']>0 and r1['return']!=16: return r1
               elif r1['return']==0:
                  found=True
                  pd=r1['path']
                  duoa=r1['data_uoa']
                  duid=r1['data_uid']
                  dalias=r1['data_alias']
                  break

               if found: break

    if not found:
       s=''
#       if ruoa!='': s+=ruoa+':'
       s+=muoa+':'+duoa+'"" ('
       if ruoa!='': 
#          if ruid!='':s+=ruid+':'
#          else: s+='?:'
          s+='?:'
       s+=muid+':'+duid+')'

       return {'return':16, 'error':'can\'t find path to CK entry ""'+s}

#    # Get info about repo
#    if ruid=='':
#       r=find_repo_by_path({'path':pr})
#       if r['return']>0: return r
#       ruoa=r['repo_uoa']
#       ruid=r['repo_uid']
#       ralias=r['repo_alias']
#       qmax=1

    return {'return':0, 'path':pd, 'path_module':pm, 'path_repo':pr,
                        'repo_uoa':ruoa, 'repo_uid':ruid, 'repo_alias':ralias,
                        'module_uoa':muoa, 'module_uid':muid, 'module_alias':malias,
                        'data_uoa':duoa, 'data_uid':duid, 'data_alias':dalias}",python,"def find_path_to_data(i):
    """"""
    Input:  {
              (repo_uoa) - repo UOA
              module_uoa - module UOA
              data_uoa   - data UOA
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if data not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0
              path         - path to data
              path_module  - path to module entry with this entry
              path_repo    - path to the repository of this entry
              repo_uoa     - repo UOA 
              repo_uid     - repo UID
              repo_alias   - repo alias
              module_uoa   - module UOA 
              module_uid   - module UID
              module_alias - module alias
              uoa          - data UOA
              uid          - data UID
              alias        - data alias
            }
    """"""
    muoa=i['module_uoa']
    muid='?'
    duoa=i['data_uoa']
    duid='?'

    ruoa=i.get('repo_uoa','')
    ruid=''
    ralias=''
    if ruoa!='':
       r=find_path_to_repo({'repo_uoa':ruoa})
       if r['return']>0: return r
       ps=[r]
       qmax=1
    else:
       ps=paths_repos
       qmax=2

    # Search
    found=False

    pr=''
    pm=''
    pd=''

    for q in range(0,qmax):
        if found: break

        if q==1:
           # Check / reload all repos
           r=reload_repo_cache({}) # Ignore errors
           if r['return']>0: return r
           ps=paths_repos_all

        for prx in ps:
            pr=prx['path']
            ruoa=prx['repo_uoa']
            ruid=prx['repo_uid']
            ralias=prx['repo_alias']
            r=find_path_to_entry({'path':pr, 'data_uoa':muoa})
            if r['return']>0 and r['return']!=16: return r
            elif r['return']==0:
               muoa=r['data_uoa']
               muid=r['data_uid']
               malias=r['data_alias']
               pm=r['path']
               r1=find_path_to_entry({'path':pm, 'data_uoa':duoa})
               if r1['return']>0 and r1['return']!=16: return r1
               elif r1['return']==0:
                  found=True
                  pd=r1['path']
                  duoa=r1['data_uoa']
                  duid=r1['data_uid']
                  dalias=r1['data_alias']
                  break

               if found: break

    if not found:
       s=''
#       if ruoa!='': s+=ruoa+':'
       s+=muoa+':'+duoa+'"" ('
       if ruoa!='': 
#          if ruid!='':s+=ruid+':'
#          else: s+='?:'
          s+='?:'
       s+=muid+':'+duid+')'

       return {'return':16, 'error':'can\'t find path to CK entry ""'+s}

#    # Get info about repo
#    if ruid=='':
#       r=find_repo_by_path({'path':pr})
#       if r['return']>0: return r
#       ruoa=r['repo_uoa']
#       ruid=r['repo_uid']
#       ralias=r['repo_alias']
#       qmax=1

    return {'return':0, 'path':pd, 'path_module':pm, 'path_repo':pr,
                        'repo_uoa':ruoa, 'repo_uid':ruid, 'repo_alias':ralias,
                        'module_uoa':muoa, 'module_uid':muid, 'module_alias':malias,
                        'data_uoa':duoa, 'data_uid':duid, 'data_alias':dalias}","['def' 'find_path_to_data' '(' 'i' ')' ':' 'muoa' '=' 'i' '['
 ""'module_uoa'"" ']' 'muid' '=' ""'?'"" 'duoa' '=' 'i' '[' ""'data_uoa'"" ']'
 'duid' '=' ""'?'"" 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')'
 'ruid' '=' ""''"" 'ralias' '=' ""''"" 'if' 'ruoa' '!=' ""''"" ':' 'r' '='
 'find_path_to_repo' '(' '{' ""'repo_uoa'"" ':' 'ruoa' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'ps' '=' '[' 'r' ']' 'qmax' '='
 '1' 'else' ':' 'ps' '=' 'paths_repos' 'qmax' '=' '2' '# Search' 'found'
 '=' 'False' 'pr' '=' ""''"" 'pm' '=' ""''"" 'pd' '=' ""''"" 'for' 'q' 'in'
 'range' '(' '0' ',' 'qmax' ')' ':' 'if' 'found' ':' 'break' 'if' 'q' '=='
 '1' ':' '# Check / reload all repos' 'r' '=' 'reload_repo_cache' '(' '{'
 '}' ')' '# Ignore errors' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'ps' '=' 'paths_repos_all' 'for' 'prx' 'in' 'ps' ':' 'pr'
 '=' 'prx' '[' ""'path'"" ']' 'ruoa' '=' 'prx' '[' ""'repo_uoa'"" ']' 'ruid'
 '=' 'prx' '[' ""'repo_uid'"" ']' 'ralias' '=' 'prx' '[' ""'repo_alias'"" ']'
 'r' '=' 'find_path_to_entry' '(' '{' ""'path'"" ':' 'pr' ',' ""'data_uoa'""
 ':' 'muoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' 'and' 'r' '['
 ""'return'"" ']' '!=' '16' ':' 'return' 'r' 'elif' 'r' '[' ""'return'"" ']'
 '==' '0' ':' 'muoa' '=' 'r' '[' ""'data_uoa'"" ']' 'muid' '=' 'r' '['
 ""'data_uid'"" ']' 'malias' '=' 'r' '[' ""'data_alias'"" ']' 'pm' '=' 'r' '['
 ""'path'"" ']' 'r1' '=' 'find_path_to_entry' '(' '{' ""'path'"" ':' 'pm' ','
 ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r1' '[' ""'return'"" ']' '>' '0'
 'and' 'r1' '[' ""'return'"" ']' '!=' '16' ':' 'return' 'r1' 'elif' 'r1' '['
 ""'return'"" ']' '==' '0' ':' 'found' '=' 'True' 'pd' '=' 'r1' '[' ""'path'""
 ']' 'duoa' '=' 'r1' '[' ""'data_uoa'"" ']' 'duid' '=' 'r1' '[' ""'data_uid'""
 ']' 'dalias' '=' 'r1' '[' ""'data_alias'"" ']' 'break' 'if' 'found' ':'
 'break' 'if' 'not' 'found' ':' 's' '=' ""''""
 ""#       if ruoa!='': s+=ruoa+':'"" 's' '+=' 'muoa' '+' ""':'"" '+' 'duoa'
 '+' '\'"" (\'' 'if' 'ruoa' '!=' ""''"" ':'
 ""#          if ruid!='':s+=ruid+':'"" ""#          else: s+='?:'"" 's' '+='
 ""'?:'"" 's' '+=' 'muid' '+' ""':'"" '+' 'duid' '+' ""')'"" 'return' '{'
 ""'return'"" ':' '16' ',' ""'error'"" ':'
 '\'can\\\'t find path to CK entry ""\'' '+' 's' '}'
 '#    # Get info about repo' ""#    if ruid=='':""
 ""#       r=find_repo_by_path({'path':pr})""
 ""#       if r['return']>0: return r"" ""#       ruoa=r['repo_uoa']""
 ""#       ruid=r['repo_uid']"" ""#       ralias=r['repo_alias']""
 '#       qmax=1' 'return' '{' ""'return'"" ':' '0' ',' ""'path'"" ':' 'pd'
 ',' ""'path_module'"" ':' 'pm' ',' ""'path_repo'"" ':' 'pr' ',' ""'repo_uoa'""
 ':' 'ruoa' ',' ""'repo_uid'"" ':' 'ruid' ',' ""'repo_alias'"" ':' 'ralias'
 ',' ""'module_uoa'"" ':' 'muoa' ',' ""'module_uid'"" ':' 'muid' ','
 ""'module_alias'"" ':' 'malias' ',' ""'data_uoa'"" ':' 'duoa' ','
 ""'data_uid'"" ':' 'duid' ',' ""'data_alias'"" ':' 'dalias' '}']","Input:  {
              (repo_uoa) - repo UOA
              module_uoa - module UOA
              data_uoa   - data UOA
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if data not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0
              path         - path to data
              path_module  - path to module entry with this entry
              path_repo    - path to the repository of this entry
              repo_uoa     - repo UOA 
              repo_uid     - repo UID
              repo_alias   - repo alias
              module_uoa   - module UOA 
              module_uid   - module UID
              module_alias - module alias
              uoa          - data UOA
              uid          - data UID
              alias        - data alias
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2748-L2856
ctuning/ck,ck/kernel.py,find_path_to_entry,"def find_path_to_entry(i):
    """"""
    Input:  {
              path     - path to a repository
              data_uoa - data UOA
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if data not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              path         - path to data entry
              data_uid     - data uid (from UOA)
              data_alias   - data alias (from UOA)
              data_uoa     - data alias or data uid, if data alias==''
            }
    """"""

    p=i['path']
    duoa=i['data_uoa']

    if duoa=='': # pragma: no cover
       raise Exception('data_uoa is empty')

    # Disambiguate UOA
    alias=''
    if is_uid(duoa):
       # If UID
       uid=duoa

       # Check if alias exists
       p1=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_alias_u'] + uid)
       found_alias=False
       if os.path.isfile(p1):
          try:
             f=open(p1)
             alias=f.readline().strip()
             f.close()
             found_alias=True
          except Exception as e:
             None

       # If alias exists, check directory with alias
       if found_alias:
          p2=os.path.join(p, alias)
          return {'return':0, 'path':p2, 'data_uid':uid, 'data_alias':alias, 'data_uoa':alias}

       p2=os.path.join(p, uid)
       if os.path.isdir(p2):
          return {'return':0, 'path':p2, 'data_uid':uid, 'data_alias':'', 'data_uoa':uid}

       return {'return':-1}

    # If alias
    alias=duoa

    p1=os.path.join(p, alias)
    if sys.version_info[0]<3: 
       try: p1=p1.encode('utf8')
       except Exception as e: pass
    if os.path.isdir(p1):
       # Check uid for this alias
       p2=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_alias_a'] + alias)
       try:
          f=open(p2)
          uid=f.readline().strip()
          f.close()
       except Exception as e:
          return {'return':10, 'error':'inconsistent entry: alias ""'+alias+'"" exists, but not the UID in file '+p2, 
                               'path':p1, 'data_alias':alias}

       return {'return':0, 'path':p1, 'data_uid':uid, 'data_alias':alias, 'data_uoa':alias}

    return {'return':16, 'error':'can\'t find path to CK entry'}",python,"def find_path_to_entry(i):
    """"""
    Input:  {
              path     - path to a repository
              data_uoa - data UOA
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if data not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              path         - path to data entry
              data_uid     - data uid (from UOA)
              data_alias   - data alias (from UOA)
              data_uoa     - data alias or data uid, if data alias==''
            }
    """"""

    p=i['path']
    duoa=i['data_uoa']

    if duoa=='': # pragma: no cover
       raise Exception('data_uoa is empty')

    # Disambiguate UOA
    alias=''
    if is_uid(duoa):
       # If UID
       uid=duoa

       # Check if alias exists
       p1=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_alias_u'] + uid)
       found_alias=False
       if os.path.isfile(p1):
          try:
             f=open(p1)
             alias=f.readline().strip()
             f.close()
             found_alias=True
          except Exception as e:
             None

       # If alias exists, check directory with alias
       if found_alias:
          p2=os.path.join(p, alias)
          return {'return':0, 'path':p2, 'data_uid':uid, 'data_alias':alias, 'data_uoa':alias}

       p2=os.path.join(p, uid)
       if os.path.isdir(p2):
          return {'return':0, 'path':p2, 'data_uid':uid, 'data_alias':'', 'data_uoa':uid}

       return {'return':-1}

    # If alias
    alias=duoa

    p1=os.path.join(p, alias)
    if sys.version_info[0]<3: 
       try: p1=p1.encode('utf8')
       except Exception as e: pass
    if os.path.isdir(p1):
       # Check uid for this alias
       p2=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_alias_a'] + alias)
       try:
          f=open(p2)
          uid=f.readline().strip()
          f.close()
       except Exception as e:
          return {'return':10, 'error':'inconsistent entry: alias ""'+alias+'"" exists, but not the UID in file '+p2, 
                               'path':p1, 'data_alias':alias}

       return {'return':0, 'path':p1, 'data_uid':uid, 'data_alias':alias, 'data_uoa':alias}

    return {'return':16, 'error':'can\'t find path to CK entry'}","['def' 'find_path_to_entry' '(' 'i' ')' ':' 'p' '=' 'i' '[' ""'path'"" ']'
 'duoa' '=' 'i' '[' ""'data_uoa'"" ']' 'if' 'duoa' '==' ""''"" ':'
 '# pragma: no cover' 'raise' 'Exception' '(' ""'data_uoa is empty'"" ')'
 '# Disambiguate UOA' 'alias' '=' ""''"" 'if' 'is_uid' '(' 'duoa' ')' ':'
 '# If UID' 'uid' '=' 'duoa' '# Check if alias exists' 'p1' '=' 'os' '.'
 'path' '.' 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'"" ']' ',' 'cfg'
 '[' ""'file_alias_u'"" ']' '+' 'uid' ')' 'found_alias' '=' 'False' 'if'
 'os' '.' 'path' '.' 'isfile' '(' 'p1' ')' ':' 'try' ':' 'f' '=' 'open'
 '(' 'p1' ')' 'alias' '=' 'f' '.' 'readline' '(' ')' '.' 'strip' '(' ')'
 'f' '.' 'close' '(' ')' 'found_alias' '=' 'True' 'except' 'Exception'
 'as' 'e' ':' 'None' '# If alias exists, check directory with alias' 'if'
 'found_alias' ':' 'p2' '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'alias'
 ')' 'return' '{' ""'return'"" ':' '0' ',' ""'path'"" ':' 'p2' ','
 ""'data_uid'"" ':' 'uid' ',' ""'data_alias'"" ':' 'alias' ',' ""'data_uoa'""
 ':' 'alias' '}' 'p2' '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'uid' ')'
 'if' 'os' '.' 'path' '.' 'isdir' '(' 'p2' ')' ':' 'return' '{' ""'return'""
 ':' '0' ',' ""'path'"" ':' 'p2' ',' ""'data_uid'"" ':' 'uid' ','
 ""'data_alias'"" ':' ""''"" ',' ""'data_uoa'"" ':' 'uid' '}' 'return' '{'
 ""'return'"" ':' '-' '1' '}' '# If alias' 'alias' '=' 'duoa' 'p1' '=' 'os'
 '.' 'path' '.' 'join' '(' 'p' ',' 'alias' ')' 'if' 'sys' '.'
 'version_info' '[' '0' ']' '<' '3' ':' 'try' ':' 'p1' '=' 'p1' '.'
 'encode' '(' ""'utf8'"" ')' 'except' 'Exception' 'as' 'e' ':' 'pass' 'if'
 'os' '.' 'path' '.' 'isdir' '(' 'p1' ')' ':' '# Check uid for this alias'
 'p2' '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'cfg' '['
 ""'subdir_ck_ext'"" ']' ',' 'cfg' '[' ""'file_alias_a'"" ']' '+' 'alias' ')'
 'try' ':' 'f' '=' 'open' '(' 'p2' ')' 'uid' '=' 'f' '.' 'readline' '('
 ')' '.' 'strip' '(' ')' 'f' '.' 'close' '(' ')' 'except' 'Exception' 'as'
 'e' ':' 'return' '{' ""'return'"" ':' '10' ',' ""'error'"" ':'
 '\'inconsistent entry: alias ""\'' '+' 'alias' '+'
 '\'"" exists, but not the UID in file \'' '+' 'p2' ',' ""'path'"" ':' 'p1'
 ',' ""'data_alias'"" ':' 'alias' '}' 'return' '{' ""'return'"" ':' '0' ','
 ""'path'"" ':' 'p1' ',' ""'data_uid'"" ':' 'uid' ',' ""'data_alias'"" ':'
 'alias' ',' ""'data_uoa'"" ':' 'alias' '}' 'return' '{' ""'return'"" ':' '16'
 ',' ""'error'"" ':' ""'can\\'t find path to CK entry'"" '}']","Input:  {
              path     - path to a repository
              data_uoa - data UOA
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if data not found (may be warning)
                                         >  0, if error
              (error)      - error text if return > 0

              path         - path to data entry
              data_uid     - data uid (from UOA)
              data_alias   - data alias (from UOA)
              data_uoa     - data alias or data uid, if data alias==''
            }","['Input' ':' '{' 'path' '-' 'path' 'to' 'a' 'repository' 'data_uoa' '-'
 'data' 'UOA' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2863-L2938
ctuning/ck,ck/kernel.py,load_meta_from_path,"def load_meta_from_path(i):
    """"""
    Input:  {
              path           - path to a data entry

              (skip_updates) - if 'yes', do not load updates
              (skip_desc)    - if 'yes', do not load descriptions
            }

    Output: {
              return         - return code =  0, if successful
                                           >  0, if error
              (error)        - error text if return > 0

              dict           - dict with meta description
              path           - path to json file with meta description

              (info)         - dict with info if exists
              (path_info)    - path to json file with info

              (updates)      - dict with updates if exists
              (path_updates) - path to json file with updates
              (path_desc)    - path to json file with API description
            }
    """"""

    p=i['path']

    slu=i.get('skip_updates','')
    sld=i.get('skip_desc','')

    p1=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_meta'])
    if not os.path.isfile(p1):
       p1=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_meta_old']) # For compatibility with cM
       if not os.path.isfile(p1):
          p1=''

    if p1!='':
       rx={'return':0}

       r=load_json_file({'json_file':p1})
       if r['return']>0: return r
       rx['path']=p1
       rx['dict']=r['dict']

       # Check info file
       p2=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_info'])
       if os.path.isfile(p2):
          r=load_json_file({'json_file':p2})
          if r['return']>0: return r
          rx['path_info']=p2
          rx['info']=r['dict']

       # Check updates file
       if slu!='yes':
          p3=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_updates'])
          if os.path.isfile(p3):
             r=load_json_file({'json_file':p3})
             if r['return']>0: return r
             rx['path_updates']=p3
             rx['updates']=r['dict']

       # Check desc file
       if sld!='yes':
          p4=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_desc'])
          if os.path.isfile(p4):
             r=load_json_file({'json_file':p4})
             if r['return']>0: return r
             rx['path_desc']=p4
             rx['desc']=r['dict']

       return rx
    else:
       return {'return':1, 'error':'meta description is not found in path '+p}",python,"def load_meta_from_path(i):
    """"""
    Input:  {
              path           - path to a data entry

              (skip_updates) - if 'yes', do not load updates
              (skip_desc)    - if 'yes', do not load descriptions
            }

    Output: {
              return         - return code =  0, if successful
                                           >  0, if error
              (error)        - error text if return > 0

              dict           - dict with meta description
              path           - path to json file with meta description

              (info)         - dict with info if exists
              (path_info)    - path to json file with info

              (updates)      - dict with updates if exists
              (path_updates) - path to json file with updates
              (path_desc)    - path to json file with API description
            }
    """"""

    p=i['path']

    slu=i.get('skip_updates','')
    sld=i.get('skip_desc','')

    p1=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_meta'])
    if not os.path.isfile(p1):
       p1=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_meta_old']) # For compatibility with cM
       if not os.path.isfile(p1):
          p1=''

    if p1!='':
       rx={'return':0}

       r=load_json_file({'json_file':p1})
       if r['return']>0: return r
       rx['path']=p1
       rx['dict']=r['dict']

       # Check info file
       p2=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_info'])
       if os.path.isfile(p2):
          r=load_json_file({'json_file':p2})
          if r['return']>0: return r
          rx['path_info']=p2
          rx['info']=r['dict']

       # Check updates file
       if slu!='yes':
          p3=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_updates'])
          if os.path.isfile(p3):
             r=load_json_file({'json_file':p3})
             if r['return']>0: return r
             rx['path_updates']=p3
             rx['updates']=r['dict']

       # Check desc file
       if sld!='yes':
          p4=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_desc'])
          if os.path.isfile(p4):
             r=load_json_file({'json_file':p4})
             if r['return']>0: return r
             rx['path_desc']=p4
             rx['desc']=r['dict']

       return rx
    else:
       return {'return':1, 'error':'meta description is not found in path '+p}","['def' 'load_meta_from_path' '(' 'i' ')' ':' 'p' '=' 'i' '[' ""'path'"" ']'
 'slu' '=' 'i' '.' 'get' '(' ""'skip_updates'"" ',' ""''"" ')' 'sld' '=' 'i'
 '.' 'get' '(' ""'skip_desc'"" ',' ""''"" ')' 'p1' '=' 'os' '.' 'path' '.'
 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'"" ']' ',' 'cfg' '['
 ""'file_meta'"" ']' ')' 'if' 'not' 'os' '.' 'path' '.' 'isfile' '(' 'p1'
 ')' ':' 'p1' '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'cfg' '['
 ""'subdir_ck_ext'"" ']' ',' 'cfg' '[' ""'file_meta_old'"" ']' ')'
 '# For compatibility with cM' 'if' 'not' 'os' '.' 'path' '.' 'isfile' '('
 'p1' ')' ':' 'p1' '=' ""''"" 'if' 'p1' '!=' ""''"" ':' 'rx' '=' '{'
 ""'return'"" ':' '0' '}' 'r' '=' 'load_json_file' '(' '{' ""'json_file'"" ':'
 'p1' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'rx'
 '[' ""'path'"" ']' '=' 'p1' 'rx' '[' ""'dict'"" ']' '=' 'r' '[' ""'dict'"" ']'
 '# Check info file' 'p2' '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'cfg'
 '[' ""'subdir_ck_ext'"" ']' ',' 'cfg' '[' ""'file_info'"" ']' ')' 'if' 'os'
 '.' 'path' '.' 'isfile' '(' 'p2' ')' ':' 'r' '=' 'load_json_file' '(' '{'
 ""'json_file'"" ':' 'p2' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'rx' '[' ""'path_info'"" ']' '=' 'p2' 'rx' '[' ""'info'"" ']'
 '=' 'r' '[' ""'dict'"" ']' '# Check updates file' 'if' 'slu' '!=' ""'yes'""
 ':' 'p3' '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'cfg' '['
 ""'subdir_ck_ext'"" ']' ',' 'cfg' '[' ""'file_updates'"" ']' ')' 'if' 'os'
 '.' 'path' '.' 'isfile' '(' 'p3' ')' ':' 'r' '=' 'load_json_file' '(' '{'
 ""'json_file'"" ':' 'p3' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'rx' '[' ""'path_updates'"" ']' '=' 'p3' 'rx' '[' ""'updates'""
 ']' '=' 'r' '[' ""'dict'"" ']' '# Check desc file' 'if' 'sld' '!=' ""'yes'""
 ':' 'p4' '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'cfg' '['
 ""'subdir_ck_ext'"" ']' ',' 'cfg' '[' ""'file_desc'"" ']' ')' 'if' 'os' '.'
 'path' '.' 'isfile' '(' 'p4' ')' ':' 'r' '=' 'load_json_file' '(' '{'
 ""'json_file'"" ':' 'p4' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'rx' '[' ""'path_desc'"" ']' '=' 'p4' 'rx' '[' ""'desc'"" ']'
 '=' 'r' '[' ""'dict'"" ']' 'return' 'rx' 'else' ':' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'meta description is not found in path '"" '+'
 'p' '}']","Input:  {
              path           - path to a data entry

              (skip_updates) - if 'yes', do not load updates
              (skip_desc)    - if 'yes', do not load descriptions
            }

    Output: {
              return         - return code =  0, if successful
                                           >  0, if error
              (error)        - error text if return > 0

              dict           - dict with meta description
              path           - path to json file with meta description

              (info)         - dict with info if exists
              (path_info)    - path to json file with info

              (updates)      - dict with updates if exists
              (path_updates) - path to json file with updates
              (path_desc)    - path to json file with API description
            }",['Input' ':' '{' 'path' '-' 'path' 'to' 'a' 'data' 'entry'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L2945-L3018
ctuning/ck,ck/kernel.py,load_module_from_path,"def load_module_from_path(i):
    """"""
    Input:  {
              path             - module path
              module_code_name - module name
              (cfg)            - configuration of the module if exists ...
              (skip_init)      - if 'yes', skip init
              (data_uoa)       - module UOA (useful when printing error)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              code         - python code object
              path         - full path to the module
              cuid         - internal UID of the module
            }
    """"""

    p=i['path']
    n=i['module_code_name']

    xcfg=i.get('cfg',None)

    # Find module
    try:
       x=imp.find_module(n, [p])
    except ImportError as e: # pragma: no cover
       return {'return':1, 'error':'can\'t find module code (path='+p+', name='+n+', err='+format(e)+')'}

    ff=x[0]
    full_path=x[1]

    # Check if code has been already loaded
    if full_path in work['cached_module_by_path'] and work['cached_module_by_path_last_modification'][full_path]==os.path.getmtime(full_path):
       ff.close()
       # Code already loaded 
       return work['cached_module_by_path'][full_path]

    # Check if has dependency on specific CK kernel version
    if xcfg!=None:
       kd=xcfg.get('min_kernel_dep','')
       if kd!='':
          rx=check_version({'version':kd})
          if rx['return']>0: return rx

          ok=rx['ok']
          version_str=rx['current_version']

          if ok!='yes':
             return {'return':1, 'error':'module ""'+i.get('data_uoa','')+'"" requires minimal CK kernel version '+kd+' while your version is '+version_str} 

    # Generate uid for the run-time extension of the loaded module 
    # otherwise modules with the same extension (key.py for example) 
    # will be reloaded ...

    r=gen_uid({})
    if r['return']>0: return r
    ruid='rt-'+r['data_uid']

    try:
       c=imp.load_module(ruid, ff, full_path, x[2])
    except ImportError as e: # pragma: no cover
       return {'return':1, 'error':'can\'t load module code (path='+p+', name='+n+', err='+format(e)+')'}

    x[0].close()

    # Initialize module with this CK instance 
    c.ck=sys.modules[__name__]
    if xcfg!=None: c.cfg=xcfg

    # Initialize module
    if i.get('skip_init','')!='yes':
       # Check if init function exists
       if getattr(c, 'init')!=None:
          r=c.init(i)
          if r['return']>0: return r

    r={'return':0, 'code':c, 'path':full_path, 'cuid':ruid}

    # Cache code together with its time of change
    work['cached_module_by_path'][full_path]=r
    work['cached_module_by_path_last_modification'][full_path]=os.path.getmtime(full_path)

    return r",python,"def load_module_from_path(i):
    """"""
    Input:  {
              path             - module path
              module_code_name - module name
              (cfg)            - configuration of the module if exists ...
              (skip_init)      - if 'yes', skip init
              (data_uoa)       - module UOA (useful when printing error)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              code         - python code object
              path         - full path to the module
              cuid         - internal UID of the module
            }
    """"""

    p=i['path']
    n=i['module_code_name']

    xcfg=i.get('cfg',None)

    # Find module
    try:
       x=imp.find_module(n, [p])
    except ImportError as e: # pragma: no cover
       return {'return':1, 'error':'can\'t find module code (path='+p+', name='+n+', err='+format(e)+')'}

    ff=x[0]
    full_path=x[1]

    # Check if code has been already loaded
    if full_path in work['cached_module_by_path'] and work['cached_module_by_path_last_modification'][full_path]==os.path.getmtime(full_path):
       ff.close()
       # Code already loaded 
       return work['cached_module_by_path'][full_path]

    # Check if has dependency on specific CK kernel version
    if xcfg!=None:
       kd=xcfg.get('min_kernel_dep','')
       if kd!='':
          rx=check_version({'version':kd})
          if rx['return']>0: return rx

          ok=rx['ok']
          version_str=rx['current_version']

          if ok!='yes':
             return {'return':1, 'error':'module ""'+i.get('data_uoa','')+'"" requires minimal CK kernel version '+kd+' while your version is '+version_str} 

    # Generate uid for the run-time extension of the loaded module 
    # otherwise modules with the same extension (key.py for example) 
    # will be reloaded ...

    r=gen_uid({})
    if r['return']>0: return r
    ruid='rt-'+r['data_uid']

    try:
       c=imp.load_module(ruid, ff, full_path, x[2])
    except ImportError as e: # pragma: no cover
       return {'return':1, 'error':'can\'t load module code (path='+p+', name='+n+', err='+format(e)+')'}

    x[0].close()

    # Initialize module with this CK instance 
    c.ck=sys.modules[__name__]
    if xcfg!=None: c.cfg=xcfg

    # Initialize module
    if i.get('skip_init','')!='yes':
       # Check if init function exists
       if getattr(c, 'init')!=None:
          r=c.init(i)
          if r['return']>0: return r

    r={'return':0, 'code':c, 'path':full_path, 'cuid':ruid}

    # Cache code together with its time of change
    work['cached_module_by_path'][full_path]=r
    work['cached_module_by_path_last_modification'][full_path]=os.path.getmtime(full_path)

    return r","['def' 'load_module_from_path' '(' 'i' ')' ':' 'p' '=' 'i' '[' ""'path'""
 ']' 'n' '=' 'i' '[' ""'module_code_name'"" ']' 'xcfg' '=' 'i' '.' 'get' '('
 ""'cfg'"" ',' 'None' ')' '# Find module' 'try' ':' 'x' '=' 'imp' '.'
 'find_module' '(' 'n' ',' '[' 'p' ']' ')' 'except' 'ImportError' 'as' 'e'
 ':' '# pragma: no cover' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' ""'can\\'t find module code (path='"" '+' 'p' '+' ""', name='"" '+' 'n'
 '+' ""', err='"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}' 'ff' '=' 'x' '['
 '0' ']' 'full_path' '=' 'x' '[' '1' ']'
 '# Check if code has been already loaded' 'if' 'full_path' 'in' 'work'
 '[' ""'cached_module_by_path'"" ']' 'and' 'work' '['
 ""'cached_module_by_path_last_modification'"" ']' '[' 'full_path' ']' '=='
 'os' '.' 'path' '.' 'getmtime' '(' 'full_path' ')' ':' 'ff' '.' 'close'
 '(' ')' '# Code already loaded ' 'return' 'work' '['
 ""'cached_module_by_path'"" ']' '[' 'full_path' ']'
 '# Check if has dependency on specific CK kernel version' 'if' 'xcfg'
 '!=' 'None' ':' 'kd' '=' 'xcfg' '.' 'get' '(' ""'min_kernel_dep'"" ',' ""''""
 ')' 'if' 'kd' '!=' ""''"" ':' 'rx' '=' 'check_version' '(' '{' ""'version'""
 ':' 'kd' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx'
 'ok' '=' 'rx' '[' ""'ok'"" ']' 'version_str' '=' 'rx' '['
 ""'current_version'"" ']' 'if' 'ok' '!=' ""'yes'"" ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':' '\'module ""\'' '+' 'i' '.' 'get' '('
 ""'data_uoa'"" ',' ""''"" ')' '+' '\'"" requires minimal CK kernel version \''
 '+' 'kd' '+' ""' while your version is '"" '+' 'version_str' '}'
 '# Generate uid for the run-time extension of the loaded module '
 '# otherwise modules with the same extension (key.py for example) '
 '# will be reloaded ...' 'r' '=' 'gen_uid' '(' '{' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'ruid' '=' ""'rt-'"" '+' 'r' '['
 ""'data_uid'"" ']' 'try' ':' 'c' '=' 'imp' '.' 'load_module' '(' 'ruid' ','
 'ff' ',' 'full_path' ',' 'x' '[' '2' ']' ')' 'except' 'ImportError' 'as'
 'e' ':' '# pragma: no cover' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'can\\'t load module code (path='"" '+' 'p' '+' ""', name='""
 '+' 'n' '+' ""', err='"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}' 'x' '[' '0'
 ']' '.' 'close' '(' ')' '# Initialize module with this CK instance ' 'c'
 '.' 'ck' '=' 'sys' '.' 'modules' '[' '__name__' ']' 'if' 'xcfg' '!='
 'None' ':' 'c' '.' 'cfg' '=' 'xcfg' '# Initialize module' 'if' 'i' '.'
 'get' '(' ""'skip_init'"" ',' ""''"" ')' '!=' ""'yes'"" ':'
 '# Check if init function exists' 'if' 'getattr' '(' 'c' ',' ""'init'"" ')'
 '!=' 'None' ':' 'r' '=' 'c' '.' 'init' '(' 'i' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'r' '=' '{' ""'return'"" ':' '0'
 ',' ""'code'"" ':' 'c' ',' ""'path'"" ':' 'full_path' ',' ""'cuid'"" ':' 'ruid'
 '}' '# Cache code together with its time of change' 'work' '['
 ""'cached_module_by_path'"" ']' '[' 'full_path' ']' '=' 'r' 'work' '['
 ""'cached_module_by_path_last_modification'"" ']' '[' 'full_path' ']' '='
 'os' '.' 'path' '.' 'getmtime' '(' 'full_path' ')' 'return' 'r']","Input:  {
              path             - module path
              module_code_name - module name
              (cfg)            - configuration of the module if exists ...
              (skip_init)      - if 'yes', skip init
              (data_uoa)       - module UOA (useful when printing error)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              code         - python code object
              path         - full path to the module
              cuid         - internal UID of the module
            }","['Input' ':' '{' 'path' '-' 'module' 'path' 'module_code_name' '-'
 'module' 'name' '(' 'cfg' ')' '-' 'configuration' 'of' 'the' 'module'
 'if' 'exists' '...' '(' 'skip_init' ')' '-' 'if' 'yes' 'skip' 'init' '('
 'data_uoa' ')' '-' 'module' 'UOA' '(' 'useful' 'when' 'printing' 'error'
 ')' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L3025-L3111
ctuning/ck,ck/kernel.py,perform_remote_action,"def perform_remote_action(i):
    """"""
    Input:  { See 'perform_action' function }
    Output: { See 'perform_action' function }
    """"""

    # Import modules compatible with Python 2.x and 3.x
    import urllib

    try:    import urllib.request as urllib2
    except: import urllib2 # pragma: no cover

    try:    from urllib.parse import urlencode
    except: from urllib import urlencode # pragma: no cover

    rr={'return':0}

    # Get action
    act=i.get('action','')

    # Check output
    o=i.get('out','')

    if o=='con':
#       out('Initiating remote access ...')
#       out('')
       i['out']='con'
       i['quiet']='yes'
       if act=='pull':
          i['out']='json'
    else:
       i['out']='json'

#    # Clean up input
#    if o!='json_file': 
#       rr['out']='json' # Decided to return json to show that it's remote ...

    if 'cid' in i: 
       del(i['cid']) # already processed

    # Get URL
    url=i.get('remote_server_url','')

    # Process i
    if 'remote_server_url' in i: del(i['remote_server_url'])

    # Pre process if push file ...
    if act=='push':
       # Check file
       fn=i.get('filename','')
       if fn=='':
          x=i.get('cids',[])
          if len(x)>0:
             fn=x[0]

       if fn=='':
          return {'return':1, 'error':'filename is empty'}

       if not os.path.isfile(fn):
          return {'return':1, 'error':'file '+fn+' not found'}

       rx=convert_file_to_upload_string({'filename':fn})
       if rx['return']>0: return rx

       i['file_content_base64']=rx['file_content_base64']

       # Leave only filename without path
       i['filename']=os.path.basename(fn)

    # Prepare post variables
    r=dumps_json({'dict':i, 'skip_indent':'yes'})
    if r['return']>0: return r
    s=r['string'].encode('utf8')

    post=urlencode({'ck_json':s})
    if sys.version_info[0]>2: post=post.encode('utf8')

    # If auth
    au=i.get('remote_server_user','')
    if au!='': 
       del(i['remote_server_user'])

       ap=i.get('remote_server_pass','')
       if ap!='': 
          del(i['remote_server_pass'])

       auth = urllib2.HTTPPasswordMgrWithDefaultRealm()
       auth.add_password(None, url, au, ap)
       urllib2.install_opener(urllib2.build_opener(urllib2.HTTPBasicAuthHandler(auth)))

    # Prepare request
    request = urllib2.Request(url, post)

    # Connect
    try:
       f=urllib2.urlopen(request)
    except Exception as e:
       return {'return':1, 'error':'Access to remote CK repository failed ('+format(e)+')'}

    # Read from Internet
    try:
       s=f.read()
       f.close()
    except Exception as e:
       return {'return':1, 'error':'Failed reading stream from remote CK web service ('+format(e)+')'}

    # Check output
    try: s=s.decode('utf8')
    except Exception as e: pass
    if o=='con' and act!='pull':
       out(s.rstrip())
    else:
       # Try to convert output to dictionary
       r=convert_json_str_to_dict({'str':s, 'skip_quote_replacement':'yes'})
       if r['return']>0: 
          return {'return':1, 'error':'can\'t parse output from remote CK server ('+r['error']+'):\n'+s[:256]+'\n\n...)'}

       d=r['dict']

       if 'return' in d: d['return']=int(d['return']) # Fix for some strange behavior when 'return' is not integer - should check why ...

       if d.get('return',0)>0:
          return d

       # Post process if pull file ...
       if act=='pull':
          if o!='json' and o!='json_file':
             # Convert encoded file to real file ...
             x=d.get('file_content_base64','')

             fn=d.get('filename','')
             if fn=='': fn=cfg['default_archive_name']

             r=convert_upload_string_to_file({'file_content_base64':x, 'filename':fn})
             if r['return']>0: return r

             if 'file_content_base64' in d: del(d['file_content_base64'])

       rr.update(d)

    # Restore original output
    i['out']=o

    return rr",python,"def perform_remote_action(i):
    """"""
    Input:  { See 'perform_action' function }
    Output: { See 'perform_action' function }
    """"""

    # Import modules compatible with Python 2.x and 3.x
    import urllib

    try:    import urllib.request as urllib2
    except: import urllib2 # pragma: no cover

    try:    from urllib.parse import urlencode
    except: from urllib import urlencode # pragma: no cover

    rr={'return':0}

    # Get action
    act=i.get('action','')

    # Check output
    o=i.get('out','')

    if o=='con':
#       out('Initiating remote access ...')
#       out('')
       i['out']='con'
       i['quiet']='yes'
       if act=='pull':
          i['out']='json'
    else:
       i['out']='json'

#    # Clean up input
#    if o!='json_file': 
#       rr['out']='json' # Decided to return json to show that it's remote ...

    if 'cid' in i: 
       del(i['cid']) # already processed

    # Get URL
    url=i.get('remote_server_url','')

    # Process i
    if 'remote_server_url' in i: del(i['remote_server_url'])

    # Pre process if push file ...
    if act=='push':
       # Check file
       fn=i.get('filename','')
       if fn=='':
          x=i.get('cids',[])
          if len(x)>0:
             fn=x[0]

       if fn=='':
          return {'return':1, 'error':'filename is empty'}

       if not os.path.isfile(fn):
          return {'return':1, 'error':'file '+fn+' not found'}

       rx=convert_file_to_upload_string({'filename':fn})
       if rx['return']>0: return rx

       i['file_content_base64']=rx['file_content_base64']

       # Leave only filename without path
       i['filename']=os.path.basename(fn)

    # Prepare post variables
    r=dumps_json({'dict':i, 'skip_indent':'yes'})
    if r['return']>0: return r
    s=r['string'].encode('utf8')

    post=urlencode({'ck_json':s})
    if sys.version_info[0]>2: post=post.encode('utf8')

    # If auth
    au=i.get('remote_server_user','')
    if au!='': 
       del(i['remote_server_user'])

       ap=i.get('remote_server_pass','')
       if ap!='': 
          del(i['remote_server_pass'])

       auth = urllib2.HTTPPasswordMgrWithDefaultRealm()
       auth.add_password(None, url, au, ap)
       urllib2.install_opener(urllib2.build_opener(urllib2.HTTPBasicAuthHandler(auth)))

    # Prepare request
    request = urllib2.Request(url, post)

    # Connect
    try:
       f=urllib2.urlopen(request)
    except Exception as e:
       return {'return':1, 'error':'Access to remote CK repository failed ('+format(e)+')'}

    # Read from Internet
    try:
       s=f.read()
       f.close()
    except Exception as e:
       return {'return':1, 'error':'Failed reading stream from remote CK web service ('+format(e)+')'}

    # Check output
    try: s=s.decode('utf8')
    except Exception as e: pass
    if o=='con' and act!='pull':
       out(s.rstrip())
    else:
       # Try to convert output to dictionary
       r=convert_json_str_to_dict({'str':s, 'skip_quote_replacement':'yes'})
       if r['return']>0: 
          return {'return':1, 'error':'can\'t parse output from remote CK server ('+r['error']+'):\n'+s[:256]+'\n\n...)'}

       d=r['dict']

       if 'return' in d: d['return']=int(d['return']) # Fix for some strange behavior when 'return' is not integer - should check why ...

       if d.get('return',0)>0:
          return d

       # Post process if pull file ...
       if act=='pull':
          if o!='json' and o!='json_file':
             # Convert encoded file to real file ...
             x=d.get('file_content_base64','')

             fn=d.get('filename','')
             if fn=='': fn=cfg['default_archive_name']

             r=convert_upload_string_to_file({'file_content_base64':x, 'filename':fn})
             if r['return']>0: return r

             if 'file_content_base64' in d: del(d['file_content_base64'])

       rr.update(d)

    # Restore original output
    i['out']=o

    return rr","['def' 'perform_remote_action' '(' 'i' ')' ':'
 '# Import modules compatible with Python 2.x and 3.x' 'import' 'urllib'
 'try' ':' 'import' 'urllib' '.' 'request' 'as' 'urllib2' 'except' ':'
 'import' 'urllib2' '# pragma: no cover' 'try' ':' 'from' 'urllib' '.'
 'parse' 'import' 'urlencode' 'except' ':' 'from' 'urllib' 'import'
 'urlencode' '# pragma: no cover' 'rr' '=' '{' ""'return'"" ':' '0' '}'
 '# Get action' 'act' '=' 'i' '.' 'get' '(' ""'action'"" ',' ""''"" ')'
 '# Check output' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')' 'if' 'o'
 '==' ""'con'"" ':' ""#       out('Initiating remote access ...')""
 ""#       out('')"" 'i' '[' ""'out'"" ']' '=' ""'con'"" 'i' '[' ""'quiet'"" ']'
 '=' ""'yes'"" 'if' 'act' '==' ""'pull'"" ':' 'i' '[' ""'out'"" ']' '=' ""'json'""
 'else' ':' 'i' '[' ""'out'"" ']' '=' ""'json'"" '#    # Clean up input'
 ""#    if o!='json_file': ""
 ""#       rr['out']='json' # Decided to return json to show that it's remote ...""
 'if' ""'cid'"" 'in' 'i' ':' 'del' '(' 'i' '[' ""'cid'"" ']' ')'
 '# already processed' '# Get URL' 'url' '=' 'i' '.' 'get' '('
 ""'remote_server_url'"" ',' ""''"" ')' '# Process i' 'if'
 ""'remote_server_url'"" 'in' 'i' ':' 'del' '(' 'i' '['
 ""'remote_server_url'"" ']' ')' '# Pre process if push file ...' 'if' 'act'
 '==' ""'push'"" ':' '# Check file' 'fn' '=' 'i' '.' 'get' '(' ""'filename'""
 ',' ""''"" ')' 'if' 'fn' '==' ""''"" ':' 'x' '=' 'i' '.' 'get' '(' ""'cids'""
 ',' '[' ']' ')' 'if' 'len' '(' 'x' ')' '>' '0' ':' 'fn' '=' 'x' '[' '0'
 ']' 'if' 'fn' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' ""'filename is empty'"" '}' 'if' 'not' 'os' '.' 'path' '.' 'isfile' '('
 'fn' ')' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':' ""'file '""
 '+' 'fn' '+' ""' not found'"" '}' 'rx' '=' 'convert_file_to_upload_string'
 '(' '{' ""'filename'"" ':' 'fn' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'rx' 'i' '[' ""'file_content_base64'"" ']' '=' 'rx' '['
 ""'file_content_base64'"" ']' '# Leave only filename without path' 'i' '['
 ""'filename'"" ']' '=' 'os' '.' 'path' '.' 'basename' '(' 'fn' ')'
 '# Prepare post variables' 'r' '=' 'dumps_json' '(' '{' ""'dict'"" ':' 'i'
 ',' ""'skip_indent'"" ':' ""'yes'"" '}' ')' 'if' 'r' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'r' 's' '=' 'r' '[' ""'string'"" ']' '.' 'encode' '('
 ""'utf8'"" ')' 'post' '=' 'urlencode' '(' '{' ""'ck_json'"" ':' 's' '}' ')'
 'if' 'sys' '.' 'version_info' '[' '0' ']' '>' '2' ':' 'post' '=' 'post'
 '.' 'encode' '(' ""'utf8'"" ')' '# If auth' 'au' '=' 'i' '.' 'get' '('
 ""'remote_server_user'"" ',' ""''"" ')' 'if' 'au' '!=' ""''"" ':' 'del' '(' 'i'
 '[' ""'remote_server_user'"" ']' ')' 'ap' '=' 'i' '.' 'get' '('
 ""'remote_server_pass'"" ',' ""''"" ')' 'if' 'ap' '!=' ""''"" ':' 'del' '(' 'i'
 '[' ""'remote_server_pass'"" ']' ')' 'auth' '=' 'urllib2' '.'
 'HTTPPasswordMgrWithDefaultRealm' '(' ')' 'auth' '.' 'add_password' '('
 'None' ',' 'url' ',' 'au' ',' 'ap' ')' 'urllib2' '.' 'install_opener' '('
 'urllib2' '.' 'build_opener' '(' 'urllib2' '.' 'HTTPBasicAuthHandler' '('
 'auth' ')' ')' ')' '# Prepare request' 'request' '=' 'urllib2' '.'
 'Request' '(' 'url' ',' 'post' ')' '# Connect' 'try' ':' 'f' '='
 'urllib2' '.' 'urlopen' '(' 'request' ')' 'except' 'Exception' 'as' 'e'
 ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'Access to remote CK repository failed ('"" '+' 'format' '(' 'e' ')' '+'
 ""')'"" '}' '# Read from Internet' 'try' ':' 's' '=' 'f' '.' 'read' '(' ')'
 'f' '.' 'close' '(' ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'Failed reading stream from remote CK web service ('"" '+' 'format' '('
 'e' ')' '+' ""')'"" '}' '# Check output' 'try' ':' 's' '=' 's' '.' 'decode'
 '(' ""'utf8'"" ')' 'except' 'Exception' 'as' 'e' ':' 'pass' 'if' 'o' '=='
 ""'con'"" 'and' 'act' '!=' ""'pull'"" ':' 'out' '(' 's' '.' 'rstrip' '(' ')'
 ')' 'else' ':' '# Try to convert output to dictionary' 'r' '='
 'convert_json_str_to_dict' '(' '{' ""'str'"" ':' 's' ','
 ""'skip_quote_replacement'"" ':' ""'yes'"" '}' ')' 'if' 'r' '[' ""'return'""
 ']' '>' '0' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'can\\'t parse output from remote CK server ('"" '+' 'r' '[' ""'error'""
 ']' '+' ""'):\\n'"" '+' 's' '[' ':' '256' ']' '+' ""'\\n\\n...)'"" '}' 'd'
 '=' 'r' '[' ""'dict'"" ']' 'if' ""'return'"" 'in' 'd' ':' 'd' '[' ""'return'""
 ']' '=' 'int' '(' 'd' '[' ""'return'"" ']' ')'
 ""# Fix for some strange behavior when 'return' is not integer - should check why ...""
 'if' 'd' '.' 'get' '(' ""'return'"" ',' '0' ')' '>' '0' ':' 'return' 'd'
 '# Post process if pull file ...' 'if' 'act' '==' ""'pull'"" ':' 'if' 'o'
 '!=' ""'json'"" 'and' 'o' '!=' ""'json_file'"" ':'
 '# Convert encoded file to real file ...' 'x' '=' 'd' '.' 'get' '('
 ""'file_content_base64'"" ',' ""''"" ')' 'fn' '=' 'd' '.' 'get' '('
 ""'filename'"" ',' ""''"" ')' 'if' 'fn' '==' ""''"" ':' 'fn' '=' 'cfg' '['
 ""'default_archive_name'"" ']' 'r' '=' 'convert_upload_string_to_file' '('
 '{' ""'file_content_base64'"" ':' 'x' ',' ""'filename'"" ':' 'fn' '}' ')'
 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'if'
 ""'file_content_base64'"" 'in' 'd' ':' 'del' '(' 'd' '['
 ""'file_content_base64'"" ']' ')' 'rr' '.' 'update' '(' 'd' ')'
 '# Restore original output' 'i' '[' ""'out'"" ']' '=' 'o' 'return' 'rr']","Input:  { See 'perform_action' function }
    Output: { See 'perform_action' function }","['Input' ':' '{' 'See' 'perform_action' 'function' '}' 'Output' ':' '{'
 'See' 'perform_action' 'function' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L3118-L3261
ctuning/ck,ck/kernel.py,perform_action,"def perform_action(i):
    """"""
    Input:  {
              all parameters from function 'access'

              (web)         - if 'yes', called from the web

              (common_func) - if 'yes', ignore search for modules 
                                        and call common func from the CK kernel

              (local)       - if 'yes', run locally even if remote repo ...
            }

    Output: {
              return  - return code =  0, if successful
                                         >  0, if error
              (error) - error text if return > 0

              (out)   - if action change output, return it
              Output from the module/action
            }
    """"""

    # Check action
    action=i.get('action','')
    if action=='':
       action='short_help'
    elif action=='-?' or action=='-h' or action=='--help':
       action='help'

    # Check web
    wb=i.get('web','')

    # Substitute # in CIDs
    cid=i.get('cid','')
    cids=i.get('cids',[])

    out=i.get('out','')

    need_subst=False
    rc={} # If CID from current directory

    if cid.startswith(cfg['detect_cur_cid']) or cid.startswith(cfg['detect_cur_cid1']):
       need_subst=True
    else:
       for c in cids:
           if c.startswith(cfg['detect_cur_cid']) or c.startswith(cfg['detect_cur_cid1']): 
              need_subst=True
              break

    # If need to substitute #, attempt to detect current CID
    if need_subst:
       rc=detect_cid_in_current_path({})
       if rc['return']>0: return rc

    # Process cid (module or CID)
    module_uoa=cid
    if cid.find(':')>=0 or cid.startswith(cfg['detect_cur_cid']) or cid.startswith(cfg['detect_cur_cid1']):
       # Means that CID
       r=parse_cid({'cid':cid, 'cur_cid':rc})
       if r['return']>0: return r
       module_uoa=r.get('module_uoa','')

       duoa=r.get('data_uoa','')
       if duoa!='': i['data_uoa']=duoa

       ruoa=r.get('repo_uoa','')
       if ruoa!='': i['repo_uoa']=ruoa


    # If module_uoa exists in input, set module_uoa
    if i.get('module_uoa','')!='': module_uoa=i['module_uoa']
    i['module_uoa']=module_uoa

    # Check if repo exists and possibly remote!
    remote=False

    local=i.get('local','')

    rs=i.get('remote_server_url','')
    if rs=='': 
       ruoa=i.get('repo_uoa','')
       if ruoa!='' and ruoa.find('*')<0 and ruoa.find('?')<0:
          rq=load_repo_info_from_cache({'repo_uoa':ruoa})
          if rq['return']>0: return rq

          dd=rq.get('dict',{})
          if dd.get('remote','')=='yes' and local!='yes':
             rs=dd.get('url','')
             if rs=='':
                return {'return':1, 'error':'URL of remote repository is not defined'}

             i['remote_server_url']=rs

             if dd.get('remote_user','')!='':
                i['remote_server_user']=dd['remote_user']

             # It is completely unsave - just for proof of concept ...
             if dd.get('remote_password','')!='':
                i['remote_server_pass']=dd['remote_password']

             if dd.get('remote_repo_uoa','')!='':
                i['repo_uoa']=dd['remote_repo_uoa']
             else:
                del (i['repo_uoa'])

             if i.get('remote_repo_uoa','')!='':
                i['repo_uoa']=i['remote_repo_uoa']
                del(i['remote_repo_uoa'])

    if rs!='' and local!='yes':
       return perform_remote_action(i)

    # Process and parse cids -> xcids
    xcids=[]

    for c in cids:
       r=parse_cid({'cid':c, 'cur_cid':rc, 'ignore_error':'yes'}) # here we ignore errors, since can be a file name, etc
       if r['return']>0: return r
       xcids.append(r)
    i['xcids']=xcids

    # Check if common function
    cf=i.get('common_func','')

    # Check if no module_uoa, not common function, then try to get module from current 
    module_detected_from_dir=False
    if not need_subst and cf!='yes' and module_uoa=='' and action not in cfg['common_actions']:
       rc=detect_cid_in_current_path({})
       if rc['return']==0:
          module_uoa=rc.get('module_uoa','')
          module_detected_from_dir=True

    display_module_uoa  = module_uoa
    default_action_name = None
    loaded_module       = None

    ## If a specific module_uoa was given (not a wildcard) :
    #
    if cf!='yes' and module_uoa!='' and module_uoa.find('*')<0 and module_uoa.find('?')<0:
       # Find module and load meta description
       rx=load({'module_uoa':cfg['module_name'], 
                'data_uoa':module_uoa})
       if rx['return']>0: return rx

       xmodule_uoa=rx['data_uoa']
       xmodule_uid=rx['data_uid']
       display_module_uoa = '""{}""'.format(xmodule_uoa)
       if xmodule_uoa!=xmodule_uid:
          display_module_uoa += ' ({})'.format(xmodule_uid)

       # Check if allowed to run only from specific repos
       if cfg.get('allow_run_only_from_allowed_repos','')=='yes':
          ruid=rx['repo_uid']

          if ruid not in cfg.get('repo_uids_to_allow_run',[]):
             return {'return':1, 'error':'executing modules from this repository is not allowed'}

       u=rx['dict']
       p=rx['path']

       declared_action      = action in u.get('actions',{})
       default_action_name  = u.get('default_action_name','')
       intercept_kernel     = i.get('{}.intercept_kernel'.format(module_uoa),'')

       if declared_action or default_action_name:
          # Load module
          mcn=u.get('module_name',cfg['module_code_name'])

          r=load_module_from_path({'path':p, 'module_code_name':mcn, 'cfg':u, 'data_uoa':rx['data_uoa']})
          if r['return']>0: return r

          loaded_module=r['code']
          loaded_module.work['self_module_uid']=rx['data_uid']
          loaded_module.work['self_module_uoa']=rx['data_uoa']
          loaded_module.work['self_module_alias']=rx['data_alias']
          loaded_module.work['path']=p

          action1=u.get('actions_redirect',{}).get(action,'')
          if action1=='': action1=action

          if i.get('help','')=='yes' or i.get('api','')=='yes':
             return get_api({'path':p, 'func':action1, 'out':out})

          if wb=='yes' and (out=='con' or out=='web') and u.get('actions',{}).get(action,{}).get('for_web','')!='yes':
             return {'return':1, 'error':'this action is not supported in remote/web mode'}

          if declared_action:
              a=getattr(loaded_module, action1)
              return a(i)
          elif default_action_name and intercept_kernel:
              a=getattr(loaded_module, default_action_name)
              return a(i)
          # otherwise fall through and try a ""special"" kernel method first


    # Check if action == special keyword (add, delete, list, etc)
    if (module_uoa!='' and action in cfg['common_actions']) or \
       ((module_uoa=='' or module_detected_from_dir) and action in cfg['actions']):
       # Check function redirect - needed if action 
       #   is the same as internal python keywords such as list
       action1=cfg['actions_redirect'].get(action,'')
       if action1=='': action1=action

       if i.get('help','')=='yes' or i.get('api','')=='yes':
          return get_api({'path':'', 'func':action1, 'out':out})

       if wb=='yes' and (out=='con' or out=='web') and cfg.get('actions',{}).get(action,{}).get('for_web','')!='yes':
          return {'return':1, 'error':'this action is not supported in remote/web mode '}

       a=getattr(sys.modules[__name__], action1)
       return a(i)

    if default_action_name:
       a=getattr(loaded_module, default_action_name)
       return a(i)

    # Prepare error
    if module_uoa=='':
       er='in kernel'
    else:
       er='in module '+display_module_uoa

    return {'return':1,'error':'action ""'+action+'"" not found '+er}",python,"def perform_action(i):
    """"""
    Input:  {
              all parameters from function 'access'

              (web)         - if 'yes', called from the web

              (common_func) - if 'yes', ignore search for modules 
                                        and call common func from the CK kernel

              (local)       - if 'yes', run locally even if remote repo ...
            }

    Output: {
              return  - return code =  0, if successful
                                         >  0, if error
              (error) - error text if return > 0

              (out)   - if action change output, return it
              Output from the module/action
            }
    """"""

    # Check action
    action=i.get('action','')
    if action=='':
       action='short_help'
    elif action=='-?' or action=='-h' or action=='--help':
       action='help'

    # Check web
    wb=i.get('web','')

    # Substitute # in CIDs
    cid=i.get('cid','')
    cids=i.get('cids',[])

    out=i.get('out','')

    need_subst=False
    rc={} # If CID from current directory

    if cid.startswith(cfg['detect_cur_cid']) or cid.startswith(cfg['detect_cur_cid1']):
       need_subst=True
    else:
       for c in cids:
           if c.startswith(cfg['detect_cur_cid']) or c.startswith(cfg['detect_cur_cid1']): 
              need_subst=True
              break

    # If need to substitute #, attempt to detect current CID
    if need_subst:
       rc=detect_cid_in_current_path({})
       if rc['return']>0: return rc

    # Process cid (module or CID)
    module_uoa=cid
    if cid.find(':')>=0 or cid.startswith(cfg['detect_cur_cid']) or cid.startswith(cfg['detect_cur_cid1']):
       # Means that CID
       r=parse_cid({'cid':cid, 'cur_cid':rc})
       if r['return']>0: return r
       module_uoa=r.get('module_uoa','')

       duoa=r.get('data_uoa','')
       if duoa!='': i['data_uoa']=duoa

       ruoa=r.get('repo_uoa','')
       if ruoa!='': i['repo_uoa']=ruoa


    # If module_uoa exists in input, set module_uoa
    if i.get('module_uoa','')!='': module_uoa=i['module_uoa']
    i['module_uoa']=module_uoa

    # Check if repo exists and possibly remote!
    remote=False

    local=i.get('local','')

    rs=i.get('remote_server_url','')
    if rs=='': 
       ruoa=i.get('repo_uoa','')
       if ruoa!='' and ruoa.find('*')<0 and ruoa.find('?')<0:
          rq=load_repo_info_from_cache({'repo_uoa':ruoa})
          if rq['return']>0: return rq

          dd=rq.get('dict',{})
          if dd.get('remote','')=='yes' and local!='yes':
             rs=dd.get('url','')
             if rs=='':
                return {'return':1, 'error':'URL of remote repository is not defined'}

             i['remote_server_url']=rs

             if dd.get('remote_user','')!='':
                i['remote_server_user']=dd['remote_user']

             # It is completely unsave - just for proof of concept ...
             if dd.get('remote_password','')!='':
                i['remote_server_pass']=dd['remote_password']

             if dd.get('remote_repo_uoa','')!='':
                i['repo_uoa']=dd['remote_repo_uoa']
             else:
                del (i['repo_uoa'])

             if i.get('remote_repo_uoa','')!='':
                i['repo_uoa']=i['remote_repo_uoa']
                del(i['remote_repo_uoa'])

    if rs!='' and local!='yes':
       return perform_remote_action(i)

    # Process and parse cids -> xcids
    xcids=[]

    for c in cids:
       r=parse_cid({'cid':c, 'cur_cid':rc, 'ignore_error':'yes'}) # here we ignore errors, since can be a file name, etc
       if r['return']>0: return r
       xcids.append(r)
    i['xcids']=xcids

    # Check if common function
    cf=i.get('common_func','')

    # Check if no module_uoa, not common function, then try to get module from current 
    module_detected_from_dir=False
    if not need_subst and cf!='yes' and module_uoa=='' and action not in cfg['common_actions']:
       rc=detect_cid_in_current_path({})
       if rc['return']==0:
          module_uoa=rc.get('module_uoa','')
          module_detected_from_dir=True

    display_module_uoa  = module_uoa
    default_action_name = None
    loaded_module       = None

    ## If a specific module_uoa was given (not a wildcard) :
    #
    if cf!='yes' and module_uoa!='' and module_uoa.find('*')<0 and module_uoa.find('?')<0:
       # Find module and load meta description
       rx=load({'module_uoa':cfg['module_name'], 
                'data_uoa':module_uoa})
       if rx['return']>0: return rx

       xmodule_uoa=rx['data_uoa']
       xmodule_uid=rx['data_uid']
       display_module_uoa = '""{}""'.format(xmodule_uoa)
       if xmodule_uoa!=xmodule_uid:
          display_module_uoa += ' ({})'.format(xmodule_uid)

       # Check if allowed to run only from specific repos
       if cfg.get('allow_run_only_from_allowed_repos','')=='yes':
          ruid=rx['repo_uid']

          if ruid not in cfg.get('repo_uids_to_allow_run',[]):
             return {'return':1, 'error':'executing modules from this repository is not allowed'}

       u=rx['dict']
       p=rx['path']

       declared_action      = action in u.get('actions',{})
       default_action_name  = u.get('default_action_name','')
       intercept_kernel     = i.get('{}.intercept_kernel'.format(module_uoa),'')

       if declared_action or default_action_name:
          # Load module
          mcn=u.get('module_name',cfg['module_code_name'])

          r=load_module_from_path({'path':p, 'module_code_name':mcn, 'cfg':u, 'data_uoa':rx['data_uoa']})
          if r['return']>0: return r

          loaded_module=r['code']
          loaded_module.work['self_module_uid']=rx['data_uid']
          loaded_module.work['self_module_uoa']=rx['data_uoa']
          loaded_module.work['self_module_alias']=rx['data_alias']
          loaded_module.work['path']=p

          action1=u.get('actions_redirect',{}).get(action,'')
          if action1=='': action1=action

          if i.get('help','')=='yes' or i.get('api','')=='yes':
             return get_api({'path':p, 'func':action1, 'out':out})

          if wb=='yes' and (out=='con' or out=='web') and u.get('actions',{}).get(action,{}).get('for_web','')!='yes':
             return {'return':1, 'error':'this action is not supported in remote/web mode'}

          if declared_action:
              a=getattr(loaded_module, action1)
              return a(i)
          elif default_action_name and intercept_kernel:
              a=getattr(loaded_module, default_action_name)
              return a(i)
          # otherwise fall through and try a ""special"" kernel method first


    # Check if action == special keyword (add, delete, list, etc)
    if (module_uoa!='' and action in cfg['common_actions']) or \
       ((module_uoa=='' or module_detected_from_dir) and action in cfg['actions']):
       # Check function redirect - needed if action 
       #   is the same as internal python keywords such as list
       action1=cfg['actions_redirect'].get(action,'')
       if action1=='': action1=action

       if i.get('help','')=='yes' or i.get('api','')=='yes':
          return get_api({'path':'', 'func':action1, 'out':out})

       if wb=='yes' and (out=='con' or out=='web') and cfg.get('actions',{}).get(action,{}).get('for_web','')!='yes':
          return {'return':1, 'error':'this action is not supported in remote/web mode '}

       a=getattr(sys.modules[__name__], action1)
       return a(i)

    if default_action_name:
       a=getattr(loaded_module, default_action_name)
       return a(i)

    # Prepare error
    if module_uoa=='':
       er='in kernel'
    else:
       er='in module '+display_module_uoa

    return {'return':1,'error':'action ""'+action+'"" not found '+er}",['def' 'perform_action' '(' ... '+' 'er' '}'],"Input:  {
              all parameters from function 'access'

              (web)         - if 'yes', called from the web

              (common_func) - if 'yes', ignore search for modules 
                                        and call common func from the CK kernel

              (local)       - if 'yes', run locally even if remote repo ...
            }

    Output: {
              return  - return code =  0, if successful
                                         >  0, if error
              (error) - error text if return > 0

              (out)   - if action change output, return it
              Output from the module/action
            }",['Input' ':' '{' 'all' 'parameters' 'from' 'function' 'access'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L3268-L3491
ctuning/ck,ck/kernel.py,get_api,"def get_api(i):
    """"""
    Input:  {
              (path)       - path to module, if comes from access function
                or
              (module_uoa) - if comes from CMD

              (func)       - func for API

              (out)  - output
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              title        - title string
              desc         - original description
              module       - module name
              api          - api as string
              line         - line in found module
            }
    """"""

    p=i.get('path','')
    f=i.get('func','')
    o=i.get('out','')

    muoa=i.get('module_uoa','')

    t=''      # last function description (if redirect to another API)
    t_orig='' # original function description
    l=0       # API line
    a=''      # accumulated API

    if p=='' and muoa!='':
       rx=load({'module_uoa':cfg['module_name'], 
                'data_uoa':muoa})
       if rx['return']>0: return rx
       p=rx['path']

    if p=='':
       p1=os.path.dirname(os.path.dirname(work['dir_default_repo']))
       p=os.path.join(p1, cfg['file_kernel_py'])

       if not os.path.isfile(p):
          return {'return':1, 'error':'kernel not found in '+p}
    else:
       p=os.path.join(p, 'module.py')

    if os.path.isfile(p):
       rx=load_text_file({'text_file':p, 'split_to_list':'yes'})
       if rx['return']>0: return rx

       lst=rx['lst']

       k=-1
       while k<len(lst)-1:
             k+=1
             q=lst[k]

             if q.find('def '+f+'(')>=0 or q.find('def '+f+' (')>=0 or \
                q.find('def\t'+f+'(')>=0 or q.find('def\t'+f+' (')>=0:

                j=k-1
                if j>=0 and lst[j].strip()=='': j-=1

                x='x'
                while j>=0 and x!='' and not x.startswith('###'):
                  x=lst[j].strip()
                  if x!='' and not x.startswith('###'):
                     if x=='#': x=' '
                     elif x.startswith('# '): x=x[2:]
                     t=x+'\n'+t
                  j-=1

                if t!='':
                   l=j+2
                   if t_orig=='': t_orig=t 

                # Find starting point of an API
                j=k+1
                if j<len(lst) and lst[j].find('""""""')>=0: 
                   j+=1

                # Check if redirect to another function
                restart=False
                if j<len(lst):
                   x=lst[j].strip()
                   if x.lower().startswith(""see""):
                      z1=x.find('""')
                      if z1>0:
                         z2=x.find('""',z1+1)
                         if z2>0:
                            f=x[z1+1:z2] # new function name
                            k=-1
                            restart=True # restart search for new function
                   
                if not restart:
                   x=''
                   while x.find('""""""')<0 and j<len(lst):
                       x=lst[j]
                       if x.find('""""""')<0:
                          a+=x+'\n'
                       j+=1

    if t=='' and a=='':
       return {'return':1, 'error':'function not found'}

    dd=t_orig.strip()
    if o=='con':
       out('Description: '+dd)
       out('')
       out('Module: '+p)
       out('')
       out('Line: '+str(l))
       out('')
       out('API:')
       out(a)
    elif o=='web':
       out('<B>Function:</B> '+t+'<BR>')
       out('<BR>')
       out('<B>Module:</B> '+p+'<BR>')
       out('<BR>')
       out('<B>API:</B><BR>')
       out('<pre>')
       out(a)
       out('</pre><BR>')

    return {'return':0, 'title':t, 'desc':dd, 'module':p, 'api':a, 'line':l}",python,"def get_api(i):
    """"""
    Input:  {
              (path)       - path to module, if comes from access function
                or
              (module_uoa) - if comes from CMD

              (func)       - func for API

              (out)  - output
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              title        - title string
              desc         - original description
              module       - module name
              api          - api as string
              line         - line in found module
            }
    """"""

    p=i.get('path','')
    f=i.get('func','')
    o=i.get('out','')

    muoa=i.get('module_uoa','')

    t=''      # last function description (if redirect to another API)
    t_orig='' # original function description
    l=0       # API line
    a=''      # accumulated API

    if p=='' and muoa!='':
       rx=load({'module_uoa':cfg['module_name'], 
                'data_uoa':muoa})
       if rx['return']>0: return rx
       p=rx['path']

    if p=='':
       p1=os.path.dirname(os.path.dirname(work['dir_default_repo']))
       p=os.path.join(p1, cfg['file_kernel_py'])

       if not os.path.isfile(p):
          return {'return':1, 'error':'kernel not found in '+p}
    else:
       p=os.path.join(p, 'module.py')

    if os.path.isfile(p):
       rx=load_text_file({'text_file':p, 'split_to_list':'yes'})
       if rx['return']>0: return rx

       lst=rx['lst']

       k=-1
       while k<len(lst)-1:
             k+=1
             q=lst[k]

             if q.find('def '+f+'(')>=0 or q.find('def '+f+' (')>=0 or \
                q.find('def\t'+f+'(')>=0 or q.find('def\t'+f+' (')>=0:

                j=k-1
                if j>=0 and lst[j].strip()=='': j-=1

                x='x'
                while j>=0 and x!='' and not x.startswith('###'):
                  x=lst[j].strip()
                  if x!='' and not x.startswith('###'):
                     if x=='#': x=' '
                     elif x.startswith('# '): x=x[2:]
                     t=x+'\n'+t
                  j-=1

                if t!='':
                   l=j+2
                   if t_orig=='': t_orig=t 

                # Find starting point of an API
                j=k+1
                if j<len(lst) and lst[j].find('""""""')>=0: 
                   j+=1

                # Check if redirect to another function
                restart=False
                if j<len(lst):
                   x=lst[j].strip()
                   if x.lower().startswith(""see""):
                      z1=x.find('""')
                      if z1>0:
                         z2=x.find('""',z1+1)
                         if z2>0:
                            f=x[z1+1:z2] # new function name
                            k=-1
                            restart=True # restart search for new function
                   
                if not restart:
                   x=''
                   while x.find('""""""')<0 and j<len(lst):
                       x=lst[j]
                       if x.find('""""""')<0:
                          a+=x+'\n'
                       j+=1

    if t=='' and a=='':
       return {'return':1, 'error':'function not found'}

    dd=t_orig.strip()
    if o=='con':
       out('Description: '+dd)
       out('')
       out('Module: '+p)
       out('')
       out('Line: '+str(l))
       out('')
       out('API:')
       out(a)
    elif o=='web':
       out('<B>Function:</B> '+t+'<BR>')
       out('<BR>')
       out('<B>Module:</B> '+p+'<BR>')
       out('<BR>')
       out('<B>API:</B><BR>')
       out('<pre>')
       out(a)
       out('</pre><BR>')

    return {'return':0, 'title':t, 'desc':dd, 'module':p, 'api':a, 'line':l}","['def' 'get_api' '(' 'i' ')' ':' 'p' '=' 'i' '.' 'get' '(' ""'path'"" ','
 ""''"" ')' 'f' '=' 'i' '.' 'get' '(' ""'func'"" ',' ""''"" ')' 'o' '=' 'i' '.'
 'get' '(' ""'out'"" ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get' '('
 ""'module_uoa'"" ',' ""''"" ')' 't' '=' ""''""
 '# last function description (if redirect to another API)' 't_orig' '='
 ""''"" '# original function description' 'l' '=' '0' '# API line' 'a' '='
 ""''"" '# accumulated API' 'if' 'p' '==' ""''"" 'and' 'muoa' '!=' ""''"" ':'
 'rx' '=' 'load' '(' '{' ""'module_uoa'"" ':' 'cfg' '[' ""'module_name'"" ']'
 ',' ""'data_uoa'"" ':' 'muoa' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'rx' 'p' '=' 'rx' '[' ""'path'"" ']' 'if' 'p' '==' ""''"" ':'
 'p1' '=' 'os' '.' 'path' '.' 'dirname' '(' 'os' '.' 'path' '.' 'dirname'
 '(' 'work' '[' ""'dir_default_repo'"" ']' ')' ')' 'p' '=' 'os' '.' 'path'
 '.' 'join' '(' 'p1' ',' 'cfg' '[' ""'file_kernel_py'"" ']' ')' 'if' 'not'
 'os' '.' 'path' '.' 'isfile' '(' 'p' ')' ':' 'return' '{' ""'return'"" ':'
 '1' ',' ""'error'"" ':' ""'kernel not found in '"" '+' 'p' '}' 'else' ':' 'p'
 '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' ""'module.py'"" ')' 'if' 'os'
 '.' 'path' '.' 'isfile' '(' 'p' ')' ':' 'rx' '=' 'load_text_file' '(' '{'
 ""'text_file'"" ':' 'p' ',' ""'split_to_list'"" ':' ""'yes'"" '}' ')' 'if' 'rx'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'lst' '=' 'rx' '[' ""'lst'""
 ']' 'k' '=' '-' '1' 'while' 'k' '<' 'len' '(' 'lst' ')' '-' '1' ':' 'k'
 '+=' '1' 'q' '=' 'lst' '[' 'k' ']' 'if' 'q' '.' 'find' '(' ""'def '"" '+'
 'f' '+' ""'('"" ')' '>=' '0' 'or' 'q' '.' 'find' '(' ""'def '"" '+' 'f' '+'
 ""' ('"" ')' '>=' '0' 'or' 'q' '.' 'find' '(' ""'def\\t'"" '+' 'f' '+' ""'('""
 ')' '>=' '0' 'or' 'q' '.' 'find' '(' ""'def\\t'"" '+' 'f' '+' ""' ('"" ')'
 '>=' '0' ':' 'j' '=' 'k' '-' '1' 'if' 'j' '>=' '0' 'and' 'lst' '[' 'j'
 ']' '.' 'strip' '(' ')' '==' ""''"" ':' 'j' '-=' '1' 'x' '=' ""'x'"" 'while'
 'j' '>=' '0' 'and' 'x' '!=' ""''"" 'and' 'not' 'x' '.' 'startswith' '('
 ""'###'"" ')' ':' 'x' '=' 'lst' '[' 'j' ']' '.' 'strip' '(' ')' 'if' 'x'
 '!=' ""''"" 'and' 'not' 'x' '.' 'startswith' '(' ""'###'"" ')' ':' 'if' 'x'
 '==' ""'#'"" ':' 'x' '=' ""' '"" 'elif' 'x' '.' 'startswith' '(' ""'# '"" ')'
 ':' 'x' '=' 'x' '[' '2' ':' ']' 't' '=' 'x' '+' ""'\\n'"" '+' 't' 'j' '-='
 '1' 'if' 't' '!=' ""''"" ':' 'l' '=' 'j' '+' '2' 'if' 't_orig' '==' ""''""
 ':' 't_orig' '=' 't' '# Find starting point of an API' 'j' '=' 'k' '+'
 '1' 'if' 'j' '<' 'len' '(' 'lst' ')' 'and' 'lst' '[' 'j' ']' '.' 'find'
 '(' '\'""""""\'' ')' '>=' '0' ':' 'j' '+=' '1'
 '# Check if redirect to another function' 'restart' '=' 'False' 'if' 'j'
 '<' 'len' '(' 'lst' ')' ':' 'x' '=' 'lst' '[' 'j' ']' '.' 'strip' '(' ')'
 'if' 'x' '.' 'lower' '(' ')' '.' 'startswith' '(' '""see""' ')' ':' 'z1'
 '=' 'x' '.' 'find' '(' '\'""\'' ')' 'if' 'z1' '>' '0' ':' 'z2' '=' 'x' '.'
 'find' '(' '\'""\'' ',' 'z1' '+' '1' ')' 'if' 'z2' '>' '0' ':' 'f' '=' 'x'
 '[' 'z1' '+' '1' ':' 'z2' ']' '# new function name' 'k' '=' '-' '1'
 'restart' '=' 'True' '# restart search for new function' 'if' 'not'
 'restart' ':' 'x' '=' ""''"" 'while' 'x' '.' 'find' '(' '\'""""""\'' ')' '<'
 '0' 'and' 'j' '<' 'len' '(' 'lst' ')' ':' 'x' '=' 'lst' '[' 'j' ']' 'if'
 'x' '.' 'find' '(' '\'""""""\'' ')' '<' '0' ':' 'a' '+=' 'x' '+' ""'\\n'"" 'j'
 '+=' '1' 'if' 't' '==' ""''"" 'and' 'a' '==' ""''"" ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':' ""'function not found'"" '}' 'dd' '='
 't_orig' '.' 'strip' '(' ')' 'if' 'o' '==' ""'con'"" ':' 'out' '('
 ""'Description: '"" '+' 'dd' ')' 'out' '(' ""''"" ')' 'out' '(' ""'Module: '""
 '+' 'p' ')' 'out' '(' ""''"" ')' 'out' '(' ""'Line: '"" '+' 'str' '(' 'l' ')'
 ')' 'out' '(' ""''"" ')' 'out' '(' ""'API:'"" ')' 'out' '(' 'a' ')' 'elif'
 'o' '==' ""'web'"" ':' 'out' '(' ""'<B>Function:</B> '"" '+' 't' '+' ""'<BR>'""
 ')' 'out' '(' ""'<BR>'"" ')' 'out' '(' ""'<B>Module:</B> '"" '+' 'p' '+'
 ""'<BR>'"" ')' 'out' '(' ""'<BR>'"" ')' 'out' '(' ""'<B>API:</B><BR>'"" ')'
 'out' '(' ""'<pre>'"" ')' 'out' '(' 'a' ')' 'out' '(' ""'</pre><BR>'"" ')'
 'return' '{' ""'return'"" ':' '0' ',' ""'title'"" ':' 't' ',' ""'desc'"" ':'
 'dd' ',' ""'module'"" ':' 'p' ',' ""'api'"" ':' 'a' ',' ""'line'"" ':' 'l' '}']","Input:  {
              (path)       - path to module, if comes from access function
                or
              (module_uoa) - if comes from CMD

              (func)       - func for API

              (out)  - output
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              title        - title string
              desc         - original description
              module       - module name
              api          - api as string
              line         - line in found module
            }","['Input' ':' '{' '(' 'path' ')' '-' 'path' 'to' 'module' 'if' 'comes'
 'from' 'access' 'function' 'or' '(' 'module_uoa' ')' '-' 'if' 'comes'
 'from' 'CMD']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L3498-L3628
ctuning/ck,ck/kernel.py,parse_cid,"def parse_cid(i):
    """"""
    Input:  {
              cid            - in format (REPO_UOA:)MODULE_UOA:DATA_UOA 
              (cur_cid)      - output of function 'detect_cid_in_current_path'
              (ignore_error) - if 'yes', ignore wrong format
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              data_uoa     - data UOA
              module_uoa   - module UOA
              (repo_uoa)   - repo UOA
            }
    """"""

    r={'return':0}
    c=i['cid'].strip()

    ie=i.get('ignore_error','')

    cc=i.get('cur_cid', {})

    a0=cc.get('repo_uoa','')
    m0=cc.get('module_uoa','')
    d0=cc.get('data_uoa','')

    if c.startswith(cfg['detect_cur_cid']) or c.startswith(cfg['detect_cur_cid1']):
       c=c[1:]

    x=c.split(':')
    if len(x)<2 and m0=='':
       if ie!='yes': 
          return {'return':1, 'error':'unknown CID format'}
       else: 
          return r

    if c=='':
       r['repo_uoa']=a0
       r['module_uoa']=m0
       r['data_uoa']=d0
    elif len(x)==1:
       if a0!='': r['repo_uoa']=a0
       r['module_uoa']=m0
       r['data_uoa']=x[0]
    elif len(x)==2:
       if a0!='': r['repo_uoa']=a0
       r['module_uoa']=x[0]
       r['data_uoa']=x[1]
    elif len(x)==3:
       r['repo_uoa']=x[0]
       r['module_uoa']=x[1]
       r['data_uoa']=x[2]
    else:
       if ie!='yes': 
          return {'return':1, 'error':'unknown CID format'}

    return r",python,"def parse_cid(i):
    """"""
    Input:  {
              cid            - in format (REPO_UOA:)MODULE_UOA:DATA_UOA 
              (cur_cid)      - output of function 'detect_cid_in_current_path'
              (ignore_error) - if 'yes', ignore wrong format
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              data_uoa     - data UOA
              module_uoa   - module UOA
              (repo_uoa)   - repo UOA
            }
    """"""

    r={'return':0}
    c=i['cid'].strip()

    ie=i.get('ignore_error','')

    cc=i.get('cur_cid', {})

    a0=cc.get('repo_uoa','')
    m0=cc.get('module_uoa','')
    d0=cc.get('data_uoa','')

    if c.startswith(cfg['detect_cur_cid']) or c.startswith(cfg['detect_cur_cid1']):
       c=c[1:]

    x=c.split(':')
    if len(x)<2 and m0=='':
       if ie!='yes': 
          return {'return':1, 'error':'unknown CID format'}
       else: 
          return r

    if c=='':
       r['repo_uoa']=a0
       r['module_uoa']=m0
       r['data_uoa']=d0
    elif len(x)==1:
       if a0!='': r['repo_uoa']=a0
       r['module_uoa']=m0
       r['data_uoa']=x[0]
    elif len(x)==2:
       if a0!='': r['repo_uoa']=a0
       r['module_uoa']=x[0]
       r['data_uoa']=x[1]
    elif len(x)==3:
       r['repo_uoa']=x[0]
       r['module_uoa']=x[1]
       r['data_uoa']=x[2]
    else:
       if ie!='yes': 
          return {'return':1, 'error':'unknown CID format'}

    return r","['def' 'parse_cid' '(' 'i' ')' ':' 'r' '=' '{' ""'return'"" ':' '0' '}' 'c'
 '=' 'i' '[' ""'cid'"" ']' '.' 'strip' '(' ')' 'ie' '=' 'i' '.' 'get' '('
 ""'ignore_error'"" ',' ""''"" ')' 'cc' '=' 'i' '.' 'get' '(' ""'cur_cid'"" ','
 '{' '}' ')' 'a0' '=' 'cc' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'm0'
 '=' 'cc' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'd0' '=' 'cc' '.'
 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if' 'c' '.' 'startswith' '(' 'cfg'
 '[' ""'detect_cur_cid'"" ']' ')' 'or' 'c' '.' 'startswith' '(' 'cfg' '['
 ""'detect_cur_cid1'"" ']' ')' ':' 'c' '=' 'c' '[' '1' ':' ']' 'x' '=' 'c'
 '.' 'split' '(' ""':'"" ')' 'if' 'len' '(' 'x' ')' '<' '2' 'and' 'm0' '=='
 ""''"" ':' 'if' 'ie' '!=' ""'yes'"" ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'unknown CID format'"" '}' 'else' ':' 'return' 'r' 'if' 'c'
 '==' ""''"" ':' 'r' '[' ""'repo_uoa'"" ']' '=' 'a0' 'r' '[' ""'module_uoa'""
 ']' '=' 'm0' 'r' '[' ""'data_uoa'"" ']' '=' 'd0' 'elif' 'len' '(' 'x' ')'
 '==' '1' ':' 'if' 'a0' '!=' ""''"" ':' 'r' '[' ""'repo_uoa'"" ']' '=' 'a0'
 'r' '[' ""'module_uoa'"" ']' '=' 'm0' 'r' '[' ""'data_uoa'"" ']' '=' 'x' '['
 '0' ']' 'elif' 'len' '(' 'x' ')' '==' '2' ':' 'if' 'a0' '!=' ""''"" ':' 'r'
 '[' ""'repo_uoa'"" ']' '=' 'a0' 'r' '[' ""'module_uoa'"" ']' '=' 'x' '[' '0'
 ']' 'r' '[' ""'data_uoa'"" ']' '=' 'x' '[' '1' ']' 'elif' 'len' '(' 'x' ')'
 '==' '3' ':' 'r' '[' ""'repo_uoa'"" ']' '=' 'x' '[' '0' ']' 'r' '['
 ""'module_uoa'"" ']' '=' 'x' '[' '1' ']' 'r' '[' ""'data_uoa'"" ']' '=' 'x'
 '[' '2' ']' 'else' ':' 'if' 'ie' '!=' ""'yes'"" ':' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'unknown CID format'"" '}' 'return' 'r']","Input:  {
              cid            - in format (REPO_UOA:)MODULE_UOA:DATA_UOA 
              (cur_cid)      - output of function 'detect_cid_in_current_path'
              (ignore_error) - if 'yes', ignore wrong format
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              data_uoa     - data UOA
              module_uoa   - module UOA
              (repo_uoa)   - repo UOA
            }","['Input' ':' '{' 'cid' '-' 'in' 'format' '(' 'REPO_UOA' ':' ')'
 'MODULE_UOA' ':' 'DATA_UOA' '(' 'cur_cid' ')' '-' 'output' 'of'
 'function' 'detect_cid_in_current_path' '(' 'ignore_error' ')' '-' 'if'
 'yes' 'ignore' 'wrong' 'format' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L3635-L3695
ctuning/ck,ck/kernel.py,create_entry,"def create_entry(i):
    """"""
    Input:  {
              path       - path where to create an entry
              (data_uoa) - data UOA
              (data_uid) - if uoa is an alias, we can force data UID

              (force)    - if 'yes', force creation even if directory already exists
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if data entry already exists
                                         >  0, if error
              (error)      - error text if return > 0

              path         - path to data entry
              data_uid     - data UID (from UOA)
              data_alias   - data alias (from UOA)
              data_uoa     - data alias or data uid if data alias==''
            }
    """"""

    p0=i.get('path','')
    d=i.get('data_uoa','')
    di=i.get('data_uid','')

    xforce=i.get('force','')
    if xforce=='yes':
       force=True
    else:
       force=False

    # If no uoa, generate UID
    alias=''
    uid=''
    if d=='':
       if di=='':
          r=gen_uid({})
          if r['return']>0: return r
          uid=r['data_uid']
       else:
          uid=di

          # Check if already exists
          r=find_path_to_entry({'path':p0, 'data_uoa':uid})
          if r['return']>0 and r['return']!=16: return r
          elif r['return']==0:
             r['return']=16
             return r

       alias=''
    else:
       # Check if already exists
       if not force:
          r=find_path_to_entry({'path':p0, 'data_uoa':d})
          if r['return']>0 and r['return']!=16: return r
          elif r['return']==0:
             r['return']=16
             return r

       if is_uid(d):
          uid=d
          alias=''
       else:
          alias=d
          if di!='':
             uid=i['data_uid']
          else: 
             r=gen_uid({})
             if r['return']>0: return r
             uid=r['data_uid']

    if alias!='':
       p=os.path.join(p0, alias)
    else:
       p=os.path.join(p0, uid)

    # Check alias disambiguation
    if alias!='':
       p1=os.path.join(p0, cfg['subdir_ck_ext'])
       if not os.path.isdir(p1):
          # Create .cm directory
          try:    # pragma: no cover
             os.mkdir(p1)
          except Exception as e:
             return {'return':1, 'error':format(e)}

       # Check if alias->uid exist
       p3=os.path.join(p1, cfg['file_alias_a'] + alias)
       if os.path.isfile(p3):     # pragma: no cover
          try:
             fx=open(p3)
             uid1=fx.readline().strip()
             fx.close()
          except Exception as e:
             None

          if uid1!=uid:
             return {'return':1, 'error':'different alias->uid disambiguator already exists in '+p3}

       ru=save_text_file({'text_file':p3, 'string':uid+'\n'})
       if ru['return']>0: return ru

       # Check if uid->alias exist
       p2=os.path.join(p1, cfg['file_alias_u'] + uid)
       if os.path.isfile(p2):     # pragma: no cover
          try:
             fx=open(p2)
             alias1=fx.readline().strip()
             fx.close()
          except Exception as e:
             None

          if alias1!=alias:
             return {'return':1, 'error':'different uid->alias disambiguator already exists in '+p2}

       ru=save_text_file({'text_file':p2, 'string':alias+'\n'})
       if ru['return']>0: return ru

    # Create directory
    if not os.path.exists(p):
       try:
          os.mkdir(p)
       except Exception as e:
          return {'return':1, 'error':format(e)}

    uoa=uid
    if alias!='': uoa=alias

    return {'return':0, 'path':p, 'data_uid':uid, 'data_alias':alias, 'data_uoa':uoa}",python,"def create_entry(i):
    """"""
    Input:  {
              path       - path where to create an entry
              (data_uoa) - data UOA
              (data_uid) - if uoa is an alias, we can force data UID

              (force)    - if 'yes', force creation even if directory already exists
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if data entry already exists
                                         >  0, if error
              (error)      - error text if return > 0

              path         - path to data entry
              data_uid     - data UID (from UOA)
              data_alias   - data alias (from UOA)
              data_uoa     - data alias or data uid if data alias==''
            }
    """"""

    p0=i.get('path','')
    d=i.get('data_uoa','')
    di=i.get('data_uid','')

    xforce=i.get('force','')
    if xforce=='yes':
       force=True
    else:
       force=False

    # If no uoa, generate UID
    alias=''
    uid=''
    if d=='':
       if di=='':
          r=gen_uid({})
          if r['return']>0: return r
          uid=r['data_uid']
       else:
          uid=di

          # Check if already exists
          r=find_path_to_entry({'path':p0, 'data_uoa':uid})
          if r['return']>0 and r['return']!=16: return r
          elif r['return']==0:
             r['return']=16
             return r

       alias=''
    else:
       # Check if already exists
       if not force:
          r=find_path_to_entry({'path':p0, 'data_uoa':d})
          if r['return']>0 and r['return']!=16: return r
          elif r['return']==0:
             r['return']=16
             return r

       if is_uid(d):
          uid=d
          alias=''
       else:
          alias=d
          if di!='':
             uid=i['data_uid']
          else: 
             r=gen_uid({})
             if r['return']>0: return r
             uid=r['data_uid']

    if alias!='':
       p=os.path.join(p0, alias)
    else:
       p=os.path.join(p0, uid)

    # Check alias disambiguation
    if alias!='':
       p1=os.path.join(p0, cfg['subdir_ck_ext'])
       if not os.path.isdir(p1):
          # Create .cm directory
          try:    # pragma: no cover
             os.mkdir(p1)
          except Exception as e:
             return {'return':1, 'error':format(e)}

       # Check if alias->uid exist
       p3=os.path.join(p1, cfg['file_alias_a'] + alias)
       if os.path.isfile(p3):     # pragma: no cover
          try:
             fx=open(p3)
             uid1=fx.readline().strip()
             fx.close()
          except Exception as e:
             None

          if uid1!=uid:
             return {'return':1, 'error':'different alias->uid disambiguator already exists in '+p3}

       ru=save_text_file({'text_file':p3, 'string':uid+'\n'})
       if ru['return']>0: return ru

       # Check if uid->alias exist
       p2=os.path.join(p1, cfg['file_alias_u'] + uid)
       if os.path.isfile(p2):     # pragma: no cover
          try:
             fx=open(p2)
             alias1=fx.readline().strip()
             fx.close()
          except Exception as e:
             None

          if alias1!=alias:
             return {'return':1, 'error':'different uid->alias disambiguator already exists in '+p2}

       ru=save_text_file({'text_file':p2, 'string':alias+'\n'})
       if ru['return']>0: return ru

    # Create directory
    if not os.path.exists(p):
       try:
          os.mkdir(p)
       except Exception as e:
          return {'return':1, 'error':format(e)}

    uoa=uid
    if alias!='': uoa=alias

    return {'return':0, 'path':p, 'data_uid':uid, 'data_alias':alias, 'data_uoa':uoa}","['def' 'create_entry' '(' 'i' ')' ':' 'p0' '=' 'i' '.' 'get' '(' ""'path'""
 ',' ""''"" ')' 'd' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'di' '='
 'i' '.' 'get' '(' ""'data_uid'"" ',' ""''"" ')' 'xforce' '=' 'i' '.' 'get'
 '(' ""'force'"" ',' ""''"" ')' 'if' 'xforce' '==' ""'yes'"" ':' 'force' '='
 'True' 'else' ':' 'force' '=' 'False' '# If no uoa, generate UID' 'alias'
 '=' ""''"" 'uid' '=' ""''"" 'if' 'd' '==' ""''"" ':' 'if' 'di' '==' ""''"" ':'
 'r' '=' 'gen_uid' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'uid' '=' 'r' '[' ""'data_uid'"" ']' 'else' ':' 'uid' '=' 'di'
 '# Check if already exists' 'r' '=' 'find_path_to_entry' '(' '{' ""'path'""
 ':' 'p0' ',' ""'data_uoa'"" ':' 'uid' '}' ')' 'if' 'r' '[' ""'return'"" ']'
 '>' '0' 'and' 'r' '[' ""'return'"" ']' '!=' '16' ':' 'return' 'r' 'elif'
 'r' '[' ""'return'"" ']' '==' '0' ':' 'r' '[' ""'return'"" ']' '=' '16'
 'return' 'r' 'alias' '=' ""''"" 'else' ':' '# Check if already exists' 'if'
 'not' 'force' ':' 'r' '=' 'find_path_to_entry' '(' '{' ""'path'"" ':' 'p0'
 ',' ""'data_uoa'"" ':' 'd' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 'and' 'r' '[' ""'return'"" ']' '!=' '16' ':' 'return' 'r' 'elif' 'r' '['
 ""'return'"" ']' '==' '0' ':' 'r' '[' ""'return'"" ']' '=' '16' 'return' 'r'
 'if' 'is_uid' '(' 'd' ')' ':' 'uid' '=' 'd' 'alias' '=' ""''"" 'else' ':'
 'alias' '=' 'd' 'if' 'di' '!=' ""''"" ':' 'uid' '=' 'i' '[' ""'data_uid'""
 ']' 'else' ':' 'r' '=' 'gen_uid' '(' '{' '}' ')' 'if' 'r' '[' ""'return'""
 ']' '>' '0' ':' 'return' 'r' 'uid' '=' 'r' '[' ""'data_uid'"" ']' 'if'
 'alias' '!=' ""''"" ':' 'p' '=' 'os' '.' 'path' '.' 'join' '(' 'p0' ','
 'alias' ')' 'else' ':' 'p' '=' 'os' '.' 'path' '.' 'join' '(' 'p0' ','
 'uid' ')' '# Check alias disambiguation' 'if' 'alias' '!=' ""''"" ':' 'p1'
 '=' 'os' '.' 'path' '.' 'join' '(' 'p0' ',' 'cfg' '[' ""'subdir_ck_ext'""
 ']' ')' 'if' 'not' 'os' '.' 'path' '.' 'isdir' '(' 'p1' ')' ':'
 '# Create .cm directory' 'try' ':' '# pragma: no cover' 'os' '.' 'mkdir'
 '(' 'p1' ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' 'format' '(' 'e' ')' '}'
 '# Check if alias->uid exist' 'p3' '=' 'os' '.' 'path' '.' 'join' '('
 'p1' ',' 'cfg' '[' ""'file_alias_a'"" ']' '+' 'alias' ')' 'if' 'os' '.'
 'path' '.' 'isfile' '(' 'p3' ')' ':' '# pragma: no cover' 'try' ':' 'fx'
 '=' 'open' '(' 'p3' ')' 'uid1' '=' 'fx' '.' 'readline' '(' ')' '.'
 'strip' '(' ')' 'fx' '.' 'close' '(' ')' 'except' 'Exception' 'as' 'e'
 ':' 'None' 'if' 'uid1' '!=' 'uid' ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'different alias->uid disambiguator already exists in '""
 '+' 'p3' '}' 'ru' '=' 'save_text_file' '(' '{' ""'text_file'"" ':' 'p3' ','
 ""'string'"" ':' 'uid' '+' ""'\\n'"" '}' ')' 'if' 'ru' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'ru' '# Check if uid->alias exist' 'p2' '=' 'os' '.'
 'path' '.' 'join' '(' 'p1' ',' 'cfg' '[' ""'file_alias_u'"" ']' '+' 'uid'
 ')' 'if' 'os' '.' 'path' '.' 'isfile' '(' 'p2' ')' ':'
 '# pragma: no cover' 'try' ':' 'fx' '=' 'open' '(' 'p2' ')' 'alias1' '='
 'fx' '.' 'readline' '(' ')' '.' 'strip' '(' ')' 'fx' '.' 'close' '(' ')'
 'except' 'Exception' 'as' 'e' ':' 'None' 'if' 'alias1' '!=' 'alias' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'different uid->alias disambiguator already exists in '"" '+' 'p2' '}'
 'ru' '=' 'save_text_file' '(' '{' ""'text_file'"" ':' 'p2' ',' ""'string'""
 ':' 'alias' '+' ""'\\n'"" '}' ')' 'if' 'ru' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'ru' '# Create directory' 'if' 'not' 'os' '.' 'path' '.'
 'exists' '(' 'p' ')' ':' 'try' ':' 'os' '.' 'mkdir' '(' 'p' ')' 'except'
 'Exception' 'as' 'e' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' 'format' '(' 'e' ')' '}' 'uoa' '=' 'uid' 'if' 'alias' '!=' ""''"" ':'
 'uoa' '=' 'alias' 'return' '{' ""'return'"" ':' '0' ',' ""'path'"" ':' 'p'
 ',' ""'data_uid'"" ':' 'uid' ',' ""'data_alias'"" ':' 'alias' ','
 ""'data_uoa'"" ':' 'uoa' '}']","Input:  {
              path       - path where to create an entry
              (data_uoa) - data UOA
              (data_uid) - if uoa is an alias, we can force data UID

              (force)    - if 'yes', force creation even if directory already exists
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if data entry already exists
                                         >  0, if error
              (error)      - error text if return > 0

              path         - path to data entry
              data_uid     - data UID (from UOA)
              data_alias   - data alias (from UOA)
              data_uoa     - data alias or data uid if data alias==''
            }","['Input' ':' '{' 'path' '-' 'path' 'where' 'to' 'create' 'an' 'entry' '('
 'data_uoa' ')' '-' 'data' 'UOA' '(' 'data_uid' ')' '-' 'if' 'uoa' 'is'
 'an' 'alias' 'we' 'can' 'force' 'data' 'UID']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L3702-L3832
ctuning/ck,ck/kernel.py,delete_alias,"def delete_alias(i):
    """"""
    Input:  {
              path         - path to the entry
              data_uid     - data UID
              (data_alias) - data alias
              (repo_dict)  - repo cfg if available to check sync
              (share)      - if 'yes', try to rm via GIT
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    rd=i.get('repo_dict',{})
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    if i.get('share','')=='yes': rshared='git'

    p=i['path']
    alias=i.get('data_alias','')
    uid=''

    if alias!='' and os.path.isdir(p):
       p0=os.path.join(p, cfg['subdir_ck_ext'])

       p9=cfg['file_alias_a'] + alias
       p1=os.path.join(p0, p9)

       if rshared!='':
          ppp=os.getcwd()
          os.chdir(p0)

       if os.path.isfile(p1):
          try:
             f=open(p1)
             uid=f.readline().strip()
             f.close()
          except Exception as e:
             None

          if rshared!='':
             ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', p9)
             rx=os.system(ss)

          if os.path.isfile(p1): os.remove(p1)

       if uid=='': uid=i['data_uid']

       if uid!='':
          p9=cfg['file_alias_u'] + uid
          p1=os.path.join(p0, p9)
          if os.path.isfile(p1):
             if rshared!='':
                ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', p9)
                rx=os.system(ss)

             if os.path.isfile(p1): os.remove(p1)

       if rshared!='':
          os.chdir(ppp)

    return {'return':0}",python,"def delete_alias(i):
    """"""
    Input:  {
              path         - path to the entry
              data_uid     - data UID
              (data_alias) - data alias
              (repo_dict)  - repo cfg if available to check sync
              (share)      - if 'yes', try to rm via GIT
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    rd=i.get('repo_dict',{})
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    if i.get('share','')=='yes': rshared='git'

    p=i['path']
    alias=i.get('data_alias','')
    uid=''

    if alias!='' and os.path.isdir(p):
       p0=os.path.join(p, cfg['subdir_ck_ext'])

       p9=cfg['file_alias_a'] + alias
       p1=os.path.join(p0, p9)

       if rshared!='':
          ppp=os.getcwd()
          os.chdir(p0)

       if os.path.isfile(p1):
          try:
             f=open(p1)
             uid=f.readline().strip()
             f.close()
          except Exception as e:
             None

          if rshared!='':
             ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', p9)
             rx=os.system(ss)

          if os.path.isfile(p1): os.remove(p1)

       if uid=='': uid=i['data_uid']

       if uid!='':
          p9=cfg['file_alias_u'] + uid
          p1=os.path.join(p0, p9)
          if os.path.isfile(p1):
             if rshared!='':
                ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', p9)
                rx=os.system(ss)

             if os.path.isfile(p1): os.remove(p1)

       if rshared!='':
          os.chdir(ppp)

    return {'return':0}","['def' 'delete_alias' '(' 'i' ')' ':' 'rd' '=' 'i' '.' 'get' '('
 ""'repo_dict'"" ',' '{' '}' ')' 'rshared' '=' 'rd' '.' 'get' '(' ""'shared'""
 ',' ""''"" ')' 'rsync' '=' 'rd' '.' 'get' '(' ""'sync'"" ',' ""''"" ')' 'if'
 'i' '.' 'get' '(' ""'share'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'rshared' '='
 ""'git'"" 'p' '=' 'i' '[' ""'path'"" ']' 'alias' '=' 'i' '.' 'get' '('
 ""'data_alias'"" ',' ""''"" ')' 'uid' '=' ""''"" 'if' 'alias' '!=' ""''"" 'and'
 'os' '.' 'path' '.' 'isdir' '(' 'p' ')' ':' 'p0' '=' 'os' '.' 'path' '.'
 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'"" ']' ')' 'p9' '=' 'cfg' '['
 ""'file_alias_a'"" ']' '+' 'alias' 'p1' '=' 'os' '.' 'path' '.' 'join' '('
 'p0' ',' 'p9' ')' 'if' 'rshared' '!=' ""''"" ':' 'ppp' '=' 'os' '.'
 'getcwd' '(' ')' 'os' '.' 'chdir' '(' 'p0' ')' 'if' 'os' '.' 'path' '.'
 'isfile' '(' 'p1' ')' ':' 'try' ':' 'f' '=' 'open' '(' 'p1' ')' 'uid' '='
 'f' '.' 'readline' '(' ')' '.' 'strip' '(' ')' 'f' '.' 'close' '(' ')'
 'except' 'Exception' 'as' 'e' ':' 'None' 'if' 'rshared' '!=' ""''"" ':'
 'ss' '=' 'cfg' '[' ""'repo_types'"" ']' '[' 'rshared' ']' '[' ""'rm'"" ']'
 '.' 'replace' '(' ""'$#files#$'"" ',' 'p9' ')' 'rx' '=' 'os' '.' 'system'
 '(' 'ss' ')' 'if' 'os' '.' 'path' '.' 'isfile' '(' 'p1' ')' ':' 'os' '.'
 'remove' '(' 'p1' ')' 'if' 'uid' '==' ""''"" ':' 'uid' '=' 'i' '['
 ""'data_uid'"" ']' 'if' 'uid' '!=' ""''"" ':' 'p9' '=' 'cfg' '['
 ""'file_alias_u'"" ']' '+' 'uid' 'p1' '=' 'os' '.' 'path' '.' 'join' '('
 'p0' ',' 'p9' ')' 'if' 'os' '.' 'path' '.' 'isfile' '(' 'p1' ')' ':' 'if'
 'rshared' '!=' ""''"" ':' 'ss' '=' 'cfg' '[' ""'repo_types'"" ']' '['
 'rshared' ']' '[' ""'rm'"" ']' '.' 'replace' '(' ""'$#files#$'"" ',' 'p9' ')'
 'rx' '=' 'os' '.' 'system' '(' 'ss' ')' 'if' 'os' '.' 'path' '.' 'isfile'
 '(' 'p1' ')' ':' 'os' '.' 'remove' '(' 'p1' ')' 'if' 'rshared' '!=' ""''""
 ':' 'os' '.' 'chdir' '(' 'ppp' ')' 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              path         - path to the entry
              data_uid     - data UID
              (data_alias) - data alias
              (repo_dict)  - repo cfg if available to check sync
              (share)      - if 'yes', try to rm via GIT
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' 'path' '-' 'path' 'to' 'the' 'entry' 'data_uid' '-'
 'data' 'UID' '(' 'data_alias' ')' '-' 'data' 'alias' '(' 'repo_dict' ')'
 '-' 'repo' 'cfg' 'if' 'available' 'to' 'check' 'sync' '(' 'share' ')' '-'
 'if' 'yes' 'try' 'to' 'rm' 'via' 'GIT' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L3839-L3905
ctuning/ck,ck/kernel.py,delete_directory,"def delete_directory(i):
    """"""
    Input:  {
              path - path to delete
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    import shutil

    p=i['path']

    if os.path.isdir(p):
       shutil.rmtree(p, onerror=rm_read_only)

    return {'return':0}",python,"def delete_directory(i):
    """"""
    Input:  {
              path - path to delete
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""

    import shutil

    p=i['path']

    if os.path.isdir(p):
       shutil.rmtree(p, onerror=rm_read_only)

    return {'return':0}","['def' 'delete_directory' '(' 'i' ')' ':' 'import' 'shutil' 'p' '=' 'i'
 '[' ""'path'"" ']' 'if' 'os' '.' 'path' '.' 'isdir' '(' 'p' ')' ':'
 'shutil' '.' 'rmtree' '(' 'p' ',' 'onerror' '=' 'rm_read_only' ')'
 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              path - path to delete
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' 'path' '-' 'path' 'to' 'delete' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L3912-L3932
ctuning/ck,ck/kernel.py,flatten_dict,"def flatten_dict(i):
    """"""
    Any list item is converted to @number=value
    Any dict item is converted to #key=value
    # is always added at the beginning 

    Input:  {
              dict         - python dictionary

              (prefix)     - prefix (for recursion)

              (prune_keys) - list of keys to prune (can have wildcards)
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              dict    - flattened dictionary
            }
    """"""

    prefix='#'
    if i.get('prefix','')!='': prefix=str(i['prefix'])

    a=i['dict']
    aa={}

    pk=i.get('prune_keys','')
    if pk=='': pk=[]

    flatten_dict_internal(a, aa, prefix, pk)

    return {'return':0, 'dict': aa}",python,"def flatten_dict(i):
    """"""
    Any list item is converted to @number=value
    Any dict item is converted to #key=value
    # is always added at the beginning 

    Input:  {
              dict         - python dictionary

              (prefix)     - prefix (for recursion)

              (prune_keys) - list of keys to prune (can have wildcards)
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              dict    - flattened dictionary
            }
    """"""

    prefix='#'
    if i.get('prefix','')!='': prefix=str(i['prefix'])

    a=i['dict']
    aa={}

    pk=i.get('prune_keys','')
    if pk=='': pk=[]

    flatten_dict_internal(a, aa, prefix, pk)

    return {'return':0, 'dict': aa}","['def' 'flatten_dict' '(' 'i' ')' ':' 'prefix' '=' ""'#'"" 'if' 'i' '.'
 'get' '(' ""'prefix'"" ',' ""''"" ')' '!=' ""''"" ':' 'prefix' '=' 'str' '('
 'i' '[' ""'prefix'"" ']' ')' 'a' '=' 'i' '[' ""'dict'"" ']' 'aa' '=' '{' '}'
 'pk' '=' 'i' '.' 'get' '(' ""'prune_keys'"" ',' ""''"" ')' 'if' 'pk' '=='
 ""''"" ':' 'pk' '=' '[' ']' 'flatten_dict_internal' '(' 'a' ',' 'aa' ','
 'prefix' ',' 'pk' ')' 'return' '{' ""'return'"" ':' '0' ',' ""'dict'"" ':'
 'aa' '}']","Any list item is converted to @number=value
    Any dict item is converted to #key=value
    # is always added at the beginning 

    Input:  {
              dict         - python dictionary

              (prefix)     - prefix (for recursion)

              (prune_keys) - list of keys to prune (can have wildcards)
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              dict    - flattened dictionary
            }","['Any' 'list' 'item' 'is' 'converted' 'to' '@number' '=' 'value' 'Any'
 'dict' 'item' 'is' 'converted' 'to' '#key' '=' 'value' '#' 'is' 'always'
 'added' 'at' 'the' 'beginning']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L3939-L3972
ctuning/ck,ck/kernel.py,get_by_flat_key,"def get_by_flat_key(i):
    """"""
    Input:  {
              dict  - dictionary
              key   - flat key
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              value   - value or None, if doesn't exist
            }
    """"""
    # Check vars
    v=None

    a=i['dict']
    k=i['key']

    # Remove leading # if exists
    if len(k)>0 and k[0:1]=='#': k=k[1:]

    k1=''
    kt='' # type '#' or '@'
    x=0
    finish=False

    while not finish:
        y=k[x]
        x+=1

        if y=='#' or y=='@':
           if kt=='#':
              if k1 not in a: break
              a=a[k1]
           elif kt=='@':
              if len(a)<=type_long(k1): break
              a=a[type_long(k1)]
           k1=''
           kt=y
        else:
           k1+=y

        if x>=len(k): break

    if k1!='' and kt!='':
       if kt=='#':   
          if k1 in a: v=a[k1]
       else:         
          if len(a)>type_long(k1): v=a[type_long(k1)]

    return {'return':0, 'value': v}",python,"def get_by_flat_key(i):
    """"""
    Input:  {
              dict  - dictionary
              key   - flat key
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              value   - value or None, if doesn't exist
            }
    """"""
    # Check vars
    v=None

    a=i['dict']
    k=i['key']

    # Remove leading # if exists
    if len(k)>0 and k[0:1]=='#': k=k[1:]

    k1=''
    kt='' # type '#' or '@'
    x=0
    finish=False

    while not finish:
        y=k[x]
        x+=1

        if y=='#' or y=='@':
           if kt=='#':
              if k1 not in a: break
              a=a[k1]
           elif kt=='@':
              if len(a)<=type_long(k1): break
              a=a[type_long(k1)]
           k1=''
           kt=y
        else:
           k1+=y

        if x>=len(k): break

    if k1!='' and kt!='':
       if kt=='#':   
          if k1 in a: v=a[k1]
       else:         
          if len(a)>type_long(k1): v=a[type_long(k1)]

    return {'return':0, 'value': v}","['def' 'get_by_flat_key' '(' 'i' ')' ':' '# Check vars' 'v' '=' 'None' 'a'
 '=' 'i' '[' ""'dict'"" ']' 'k' '=' 'i' '[' ""'key'"" ']'
 '# Remove leading # if exists' 'if' 'len' '(' 'k' ')' '>' '0' 'and' 'k'
 '[' '0' ':' '1' ']' '==' ""'#'"" ':' 'k' '=' 'k' '[' '1' ':' ']' 'k1' '='
 ""''"" 'kt' '=' ""''"" ""# type '#' or '@'"" 'x' '=' '0' 'finish' '=' 'False'
 'while' 'not' 'finish' ':' 'y' '=' 'k' '[' 'x' ']' 'x' '+=' '1' 'if' 'y'
 '==' ""'#'"" 'or' 'y' '==' ""'@'"" ':' 'if' 'kt' '==' ""'#'"" ':' 'if' 'k1'
 'not' 'in' 'a' ':' 'break' 'a' '=' 'a' '[' 'k1' ']' 'elif' 'kt' '=='
 ""'@'"" ':' 'if' 'len' '(' 'a' ')' '<=' 'type_long' '(' 'k1' ')' ':'
 'break' 'a' '=' 'a' '[' 'type_long' '(' 'k1' ')' ']' 'k1' '=' ""''"" 'kt'
 '=' 'y' 'else' ':' 'k1' '+=' 'y' 'if' 'x' '>=' 'len' '(' 'k' ')' ':'
 'break' 'if' 'k1' '!=' ""''"" 'and' 'kt' '!=' ""''"" ':' 'if' 'kt' '==' ""'#'""
 ':' 'if' 'k1' 'in' 'a' ':' 'v' '=' 'a' '[' 'k1' ']' 'else' ':' 'if' 'len'
 '(' 'a' ')' '>' 'type_long' '(' 'k1' ')' ':' 'v' '=' 'a' '[' 'type_long'
 '(' 'k1' ')' ']' 'return' '{' ""'return'"" ':' '0' ',' ""'value'"" ':' 'v'
 '}']","Input:  {
              dict  - dictionary
              key   - flat key
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              value   - value or None, if doesn't exist
            }",['Input' ':' '{' 'dict' '-' 'dictionary' 'key' '-' 'flat' 'key' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4032-L4084
ctuning/ck,ck/kernel.py,restore_flattened_dict,"def restore_flattened_dict(i):
    """"""
    Input:  {
              dict - flattened dict
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              dict    - restored dict
            }
    """"""
    # Check vars
    a={} # default
    b=i['dict']
    first=True
    for x in b:
        if first: 
           first=False
           y=x[1:2]
           if y=='@': a=[]
           else: a={}

        set_by_flat_key({'dict':a, 'key':x, 'value':b[x]})

    return {'return':0, 'dict': a}",python,"def restore_flattened_dict(i):
    """"""
    Input:  {
              dict - flattened dict
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              dict    - restored dict
            }
    """"""
    # Check vars
    a={} # default
    b=i['dict']
    first=True
    for x in b:
        if first: 
           first=False
           y=x[1:2]
           if y=='@': a=[]
           else: a={}

        set_by_flat_key({'dict':a, 'key':x, 'value':b[x]})

    return {'return':0, 'dict': a}","['def' 'restore_flattened_dict' '(' 'i' ')' ':' '# Check vars' 'a' '=' '{'
 '}' '# default' 'b' '=' 'i' '[' ""'dict'"" ']' 'first' '=' 'True' 'for' 'x'
 'in' 'b' ':' 'if' 'first' ':' 'first' '=' 'False' 'y' '=' 'x' '[' '1' ':'
 '2' ']' 'if' 'y' '==' ""'@'"" ':' 'a' '=' '[' ']' 'else' ':' 'a' '=' '{'
 '}' 'set_by_flat_key' '(' '{' ""'dict'"" ':' 'a' ',' ""'key'"" ':' 'x' ','
 ""'value'"" ':' 'b' '[' 'x' ']' '}' ')' 'return' '{' ""'return'"" ':' '0' ','
 ""'dict'"" ':' 'a' '}']","Input:  {
              dict - flattened dict
            }

    Output: {
              return  - return code =  0, if successful
                                    >  0, if error
              (error) - error text if return > 0
              dict    - restored dict
            }",['Input' ':' '{' 'dict' '-' 'flattened' 'dict' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4159-L4185
ctuning/ck,ck/kernel.py,set_lock,"def set_lock(i):
    """"""
    Input:  {
              path               - path to be locked

              (get_lock)         - if 'yes', lock this entry
              (lock_retries)     - number of retries to aquire lock (default=11)
              (lock_retry_delay) - delay in seconds before trying to aquire lock again (default=3)
              (lock_expire_time) - number of seconds before lock expires (default=30)

              (unlock_uid)       - UID of the lock to release it
            }

    Output: {
              return       - return code =  0, if successful
                                         = 32, couldn't acquire lock (still locked after all retries)
                                         >  0, if error
              (error)      - error text if return > 0

              (lock_uid)   - lock UID, if locked successfully
            }
    """"""
    p=i['path']

    gl=i.get('get_lock','')
    uuid=i.get('unlock_uid','')
    exp=float(i.get('lock_expire_time','30'))

    rr={'return':0}

    if gl=='yes' or uuid!='':
       pl=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_for_lock'])

       luid=''
       if os.path.isfile(pl):
          import time

          # Read lock file
          try:
             f=open(pl)
             luid=f.readline().strip()
             exp=float(f.readline().strip())
             if exp<0: exp=1
             f.close()
          except Exception as e:
             return {'return':1, 'error':'problem reading lock file'}

          # Check if lock has expired
          if gl=='yes' and uuid=='':
             # Retry if locked
             retry=int(i.get('lock_retries','11'))
             retryd=float(i.get('lock_retry_delay','3'))

             dt=os.path.getmtime(pl)+exp-time.time()
             if dt>0: 
                while retry>0 and os.path.isfile(pl) and dt>0:
                   retry-=1
                   time.sleep(retryd)
                   if os.path.isfile(pl): 
                      dt=os.path.getmtime(pl)+exp-time.time()

                if retry==0 and dt>0 and os.path.isfile(pl):
                   return {'return':32, 'error':'entry is still locked'}

             luid=''
             if os.path.isfile(pl): os.remove(pl)

       # Release lock if requested (and if not locked by another UID)
       if luid!='' and uuid!='':
          if luid!=uuid:
             return {'return':32, 'error': 'entry is locked with another UID'}
          luid=''
          os.remove(pl)

       # Finish acquiring lock
       if gl=='yes':
          # (Re)acquire lock
          if uuid=='':
             r=gen_uid({})
             if r['return']>0: return r
             luid=r['data_uid']
          else:
             luid=uuid

          # Write lock file
          try:
             f=open(pl,'w')
             f.write(luid+'\n')
             f.write(str(exp)+'\n')
             f.close()
          except Exception as e:
             return {'return':1, 'error':'problem writing lock file'}

          rr['lock_uid']=luid

    return rr",python,"def set_lock(i):
    """"""
    Input:  {
              path               - path to be locked

              (get_lock)         - if 'yes', lock this entry
              (lock_retries)     - number of retries to aquire lock (default=11)
              (lock_retry_delay) - delay in seconds before trying to aquire lock again (default=3)
              (lock_expire_time) - number of seconds before lock expires (default=30)

              (unlock_uid)       - UID of the lock to release it
            }

    Output: {
              return       - return code =  0, if successful
                                         = 32, couldn't acquire lock (still locked after all retries)
                                         >  0, if error
              (error)      - error text if return > 0

              (lock_uid)   - lock UID, if locked successfully
            }
    """"""
    p=i['path']

    gl=i.get('get_lock','')
    uuid=i.get('unlock_uid','')
    exp=float(i.get('lock_expire_time','30'))

    rr={'return':0}

    if gl=='yes' or uuid!='':
       pl=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_for_lock'])

       luid=''
       if os.path.isfile(pl):
          import time

          # Read lock file
          try:
             f=open(pl)
             luid=f.readline().strip()
             exp=float(f.readline().strip())
             if exp<0: exp=1
             f.close()
          except Exception as e:
             return {'return':1, 'error':'problem reading lock file'}

          # Check if lock has expired
          if gl=='yes' and uuid=='':
             # Retry if locked
             retry=int(i.get('lock_retries','11'))
             retryd=float(i.get('lock_retry_delay','3'))

             dt=os.path.getmtime(pl)+exp-time.time()
             if dt>0: 
                while retry>0 and os.path.isfile(pl) and dt>0:
                   retry-=1
                   time.sleep(retryd)
                   if os.path.isfile(pl): 
                      dt=os.path.getmtime(pl)+exp-time.time()

                if retry==0 and dt>0 and os.path.isfile(pl):
                   return {'return':32, 'error':'entry is still locked'}

             luid=''
             if os.path.isfile(pl): os.remove(pl)

       # Release lock if requested (and if not locked by another UID)
       if luid!='' and uuid!='':
          if luid!=uuid:
             return {'return':32, 'error': 'entry is locked with another UID'}
          luid=''
          os.remove(pl)

       # Finish acquiring lock
       if gl=='yes':
          # (Re)acquire lock
          if uuid=='':
             r=gen_uid({})
             if r['return']>0: return r
             luid=r['data_uid']
          else:
             luid=uuid

          # Write lock file
          try:
             f=open(pl,'w')
             f.write(luid+'\n')
             f.write(str(exp)+'\n')
             f.close()
          except Exception as e:
             return {'return':1, 'error':'problem writing lock file'}

          rr['lock_uid']=luid

    return rr","['def' 'set_lock' '(' 'i' ')' ':' 'p' '=' 'i' '[' ""'path'"" ']' 'gl' '='
 'i' '.' 'get' '(' ""'get_lock'"" ',' ""''"" ')' 'uuid' '=' 'i' '.' 'get' '('
 ""'unlock_uid'"" ',' ""''"" ')' 'exp' '=' 'float' '(' 'i' '.' 'get' '('
 ""'lock_expire_time'"" ',' ""'30'"" ')' ')' 'rr' '=' '{' ""'return'"" ':' '0'
 '}' 'if' 'gl' '==' ""'yes'"" 'or' 'uuid' '!=' ""''"" ':' 'pl' '=' 'os' '.'
 'path' '.' 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'"" ']' ',' 'cfg'
 '[' ""'file_for_lock'"" ']' ')' 'luid' '=' ""''"" 'if' 'os' '.' 'path' '.'
 'isfile' '(' 'pl' ')' ':' 'import' 'time' '# Read lock file' 'try' ':'
 'f' '=' 'open' '(' 'pl' ')' 'luid' '=' 'f' '.' 'readline' '(' ')' '.'
 'strip' '(' ')' 'exp' '=' 'float' '(' 'f' '.' 'readline' '(' ')' '.'
 'strip' '(' ')' ')' 'if' 'exp' '<' '0' ':' 'exp' '=' '1' 'f' '.' 'close'
 '(' ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{' ""'return'"" ':' '1'
 ',' ""'error'"" ':' ""'problem reading lock file'"" '}'
 '# Check if lock has expired' 'if' 'gl' '==' ""'yes'"" 'and' 'uuid' '=='
 ""''"" ':' '# Retry if locked' 'retry' '=' 'int' '(' 'i' '.' 'get' '('
 ""'lock_retries'"" ',' ""'11'"" ')' ')' 'retryd' '=' 'float' '(' 'i' '.'
 'get' '(' ""'lock_retry_delay'"" ',' ""'3'"" ')' ')' 'dt' '=' 'os' '.' 'path'
 '.' 'getmtime' '(' 'pl' ')' '+' 'exp' '-' 'time' '.' 'time' '(' ')' 'if'
 'dt' '>' '0' ':' 'while' 'retry' '>' '0' 'and' 'os' '.' 'path' '.'
 'isfile' '(' 'pl' ')' 'and' 'dt' '>' '0' ':' 'retry' '-=' '1' 'time' '.'
 'sleep' '(' 'retryd' ')' 'if' 'os' '.' 'path' '.' 'isfile' '(' 'pl' ')'
 ':' 'dt' '=' 'os' '.' 'path' '.' 'getmtime' '(' 'pl' ')' '+' 'exp' '-'
 'time' '.' 'time' '(' ')' 'if' 'retry' '==' '0' 'and' 'dt' '>' '0' 'and'
 'os' '.' 'path' '.' 'isfile' '(' 'pl' ')' ':' 'return' '{' ""'return'"" ':'
 '32' ',' ""'error'"" ':' ""'entry is still locked'"" '}' 'luid' '=' ""''"" 'if'
 'os' '.' 'path' '.' 'isfile' '(' 'pl' ')' ':' 'os' '.' 'remove' '(' 'pl'
 ')' '# Release lock if requested (and if not locked by another UID)' 'if'
 'luid' '!=' ""''"" 'and' 'uuid' '!=' ""''"" ':' 'if' 'luid' '!=' 'uuid' ':'
 'return' '{' ""'return'"" ':' '32' ',' ""'error'"" ':'
 ""'entry is locked with another UID'"" '}' 'luid' '=' ""''"" 'os' '.'
 'remove' '(' 'pl' ')' '# Finish acquiring lock' 'if' 'gl' '==' ""'yes'""
 ':' '# (Re)acquire lock' 'if' 'uuid' '==' ""''"" ':' 'r' '=' 'gen_uid' '('
 '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'luid'
 '=' 'r' '[' ""'data_uid'"" ']' 'else' ':' 'luid' '=' 'uuid'
 '# Write lock file' 'try' ':' 'f' '=' 'open' '(' 'pl' ',' ""'w'"" ')' 'f'
 '.' 'write' '(' 'luid' '+' ""'\\n'"" ')' 'f' '.' 'write' '(' 'str' '('
 'exp' ')' '+' ""'\\n'"" ')' 'f' '.' 'close' '(' ')' 'except' 'Exception'
 'as' 'e' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem writing lock file'"" '}' 'rr' '[' ""'lock_uid'"" ']' '=' 'luid'
 'return' 'rr']","Input:  {
              path               - path to be locked

              (get_lock)         - if 'yes', lock this entry
              (lock_retries)     - number of retries to aquire lock (default=11)
              (lock_retry_delay) - delay in seconds before trying to aquire lock again (default=3)
              (lock_expire_time) - number of seconds before lock expires (default=30)

              (unlock_uid)       - UID of the lock to release it
            }

    Output: {
              return       - return code =  0, if successful
                                         = 32, couldn't acquire lock (still locked after all retries)
                                         >  0, if error
              (error)      - error text if return > 0

              (lock_uid)   - lock UID, if locked successfully
            }",['Input' ':' '{' 'path' '-' 'path' 'to' 'be' 'locked'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4192-L4287
ctuning/ck,ck/kernel.py,check_lock,"def check_lock(i):
    """"""
    Input:  {
              path               - path to be locked
              (unlock_uid)       - UID of the lock to release it
            }

    Output: {
              return       - return code =  0, if successful
                                         = 32, lock UID is not matching
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""
    p=i['path']
    uuid=i.get('unlock_uid','')

    pl=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_for_lock'])

    luid=''
    if os.path.isfile(pl):
       import time

       # Read lock file
       try:
          f=open(pl)
          luid=f.readline().strip()
          exp=float(f.readline().strip())
          if exp<0: exp=1
          f.close()
       except Exception as e:
          return {'return':1, 'error':'problem reading lock file'}

       # Check if lock has expired
       dt=os.path.getmtime(pl)+exp-time.time()
       if dt<0: 
          # Expired
          if uuid=='' or uuid==luid:
             os.remove(pl)
          else:
             return {'return':32, 'error':'entry lock UID is not matching'}
       else:
          if uuid=='':
             return {'return':32, 'error':'entry is locked'}
          elif uuid!=luid:
             return {'return':32, 'error':'entry is locked with different UID'}

    elif uuid!='':
       return {'return':32, 'error':'lock was removed or expired'}

    return {'return':0}",python,"def check_lock(i):
    """"""
    Input:  {
              path               - path to be locked
              (unlock_uid)       - UID of the lock to release it
            }

    Output: {
              return       - return code =  0, if successful
                                         = 32, lock UID is not matching
                                         >  0, if error
              (error)      - error text if return > 0
            }
    """"""
    p=i['path']
    uuid=i.get('unlock_uid','')

    pl=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_for_lock'])

    luid=''
    if os.path.isfile(pl):
       import time

       # Read lock file
       try:
          f=open(pl)
          luid=f.readline().strip()
          exp=float(f.readline().strip())
          if exp<0: exp=1
          f.close()
       except Exception as e:
          return {'return':1, 'error':'problem reading lock file'}

       # Check if lock has expired
       dt=os.path.getmtime(pl)+exp-time.time()
       if dt<0: 
          # Expired
          if uuid=='' or uuid==luid:
             os.remove(pl)
          else:
             return {'return':32, 'error':'entry lock UID is not matching'}
       else:
          if uuid=='':
             return {'return':32, 'error':'entry is locked'}
          elif uuid!=luid:
             return {'return':32, 'error':'entry is locked with different UID'}

    elif uuid!='':
       return {'return':32, 'error':'lock was removed or expired'}

    return {'return':0}","['def' 'check_lock' '(' 'i' ')' ':' 'p' '=' 'i' '[' ""'path'"" ']' 'uuid'
 '=' 'i' '.' 'get' '(' ""'unlock_uid'"" ',' ""''"" ')' 'pl' '=' 'os' '.'
 'path' '.' 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'"" ']' ',' 'cfg'
 '[' ""'file_for_lock'"" ']' ')' 'luid' '=' ""''"" 'if' 'os' '.' 'path' '.'
 'isfile' '(' 'pl' ')' ':' 'import' 'time' '# Read lock file' 'try' ':'
 'f' '=' 'open' '(' 'pl' ')' 'luid' '=' 'f' '.' 'readline' '(' ')' '.'
 'strip' '(' ')' 'exp' '=' 'float' '(' 'f' '.' 'readline' '(' ')' '.'
 'strip' '(' ')' ')' 'if' 'exp' '<' '0' ':' 'exp' '=' '1' 'f' '.' 'close'
 '(' ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{' ""'return'"" ':' '1'
 ',' ""'error'"" ':' ""'problem reading lock file'"" '}'
 '# Check if lock has expired' 'dt' '=' 'os' '.' 'path' '.' 'getmtime' '('
 'pl' ')' '+' 'exp' '-' 'time' '.' 'time' '(' ')' 'if' 'dt' '<' '0' ':'
 '# Expired' 'if' 'uuid' '==' ""''"" 'or' 'uuid' '==' 'luid' ':' 'os' '.'
 'remove' '(' 'pl' ')' 'else' ':' 'return' '{' ""'return'"" ':' '32' ','
 ""'error'"" ':' ""'entry lock UID is not matching'"" '}' 'else' ':' 'if'
 'uuid' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '32' ',' ""'error'"" ':'
 ""'entry is locked'"" '}' 'elif' 'uuid' '!=' 'luid' ':' 'return' '{'
 ""'return'"" ':' '32' ',' ""'error'"" ':'
 ""'entry is locked with different UID'"" '}' 'elif' 'uuid' '!=' ""''"" ':'
 'return' '{' ""'return'"" ':' '32' ',' ""'error'"" ':'
 ""'lock was removed or expired'"" '}' 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              path               - path to be locked
              (unlock_uid)       - UID of the lock to release it
            }

    Output: {
              return       - return code =  0, if successful
                                         = 32, lock UID is not matching
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' 'path' '-' 'path' 'to' 'be' 'locked' '(' 'unlock_uid' ')'
 '-' 'UID' 'of' 'the' 'lock' 'to' 'release' 'it' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4294-L4344
ctuning/ck,ck/kernel.py,get_current_date_time,"def get_current_date_time(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0

              array        - array with date and time
              iso_datetime - date and time in ISO format
            }
    """"""

    import datetime

    a={}

    now1=datetime.datetime.now()
    now=now1.timetuple()

    a['date_year']=now[0]
    a['date_month']=now[1]
    a['date_day']=now[2]
    a['time_hour']=now[3]
    a['time_minute']=now[4]
    a['time_second']=now[5]

    return {'return':0, 'array':a, 'iso_datetime':now1.isoformat()}",python,"def get_current_date_time(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0

              array        - array with date and time
              iso_datetime - date and time in ISO format
            }
    """"""

    import datetime

    a={}

    now1=datetime.datetime.now()
    now=now1.timetuple()

    a['date_year']=now[0]
    a['date_month']=now[1]
    a['date_day']=now[2]
    a['time_hour']=now[3]
    a['time_minute']=now[4]
    a['time_second']=now[5]

    return {'return':0, 'array':a, 'iso_datetime':now1.isoformat()}","['def' 'get_current_date_time' '(' 'i' ')' ':' 'import' 'datetime' 'a' '='
 '{' '}' 'now1' '=' 'datetime' '.' 'datetime' '.' 'now' '(' ')' 'now' '='
 'now1' '.' 'timetuple' '(' ')' 'a' '[' ""'date_year'"" ']' '=' 'now' '['
 '0' ']' 'a' '[' ""'date_month'"" ']' '=' 'now' '[' '1' ']' 'a' '['
 ""'date_day'"" ']' '=' 'now' '[' '2' ']' 'a' '[' ""'time_hour'"" ']' '='
 'now' '[' '3' ']' 'a' '[' ""'time_minute'"" ']' '=' 'now' '[' '4' ']' 'a'
 '[' ""'time_second'"" ']' '=' 'now' '[' '5' ']' 'return' '{' ""'return'"" ':'
 '0' ',' ""'array'"" ':' 'a' ',' ""'iso_datetime'"" ':' 'now1' '.' 'isoformat'
 '(' ')' '}']","Input:  {}

    Output: {
              return       - return code =  0

              array        - array with date and time
              iso_datetime - date and time in ISO format
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4351-L4377
ctuning/ck,ck/kernel.py,detect_cid_in_current_path,"def detect_cid_in_current_path(i):
    """"""
    Input:  {
              (path)     - path, otherwise current directory
            }

    Output: {
              return         - return code =  0, if successful
                                           >  0, if error
              (error)        - error text if return > 0

              repo_uoa       - repo UOA
              repo_uid       - repo UID
              repo_alias     - repo alias
              (module_uoa)   - module UOA
              (module_uid)   - module UID
              (module_alias) - module alias
              (data_uoa)     - data UOA
              (data_uid)     - data UID
              (data_alias)   - data alias
            }
    """"""

    p=i.get('path','')
    if p=='': p=os.getcwd()
    p=os.path.normpath(p)

    dirs=[]
    p1=''
    pr='*'
    found=False

    while pr!='':
       p1=os.path.join(p, cfg['repo_file'])

       if os.path.isfile(p1): 
          found=True
          break

       p2=os.path.split(p)
       p=p2[0]
       pr=p2[1]
       dirs.append(pr)

    if not found:
       return {'return':16, 'error':'repository is not detected in the current path'}

    # Find info about repo (prepared as return dict)
    r=find_repo_by_path({'path':p})
    if r['return']>0: return r

    # Check info about module
    ld=len(dirs)
    if ld>0:
       m=dirs[ld-1]

       rx=find_path_to_entry({'path':p, 'data_uoa':m})
       if rx['return']>0 and rx['return']!=16: return rx
       elif rx['return']==0:
          r['module_uoa']=rx['data_uoa']
          r['module_uid']=rx['data_uid']
          r['module_alias']=rx['data_alias']

       # Check info about data
       if ld>1:
          d=dirs[ld-2]

          rx=find_path_to_entry({'path':os.path.join(p,m), 'data_uoa':d})
          if rx['return']>0 and rx['return']!=16: return rx
          elif rx['return']==0:
             r['data_uoa']=rx['data_uoa']
             r['data_uid']=rx['data_uid']
             r['data_alias']=rx['data_alias']

    return r",python,"def detect_cid_in_current_path(i):
    """"""
    Input:  {
              (path)     - path, otherwise current directory
            }

    Output: {
              return         - return code =  0, if successful
                                           >  0, if error
              (error)        - error text if return > 0

              repo_uoa       - repo UOA
              repo_uid       - repo UID
              repo_alias     - repo alias
              (module_uoa)   - module UOA
              (module_uid)   - module UID
              (module_alias) - module alias
              (data_uoa)     - data UOA
              (data_uid)     - data UID
              (data_alias)   - data alias
            }
    """"""

    p=i.get('path','')
    if p=='': p=os.getcwd()
    p=os.path.normpath(p)

    dirs=[]
    p1=''
    pr='*'
    found=False

    while pr!='':
       p1=os.path.join(p, cfg['repo_file'])

       if os.path.isfile(p1): 
          found=True
          break

       p2=os.path.split(p)
       p=p2[0]
       pr=p2[1]
       dirs.append(pr)

    if not found:
       return {'return':16, 'error':'repository is not detected in the current path'}

    # Find info about repo (prepared as return dict)
    r=find_repo_by_path({'path':p})
    if r['return']>0: return r

    # Check info about module
    ld=len(dirs)
    if ld>0:
       m=dirs[ld-1]

       rx=find_path_to_entry({'path':p, 'data_uoa':m})
       if rx['return']>0 and rx['return']!=16: return rx
       elif rx['return']==0:
          r['module_uoa']=rx['data_uoa']
          r['module_uid']=rx['data_uid']
          r['module_alias']=rx['data_alias']

       # Check info about data
       if ld>1:
          d=dirs[ld-2]

          rx=find_path_to_entry({'path':os.path.join(p,m), 'data_uoa':d})
          if rx['return']>0 and rx['return']!=16: return rx
          elif rx['return']==0:
             r['data_uoa']=rx['data_uoa']
             r['data_uid']=rx['data_uid']
             r['data_alias']=rx['data_alias']

    return r","['def' 'detect_cid_in_current_path' '(' 'i' ')' ':' 'p' '=' 'i' '.' 'get'
 '(' ""'path'"" ',' ""''"" ')' 'if' 'p' '==' ""''"" ':' 'p' '=' 'os' '.'
 'getcwd' '(' ')' 'p' '=' 'os' '.' 'path' '.' 'normpath' '(' 'p' ')'
 'dirs' '=' '[' ']' 'p1' '=' ""''"" 'pr' '=' ""'*'"" 'found' '=' 'False'
 'while' 'pr' '!=' ""''"" ':' 'p1' '=' 'os' '.' 'path' '.' 'join' '(' 'p'
 ',' 'cfg' '[' ""'repo_file'"" ']' ')' 'if' 'os' '.' 'path' '.' 'isfile' '('
 'p1' ')' ':' 'found' '=' 'True' 'break' 'p2' '=' 'os' '.' 'path' '.'
 'split' '(' 'p' ')' 'p' '=' 'p2' '[' '0' ']' 'pr' '=' 'p2' '[' '1' ']'
 'dirs' '.' 'append' '(' 'pr' ')' 'if' 'not' 'found' ':' 'return' '{'
 ""'return'"" ':' '16' ',' ""'error'"" ':'
 ""'repository is not detected in the current path'"" '}'
 '# Find info about repo (prepared as return dict)' 'r' '='
 'find_repo_by_path' '(' '{' ""'path'"" ':' 'p' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' '# Check info about module' 'ld'
 '=' 'len' '(' 'dirs' ')' 'if' 'ld' '>' '0' ':' 'm' '=' 'dirs' '[' 'ld'
 '-' '1' ']' 'rx' '=' 'find_path_to_entry' '(' '{' ""'path'"" ':' 'p' ','
 ""'data_uoa'"" ':' 'm' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' 'and'
 'rx' '[' ""'return'"" ']' '!=' '16' ':' 'return' 'rx' 'elif' 'rx' '['
 ""'return'"" ']' '==' '0' ':' 'r' '[' ""'module_uoa'"" ']' '=' 'rx' '['
 ""'data_uoa'"" ']' 'r' '[' ""'module_uid'"" ']' '=' 'rx' '[' ""'data_uid'"" ']'
 'r' '[' ""'module_alias'"" ']' '=' 'rx' '[' ""'data_alias'"" ']'
 '# Check info about data' 'if' 'ld' '>' '1' ':' 'd' '=' 'dirs' '[' 'ld'
 '-' '2' ']' 'rx' '=' 'find_path_to_entry' '(' '{' ""'path'"" ':' 'os' '.'
 'path' '.' 'join' '(' 'p' ',' 'm' ')' ',' ""'data_uoa'"" ':' 'd' '}' ')'
 'if' 'rx' '[' ""'return'"" ']' '>' '0' 'and' 'rx' '[' ""'return'"" ']' '!='
 '16' ':' 'return' 'rx' 'elif' 'rx' '[' ""'return'"" ']' '==' '0' ':' 'r'
 '[' ""'data_uoa'"" ']' '=' 'rx' '[' ""'data_uoa'"" ']' 'r' '[' ""'data_uid'""
 ']' '=' 'rx' '[' ""'data_uid'"" ']' 'r' '[' ""'data_alias'"" ']' '=' 'rx' '['
 ""'data_alias'"" ']' 'return' 'r']","Input:  {
              (path)     - path, otherwise current directory
            }

    Output: {
              return         - return code =  0, if successful
                                           >  0, if error
              (error)        - error text if return > 0

              repo_uoa       - repo UOA
              repo_uid       - repo UID
              repo_alias     - repo alias
              (module_uoa)   - module UOA
              (module_uid)   - module UID
              (module_alias) - module alias
              (data_uoa)     - data UOA
              (data_uid)     - data UID
              (data_alias)   - data alias
            }","['Input' ':' '{' '(' 'path' ')' '-' 'path' 'otherwise' 'current'
 'directory' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4385-L4459
ctuning/ck,ck/kernel.py,uid,"def uid(i):
    """"""
    Input:  {}

    Output: {
              Output from 'gen_uid' function
            }

    """"""

    o=i.get('out','')

    r=gen_uid({})
    if r['return']>0: return r

    if o=='con':
       out(r['data_uid'])

    return r",python,"def uid(i):
    """"""
    Input:  {}

    Output: {
              Output from 'gen_uid' function
            }

    """"""

    o=i.get('out','')

    r=gen_uid({})
    if r['return']>0: return r

    if o=='con':
       out(r['data_uid'])

    return r","['def' 'uid' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'r' '=' 'gen_uid' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' 'if' 'o' '==' ""'con'"" ':' 'out' '(' 'r' '[' ""'data_uid'""
 ']' ')' 'return' 'r']","Input:  {}

    Output: {
              Output from 'gen_uid' function
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4470-L4488
ctuning/ck,ck/kernel.py,version,"def version(i):
    """"""
    Input:  {}

    Output: {
              output from function 'get_version'
            }

    """"""

    o=i.get('out','')

    r=get_version({})
    if r['return']>0: return r
    version_str=r['version_str']

    if o=='con':
       out('V'+version_str)

    return r",python,"def version(i):
    """"""
    Input:  {}

    Output: {
              output from function 'get_version'
            }

    """"""

    o=i.get('out','')

    r=get_version({})
    if r['return']>0: return r
    version_str=r['version_str']

    if o=='con':
       out('V'+version_str)

    return r","['def' 'version' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ','
 ""''"" ')' 'r' '=' 'get_version' '(' '{' '}' ')' 'if' 'r' '[' ""'return'""
 ']' '>' '0' ':' 'return' 'r' 'version_str' '=' 'r' '[' ""'version_str'""
 ']' 'if' 'o' '==' ""'con'"" ':' 'out' '(' ""'V'"" '+' 'version_str' ')'
 'return' 'r']","Input:  {}

    Output: {
              output from function 'get_version'
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4495-L4514
ctuning/ck,ck/kernel.py,python_version,"def python_version(i):
    """"""
    Input:  {}

    Output: {
               version - sys.version
               version_info - sys.version_info
            }

    """"""

    import sys

    o=i.get('out','')

    v1=sys.version
    v2=sys.version_info

    if o=='con':
       out(v1)

    return {'return':0, 'version':v1, 'version_info':v2}",python,"def python_version(i):
    """"""
    Input:  {}

    Output: {
               version - sys.version
               version_info - sys.version_info
            }

    """"""

    import sys

    o=i.get('out','')

    v1=sys.version
    v2=sys.version_info

    if o=='con':
       out(v1)

    return {'return':0, 'version':v1, 'version_info':v2}","['def' 'python_version' '(' 'i' ')' ':' 'import' 'sys' 'o' '=' 'i' '.'
 'get' '(' ""'out'"" ',' ""''"" ')' 'v1' '=' 'sys' '.' 'version' 'v2' '='
 'sys' '.' 'version_info' 'if' 'o' '==' ""'con'"" ':' 'out' '(' 'v1' ')'
 'return' '{' ""'return'"" ':' '0' ',' ""'version'"" ':' 'v1' ','
 ""'version_info'"" ':' 'v2' '}']","Input:  {}

    Output: {
               version - sys.version
               version_info - sys.version_info
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4521-L4542
ctuning/ck,ck/kernel.py,status,"def status(i):
    """"""
    Input:  {}

    Output: {
              outdated     - if 'yes', newer version exists

              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    outdated=''

    o=i.get('out','')

    try:    import urllib.request as urllib2
    except: import urllib2

    try:    from urllib.parse import urlencode
    except: from urllib import urlencode

    page=''
    try:
       res=urllib2.urlopen(cfg['status_url'])
       page=res.read()
    except urllib2.HTTPError as e:
       return {'return':1, 'error':'Problem accessing server ('+format(e)+')'}
    except urllib2.URLError as e:
       return {'return':1, 'error':'Problem accessing server ('+format(e)+')'}

    # Support for Python 3
    if sys.version_info[0]>2:
       try: 
          page=page.decode('utf-8')
       except Exception as e: 
          pass

    if page!='':
       s1='version=\''
       i1=page.find(s1)
       if i1>0:
          i2=page.find('\'',i1+9)
          if i2>0:
             lversion_str=page[i1+len(s1):i2].strip()

             rx=check_version({'version':lversion_str})
             if rx['return']>0: return rx

             ok=rx['ok']
             version_str=rx['current_version']
             if ok!='yes':
                outdated='yes'

                if o=='con':
                   out('Your version is outdated: V'+version_str)
                   out('New available version   : V'+lversion_str)
                   u=cfg.get('ck_web','')
                   if u!='':
                      out('')
                      out('If you install CK via pip, upgrade it as follows (prefix with ""sudo"" on Linux):')
                      out(' $ pip install ck --upgrade')
                      out('')
                      out('If you use GitHub version, update CK kernel (and all other repositories) as follows:')
                      out(' $ ck pull all --kernel')
                      out('')
                      out('Visit '+u+' for more details!')

    if o=='con':
       if outdated!='yes':
          out('Your version is up-to-date: V'+version_str)
       elif outdated=='':
          out('Problem checking version ...')

    return {'return':0, 'outdated':outdated}",python,"def status(i):
    """"""
    Input:  {}

    Output: {
              outdated     - if 'yes', newer version exists

              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    outdated=''

    o=i.get('out','')

    try:    import urllib.request as urllib2
    except: import urllib2

    try:    from urllib.parse import urlencode
    except: from urllib import urlencode

    page=''
    try:
       res=urllib2.urlopen(cfg['status_url'])
       page=res.read()
    except urllib2.HTTPError as e:
       return {'return':1, 'error':'Problem accessing server ('+format(e)+')'}
    except urllib2.URLError as e:
       return {'return':1, 'error':'Problem accessing server ('+format(e)+')'}

    # Support for Python 3
    if sys.version_info[0]>2:
       try: 
          page=page.decode('utf-8')
       except Exception as e: 
          pass

    if page!='':
       s1='version=\''
       i1=page.find(s1)
       if i1>0:
          i2=page.find('\'',i1+9)
          if i2>0:
             lversion_str=page[i1+len(s1):i2].strip()

             rx=check_version({'version':lversion_str})
             if rx['return']>0: return rx

             ok=rx['ok']
             version_str=rx['current_version']
             if ok!='yes':
                outdated='yes'

                if o=='con':
                   out('Your version is outdated: V'+version_str)
                   out('New available version   : V'+lversion_str)
                   u=cfg.get('ck_web','')
                   if u!='':
                      out('')
                      out('If you install CK via pip, upgrade it as follows (prefix with ""sudo"" on Linux):')
                      out(' $ pip install ck --upgrade')
                      out('')
                      out('If you use GitHub version, update CK kernel (and all other repositories) as follows:')
                      out(' $ ck pull all --kernel')
                      out('')
                      out('Visit '+u+' for more details!')

    if o=='con':
       if outdated!='yes':
          out('Your version is up-to-date: V'+version_str)
       elif outdated=='':
          out('Problem checking version ...')

    return {'return':0, 'outdated':outdated}","['def' 'status' '(' 'i' ')' ':' 'outdated' '=' ""''"" 'o' '=' 'i' '.' 'get'
 '(' ""'out'"" ',' ""''"" ')' 'try' ':' 'import' 'urllib' '.' 'request' 'as'
 'urllib2' 'except' ':' 'import' 'urllib2' 'try' ':' 'from' 'urllib' '.'
 'parse' 'import' 'urlencode' 'except' ':' 'from' 'urllib' 'import'
 'urlencode' 'page' '=' ""''"" 'try' ':' 'res' '=' 'urllib2' '.' 'urlopen'
 '(' 'cfg' '[' ""'status_url'"" ']' ')' 'page' '=' 'res' '.' 'read' '(' ')'
 'except' 'urllib2' '.' 'HTTPError' 'as' 'e' ':' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'Problem accessing server ('"" '+' 'format' '('
 'e' ')' '+' ""')'"" '}' 'except' 'urllib2' '.' 'URLError' 'as' 'e' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'Problem accessing server ('"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}'
 '# Support for Python 3' 'if' 'sys' '.' 'version_info' '[' '0' ']' '>'
 '2' ':' 'try' ':' 'page' '=' 'page' '.' 'decode' '(' ""'utf-8'"" ')'
 'except' 'Exception' 'as' 'e' ':' 'pass' 'if' 'page' '!=' ""''"" ':' 's1'
 '=' ""'version=\\''"" 'i1' '=' 'page' '.' 'find' '(' 's1' ')' 'if' 'i1' '>'
 '0' ':' 'i2' '=' 'page' '.' 'find' '(' ""'\\''"" ',' 'i1' '+' '9' ')' 'if'
 'i2' '>' '0' ':' 'lversion_str' '=' 'page' '[' 'i1' '+' 'len' '(' 's1'
 ')' ':' 'i2' ']' '.' 'strip' '(' ')' 'rx' '=' 'check_version' '(' '{'
 ""'version'"" ':' 'lversion_str' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'rx' 'ok' '=' 'rx' '[' ""'ok'"" ']' 'version_str' '=' 'rx'
 '[' ""'current_version'"" ']' 'if' 'ok' '!=' ""'yes'"" ':' 'outdated' '='
 ""'yes'"" 'if' 'o' '==' ""'con'"" ':' 'out' '('
 ""'Your version is outdated: V'"" '+' 'version_str' ')' 'out' '('
 ""'New available version   : V'"" '+' 'lversion_str' ')' 'u' '=' 'cfg' '.'
 'get' '(' ""'ck_web'"" ',' ""''"" ')' 'if' 'u' '!=' ""''"" ':' 'out' '(' ""''""
 ')' 'out' '('
 '\'If you install CK via pip, upgrade it as follows (prefix with ""sudo"" on Linux):\''
 ')' 'out' '(' ""' $ pip install ck --upgrade'"" ')' 'out' '(' ""''"" ')'
 'out' '('
 ""'If you use GitHub version, update CK kernel (and all other repositories) as follows:'""
 ')' 'out' '(' ""' $ ck pull all --kernel'"" ')' 'out' '(' ""''"" ')' 'out'
 '(' ""'Visit '"" '+' 'u' '+' ""' for more details!'"" ')' 'if' 'o' '=='
 ""'con'"" ':' 'if' 'outdated' '!=' ""'yes'"" ':' 'out' '('
 ""'Your version is up-to-date: V'"" '+' 'version_str' ')' 'elif' 'outdated'
 '==' ""''"" ':' 'out' '(' ""'Problem checking version ...'"" ')' 'return' '{'
 ""'return'"" ':' '0' ',' ""'outdated'"" ':' 'outdated' '}']","Input:  {}

    Output: {
              outdated     - if 'yes', newer version exists

              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4549-L4625
ctuning/ck,ck/kernel.py,check_version,"def check_version(i):
    """"""
    Input:  {
              version      - your version (string)
            }

    Output: {
              return          - return code =  0

              ok              - if 'yes', your CK kernel version is outdated
              current_version - your CK kernel version
            }

    """"""

    ok='yes'

    r=get_version({})
    if r['return']>0: return r
    version=r['version']
    version_str=r['version_str']

    lversion_str=i['version'].replace('dev','.1') # for compatibility with older versions
    lversion=lversion_str.split('.')

    # Comparing
    for q in range(0, len(version)):
        if len(lversion)<=q:
            break

        v=version[q]
        lv=lversion[q]

        # try int first, then try string
        try:
           if int(lv)>int(v):
               ok='no'
               break
        except Exception as e:
            pass

        if lv>v:
            ok='no'
            break

        if lv<v:
            break

    return {'return':0, 'ok':ok, 'current_version':version_str}",python,"def check_version(i):
    """"""
    Input:  {
              version      - your version (string)
            }

    Output: {
              return          - return code =  0

              ok              - if 'yes', your CK kernel version is outdated
              current_version - your CK kernel version
            }

    """"""

    ok='yes'

    r=get_version({})
    if r['return']>0: return r
    version=r['version']
    version_str=r['version_str']

    lversion_str=i['version'].replace('dev','.1') # for compatibility with older versions
    lversion=lversion_str.split('.')

    # Comparing
    for q in range(0, len(version)):
        if len(lversion)<=q:
            break

        v=version[q]
        lv=lversion[q]

        # try int first, then try string
        try:
           if int(lv)>int(v):
               ok='no'
               break
        except Exception as e:
            pass

        if lv>v:
            ok='no'
            break

        if lv<v:
            break

    return {'return':0, 'ok':ok, 'current_version':version_str}","['def' 'check_version' '(' 'i' ')' ':' 'ok' '=' ""'yes'"" 'r' '='
 'get_version' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'version' '=' 'r' '[' ""'version'"" ']' 'version_str' '=' 'r'
 '[' ""'version_str'"" ']' 'lversion_str' '=' 'i' '[' ""'version'"" ']' '.'
 'replace' '(' ""'dev'"" ',' ""'.1'"" ')'
 '# for compatibility with older versions' 'lversion' '=' 'lversion_str'
 '.' 'split' '(' ""'.'"" ')' '# Comparing' 'for' 'q' 'in' 'range' '(' '0'
 ',' 'len' '(' 'version' ')' ')' ':' 'if' 'len' '(' 'lversion' ')' '<='
 'q' ':' 'break' 'v' '=' 'version' '[' 'q' ']' 'lv' '=' 'lversion' '[' 'q'
 ']' '# try int first, then try string' 'try' ':' 'if' 'int' '(' 'lv' ')'
 '>' 'int' '(' 'v' ')' ':' 'ok' '=' ""'no'"" 'break' 'except' 'Exception'
 'as' 'e' ':' 'pass' 'if' 'lv' '>' 'v' ':' 'ok' '=' ""'no'"" 'break' 'if'
 'lv' '<' 'v' ':' 'break' 'return' '{' ""'return'"" ':' '0' ',' ""'ok'"" ':'
 'ok' ',' ""'current_version'"" ':' 'version_str' '}']","Input:  {
              version      - your version (string)
            }

    Output: {
              return          - return code =  0

              ok              - if 'yes', your CK kernel version is outdated
              current_version - your CK kernel version
            }",['Input' ':' '{' 'version' '-' 'your' 'version' '(' 'string' ')' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4632-L4680
ctuning/ck,ck/kernel.py,convert_entry_to_cid,"def convert_entry_to_cid(i):
    """"""
    Input:  {
               (repo_uoa)   - Repo UOA
               (repo_uid)   - Repo UID
               (module_uoa) - Module UOA
               (module_uid) - Module UID
               (data_uoa)   - Data UOA
               (data_uid)   - Data UID
            }

    Output: {
              return       - return code =  0

              cuoa         - module_uoa:data_uoa           (substituted with ? if can't find)
              cid          - module_uid:data_uid           (substituted with ? if can't find)
              xcuoa        - repo_uoa:module_uoa:data_uoa  (substituted with ? if can't find)
              xcid         - repo_uid:module_uid:data_uid  (substituted with ? if can't find)
            }

    """"""

    xcuoa=''
    xcid=''

    if i.get('module_uoa','')!='': cuoa=i['module_uoa']
    else: cuoa='?'
    if i.get('module_uid','')!='': cid=i['module_uid']
    else: cid='?'

    cuoa+=':'
    cid+=':'

    if i.get('data_uoa','')!='': cuoa+=i['data_uoa']
    else: cuoa+='?'
    if i.get('data_uid','')!='': cid+=i['data_uid']
    else: cid+='?'

    if i.get('repo_uoa','')!='': xcuoa=i['repo_uoa']+':'+cuoa
    else: xcuoa='?:'+cuoa
    if i.get('repo_uid','')!='': xcid=i['repo_uid']+':'+cid
    else: xcid='?:'+cid

    r={'return':0}
    r['cuoa']=cuoa
    r['cid']=cid
    r['xcuoa']=xcuoa
    r['xcid']=xcid

    return r",python,"def convert_entry_to_cid(i):
    """"""
    Input:  {
               (repo_uoa)   - Repo UOA
               (repo_uid)   - Repo UID
               (module_uoa) - Module UOA
               (module_uid) - Module UID
               (data_uoa)   - Data UOA
               (data_uid)   - Data UID
            }

    Output: {
              return       - return code =  0

              cuoa         - module_uoa:data_uoa           (substituted with ? if can't find)
              cid          - module_uid:data_uid           (substituted with ? if can't find)
              xcuoa        - repo_uoa:module_uoa:data_uoa  (substituted with ? if can't find)
              xcid         - repo_uid:module_uid:data_uid  (substituted with ? if can't find)
            }

    """"""

    xcuoa=''
    xcid=''

    if i.get('module_uoa','')!='': cuoa=i['module_uoa']
    else: cuoa='?'
    if i.get('module_uid','')!='': cid=i['module_uid']
    else: cid='?'

    cuoa+=':'
    cid+=':'

    if i.get('data_uoa','')!='': cuoa+=i['data_uoa']
    else: cuoa+='?'
    if i.get('data_uid','')!='': cid+=i['data_uid']
    else: cid+='?'

    if i.get('repo_uoa','')!='': xcuoa=i['repo_uoa']+':'+cuoa
    else: xcuoa='?:'+cuoa
    if i.get('repo_uid','')!='': xcid=i['repo_uid']+':'+cid
    else: xcid='?:'+cid

    r={'return':0}
    r['cuoa']=cuoa
    r['cid']=cid
    r['xcuoa']=xcuoa
    r['xcid']=xcid

    return r","['def' 'convert_entry_to_cid' '(' 'i' ')' ':' 'xcuoa' '=' ""''"" 'xcid' '='
 ""''"" 'if' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' '!=' ""''"" ':'
 'cuoa' '=' 'i' '[' ""'module_uoa'"" ']' 'else' ':' 'cuoa' '=' ""'?'"" 'if'
 'i' '.' 'get' '(' ""'module_uid'"" ',' ""''"" ')' '!=' ""''"" ':' 'cid' '=' 'i'
 '[' ""'module_uid'"" ']' 'else' ':' 'cid' '=' ""'?'"" 'cuoa' '+=' ""':'"" 'cid'
 '+=' ""':'"" 'if' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' '!=' ""''"" ':'
 'cuoa' '+=' 'i' '[' ""'data_uoa'"" ']' 'else' ':' 'cuoa' '+=' ""'?'"" 'if'
 'i' '.' 'get' '(' ""'data_uid'"" ',' ""''"" ')' '!=' ""''"" ':' 'cid' '+=' 'i'
 '[' ""'data_uid'"" ']' 'else' ':' 'cid' '+=' ""'?'"" 'if' 'i' '.' 'get' '('
 ""'repo_uoa'"" ',' ""''"" ')' '!=' ""''"" ':' 'xcuoa' '=' 'i' '[' ""'repo_uoa'""
 ']' '+' ""':'"" '+' 'cuoa' 'else' ':' 'xcuoa' '=' ""'?:'"" '+' 'cuoa' 'if'
 'i' '.' 'get' '(' ""'repo_uid'"" ',' ""''"" ')' '!=' ""''"" ':' 'xcid' '=' 'i'
 '[' ""'repo_uid'"" ']' '+' ""':'"" '+' 'cid' 'else' ':' 'xcid' '=' ""'?:'"" '+'
 'cid' 'r' '=' '{' ""'return'"" ':' '0' '}' 'r' '[' ""'cuoa'"" ']' '=' 'cuoa'
 'r' '[' ""'cid'"" ']' '=' 'cid' 'r' '[' ""'xcuoa'"" ']' '=' 'xcuoa' 'r' '['
 ""'xcid'"" ']' '=' 'xcid' 'return' 'r']","Input:  {
               (repo_uoa)   - Repo UOA
               (repo_uid)   - Repo UID
               (module_uoa) - Module UOA
               (module_uid) - Module UID
               (data_uoa)   - Data UOA
               (data_uid)   - Data UID
            }

    Output: {
              return       - return code =  0

              cuoa         - module_uoa:data_uoa           (substituted with ? if can't find)
              cid          - module_uid:data_uid           (substituted with ? if can't find)
              xcuoa        - repo_uoa:module_uoa:data_uoa  (substituted with ? if can't find)
              xcid         - repo_uid:module_uid:data_uid  (substituted with ? if can't find)
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'Repo' 'UOA' '(' 'repo_uid' ')'
 '-' 'Repo' 'UID' '(' 'module_uoa' ')' '-' 'Module' 'UOA' '(' 'module_uid'
 ')' '-' 'Module' 'UID' '(' 'data_uoa' ')' '-' 'Data' 'UOA' '(' 'data_uid'
 ')' '-' 'Data' 'UID' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4687-L4736
ctuning/ck,ck/kernel.py,webhelp,"def webhelp(i):
    """"""
    Input:  { from access function }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    a=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    url=cfg['wiki_data_web']

    if m!='':
       if duoa=='': 
          duoa=m
          m=cfg['module_name']

       r=find_path_to_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
       if r['return']>0: return r
       p=r['path']

       rx=convert_entry_to_cid(r)
       if rx['return']>0: return rx

       cuoa=rx['cuoa']
       cid=rx['cid']
       xcuoa=rx['xcuoa']
       xcid=rx['xcid']

       # Prepare URL
       url+=cid.replace(':','_')

    out('Opening web page '+url+' ...')

    import webbrowser
    webbrowser.open(url)

    return {'return':0}",python,"def webhelp(i):
    """"""
    Input:  { from access function }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    a=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    url=cfg['wiki_data_web']

    if m!='':
       if duoa=='': 
          duoa=m
          m=cfg['module_name']

       r=find_path_to_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
       if r['return']>0: return r
       p=r['path']

       rx=convert_entry_to_cid(r)
       if rx['return']>0: return rx

       cuoa=rx['cuoa']
       cid=rx['cid']
       xcuoa=rx['xcuoa']
       xcid=rx['xcid']

       # Prepare URL
       url+=cid.replace(':','_')

    out('Opening web page '+url+' ...')

    import webbrowser
    webbrowser.open(url)

    return {'return':0}","['def' 'webhelp' '(' 'i' ')' ':' 'a' '=' 'i' '.' 'get' '(' ""'repo_uoa'""
 ',' ""''"" ')' 'm' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa'
 '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'url' '=' 'cfg' '['
 ""'wiki_data_web'"" ']' 'if' 'm' '!=' ""''"" ':' 'if' 'duoa' '==' ""''"" ':'
 'duoa' '=' 'm' 'm' '=' 'cfg' '[' ""'module_name'"" ']' 'r' '='
 'find_path_to_data' '(' '{' ""'repo_uoa'"" ':' 'a' ',' ""'module_uoa'"" ':'
 'm' ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'r' 'p' '=' 'r' '[' ""'path'"" ']' 'rx' '='
 'convert_entry_to_cid' '(' 'r' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'rx' 'cuoa' '=' 'rx' '[' ""'cuoa'"" ']' 'cid' '=' 'rx' '['
 ""'cid'"" ']' 'xcuoa' '=' 'rx' '[' ""'xcuoa'"" ']' 'xcid' '=' 'rx' '['
 ""'xcid'"" ']' '# Prepare URL' 'url' '+=' 'cid' '.' 'replace' '(' ""':'"" ','
 ""'_'"" ')' 'out' '(' ""'Opening web page '"" '+' 'url' '+' ""' ...'"" ')'
 'import' 'webbrowser' 'webbrowser' '.' 'open' '(' 'url' ')' 'return' '{'
 ""'return'"" ':' '0' '}']","Input:  { from access function }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' 'from' 'access' 'function' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4747-L4789
ctuning/ck,ck/kernel.py,wiki,"def wiki(i):
    """"""
    Input:  { 
               (repo_uoa)
               (module_uoa)
               (data_uoa)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    url=cfg['wiki_data_web']

    if muoa=='' or duoa=='':
       # Try to detect CID in current path
       rx=detect_cid_in_current_path({})
       if rx['return']==0:
          muoa=rx.get('module_uoa','')
          duoa=rx.get('data_uoa','')

    if muoa=='' or duoa=='':
       return guide({}) #{'return':1, 'error':'entry is not defined'}

    r=find_path_to_data({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    rx=convert_entry_to_cid(r)
    if rx['return']>0: return rx

    cuoa=rx['cuoa']
    cid=rx['cid']
    xcuoa=rx['xcuoa']
    xcid=rx['xcid']

    # Prepare URL
    url+=cid.replace(':','_')

    out('Opening web page '+url+' ...')

    import webbrowser
    webbrowser.open(url)

    return {'return':0}",python,"def wiki(i):
    """"""
    Input:  { 
               (repo_uoa)
               (module_uoa)
               (data_uoa)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    url=cfg['wiki_data_web']

    if muoa=='' or duoa=='':
       # Try to detect CID in current path
       rx=detect_cid_in_current_path({})
       if rx['return']==0:
          muoa=rx.get('module_uoa','')
          duoa=rx.get('data_uoa','')

    if muoa=='' or duoa=='':
       return guide({}) #{'return':1, 'error':'entry is not defined'}

    r=find_path_to_data({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    rx=convert_entry_to_cid(r)
    if rx['return']>0: return rx

    cuoa=rx['cuoa']
    cid=rx['cid']
    xcuoa=rx['xcuoa']
    xcid=rx['xcid']

    # Prepare URL
    url+=cid.replace(':','_')

    out('Opening web page '+url+' ...')

    import webbrowser
    webbrowser.open(url)

    return {'return':0}","['def' 'wiki' '(' 'i' ')' ':' 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'""
 ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')'
 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'url' '=' 'cfg'
 '[' ""'wiki_data_web'"" ']' 'if' 'muoa' '==' ""''"" 'or' 'duoa' '==' ""''"" ':'
 '# Try to detect CID in current path' 'rx' '='
 'detect_cid_in_current_path' '(' '{' '}' ')' 'if' 'rx' '[' ""'return'"" ']'
 '==' '0' ':' 'muoa' '=' 'rx' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')'
 'duoa' '=' 'rx' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if' 'muoa' '=='
 ""''"" 'or' 'duoa' '==' ""''"" ':' 'return' 'guide' '(' '{' '}' ')'
 ""#{'return':1, 'error':'entry is not defined'}"" 'r' '='
 'find_path_to_data' '(' '{' ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'""
 ':' 'muoa' ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'""
 ']' '>' '0' ':' 'return' 'r' 'rx' '=' 'convert_entry_to_cid' '(' 'r' ')'
 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'cuoa' '=' 'rx'
 '[' ""'cuoa'"" ']' 'cid' '=' 'rx' '[' ""'cid'"" ']' 'xcuoa' '=' 'rx' '['
 ""'xcuoa'"" ']' 'xcid' '=' 'rx' '[' ""'xcid'"" ']' '# Prepare URL' 'url' '+='
 'cid' '.' 'replace' '(' ""':'"" ',' ""'_'"" ')' 'out' '('
 ""'Opening web page '"" '+' 'url' '+' ""' ...'"" ')' 'import' 'webbrowser'
 'webbrowser' '.' 'open' '(' 'url' ')' 'return' '{' ""'return'"" ':' '0' '}']","Input:  { 
               (repo_uoa)
               (module_uoa)
               (data_uoa)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '(' 'module_uoa' ')' '(' 'data_uoa'
 ')' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4797-L4847
ctuning/ck,ck/kernel.py,webapi,"def webapi(i):
    """"""
    Input:  { from access function }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    url=cfg['api_web']

    if muoa=='':
       muoa=duoa

    if muoa=='':
       url+='ck_'+cfg['subdir_kernel']+'_api/html/kernel_8py.html'
    else:
       duoa=muoa
       muoa=cfg['module_name']

       r=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
       if r['return']>0: return r
       muoa=r['data_uoa']

       url+='ck_modules_api/html/'+muoa+'_2module_8py.html'

    out('Opening web page '+url+' ...')
    out('  Note: if discussion wiki page doesn\'t exist yet, root Wiki will open!')
    out('        You should then log in to Github, and restart ck wiki agian to edit it ...')

    import webbrowser
    webbrowser.open(url)

    return {'return':0}",python,"def webapi(i):
    """"""
    Input:  { from access function }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    url=cfg['api_web']

    if muoa=='':
       muoa=duoa

    if muoa=='':
       url+='ck_'+cfg['subdir_kernel']+'_api/html/kernel_8py.html'
    else:
       duoa=muoa
       muoa=cfg['module_name']

       r=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
       if r['return']>0: return r
       muoa=r['data_uoa']

       url+='ck_modules_api/html/'+muoa+'_2module_8py.html'

    out('Opening web page '+url+' ...')
    out('  Note: if discussion wiki page doesn\'t exist yet, root Wiki will open!')
    out('        You should then log in to Github, and restart ck wiki agian to edit it ...')

    import webbrowser
    webbrowser.open(url)

    return {'return':0}","['def' 'webapi' '(' 'i' ')' ':' 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'""
 ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')'
 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'url' '=' 'cfg'
 '[' ""'api_web'"" ']' 'if' 'muoa' '==' ""''"" ':' 'muoa' '=' 'duoa' 'if'
 'muoa' '==' ""''"" ':' 'url' '+=' ""'ck_'"" '+' 'cfg' '[' ""'subdir_kernel'""
 ']' '+' ""'_api/html/kernel_8py.html'"" 'else' ':' 'duoa' '=' 'muoa' 'muoa'
 '=' 'cfg' '[' ""'module_name'"" ']' 'r' '=' 'load' '(' '{' ""'repo_uoa'"" ':'
 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ',' ""'data_uoa'"" ':' 'duoa' '}' ')'
 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'muoa' '=' 'r' '['
 ""'data_uoa'"" ']' 'url' '+=' ""'ck_modules_api/html/'"" '+' 'muoa' '+'
 ""'_2module_8py.html'"" 'out' '(' ""'Opening web page '"" '+' 'url' '+'
 ""' ...'"" ')' 'out' '('
 ""'  Note: if discussion wiki page doesn\\'t exist yet, root Wiki will open!'""
 ')' 'out' '('
 ""'        You should then log in to Github, and restart ck wiki agian to edit it ...'""
 ')' 'import' 'webbrowser' 'webbrowser' '.' 'open' '(' 'url' ')' 'return'
 '{' ""'return'"" ':' '0' '}']","Input:  { from access function }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' 'from' 'access' 'function' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4912-L4951
ctuning/ck,ck/kernel.py,browser,"def browser(i):
    """"""
    Input:  {
              (template)   - use this web template
              (repo_uoa)   -
              (module_uoa) - 
              (data_uoa)   - view a given entry
              (extra_url)  - extra URL
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if ck-web is installed
    r=find({'module_uoa':'module',
            'data_uoa':'wfe'})
    if r['return']>0:
       if r['return']!=16: return r
 
       out('Seems like ck-web repository is not installed (can\'t find wfe module)!')
       out('Please, install it via ""ck pull repo:ck-web"" and try again!')

       return {'return':0}

    t=i.get('template','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    cid=''
    if duoa!='' or muoa!='' or ruoa!='':
       if ruoa!='': cid=ruoa+':'
       if muoa!='': cid+=muoa+':'
       if duoa!='': cid+=duoa

    # Starting web service and asking to open page
    return access({'action':'start', 'module_uoa':'web', 'browser':'yes', 
                   'template':t, 'cid':cid, 'extra_url':i.get('extra_url','')})",python,"def browser(i):
    """"""
    Input:  {
              (template)   - use this web template
              (repo_uoa)   -
              (module_uoa) - 
              (data_uoa)   - view a given entry
              (extra_url)  - extra URL
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if ck-web is installed
    r=find({'module_uoa':'module',
            'data_uoa':'wfe'})
    if r['return']>0:
       if r['return']!=16: return r
 
       out('Seems like ck-web repository is not installed (can\'t find wfe module)!')
       out('Please, install it via ""ck pull repo:ck-web"" and try again!')

       return {'return':0}

    t=i.get('template','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    cid=''
    if duoa!='' or muoa!='' or ruoa!='':
       if ruoa!='': cid=ruoa+':'
       if muoa!='': cid+=muoa+':'
       if duoa!='': cid+=duoa

    # Starting web service and asking to open page
    return access({'action':'start', 'module_uoa':'web', 'browser':'yes', 
                   'template':t, 'cid':cid, 'extra_url':i.get('extra_url','')})","['def' 'browser' '(' 'i' ')' ':' '# Check if ck-web is installed' 'r' '='
 'find' '(' '{' ""'module_uoa'"" ':' ""'module'"" ',' ""'data_uoa'"" ':' ""'wfe'""
 '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'if' 'r' '[' ""'return'""
 ']' '!=' '16' ':' 'return' 'r' 'out' '('
 ""'Seems like ck-web repository is not installed (can\\'t find wfe module)!'""
 ')' 'out' '('
 '\'Please, install it via ""ck pull repo:ck-web"" and try again!\'' ')'
 'return' '{' ""'return'"" ':' '0' '}' 't' '=' 'i' '.' 'get' '('
 ""'template'"" ',' ""''"" ')' 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ','
 ""''"" ')' 'muoa' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa'
 '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'cid' '=' ""''"" 'if'
 'duoa' '!=' ""''"" 'or' 'muoa' '!=' ""''"" 'or' 'ruoa' '!=' ""''"" ':' 'if'
 'ruoa' '!=' ""''"" ':' 'cid' '=' 'ruoa' '+' ""':'"" 'if' 'muoa' '!=' ""''"" ':'
 'cid' '+=' 'muoa' '+' ""':'"" 'if' 'duoa' '!=' ""''"" ':' 'cid' '+=' 'duoa'
 '# Starting web service and asking to open page' 'return' 'access' '('
 '{' ""'action'"" ':' ""'start'"" ',' ""'module_uoa'"" ':' ""'web'"" ','
 ""'browser'"" ':' ""'yes'"" ',' ""'template'"" ':' 't' ',' ""'cid'"" ':' 'cid'
 ',' ""'extra_url'"" ':' 'i' '.' 'get' '(' ""'extra_url'"" ',' ""''"" ')' '}'
 ')']","Input:  {
              (template)   - use this web template
              (repo_uoa)   -
              (module_uoa) - 
              (data_uoa)   - view a given entry
              (extra_url)  - extra URL
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'template' ')' '-' 'use' 'this' 'web' 'template' '('
 'repo_uoa' ')' '-' '(' 'module_uoa' ')' '-' '(' 'data_uoa' ')' '-' 'view'
 'a' 'given' 'entry' '(' 'extra_url' ')' '-' 'extra' 'URL' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L4958-L5001
ctuning/ck,ck/kernel.py,guide,"def guide(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    url=cfg['ck_web_wiki']

    out('Opening web page '+url+' ...')

    import webbrowser
    webbrowser.open(url)

    return {'return':0}",python,"def guide(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""
    url=cfg['ck_web_wiki']

    out('Opening web page '+url+' ...')

    import webbrowser
    webbrowser.open(url)

    return {'return':0}","['def' 'guide' '(' 'i' ')' ':' 'url' '=' 'cfg' '[' ""'ck_web_wiki'"" ']'
 'out' '(' ""'Opening web page '"" '+' 'url' '+' ""' ...'"" ')' 'import'
 'webbrowser' 'webbrowser' '.' 'open' '(' 'url' ')' 'return' '{'
 ""'return'"" ':' '0' '}']","Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5008-L5026
ctuning/ck,ck/kernel.py,help,"def help(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              help         - help text
            }

    """"""

    o=i.get('out','')

    m=i.get('module_uoa','')
    if m=='':
       m='<module_uoa>'

    h= 'Usage: '+cfg['cmd'].replace('$#module_uoa#$', m)+'\n'

    h+='\n'
    h+='  Common actions:\n'

    for q in sorted(cfg['common_actions']):
        s=q
        desc=cfg['actions'][q].get('desc','')
        if desc!='': s+=' - '+desc
        h+='    '+s+'\n'

    h+='\n'
    h+='  Module actions:\n'

    if m=='<module_uoa>':
       # Internal actions (for this kernel)
       for q in sorted(cfg['actions']):
           if q not in cfg['common_actions']:
              s=q
              desc=cfg['actions'][q].get('desc','')
              if desc!='': s+=' - '+desc
              h+='    '+s+'\n'
    else:
       # Attempt to load 
       r=list_actions({'module_uoa':m}) 
       if r['return']>0: return r
       actions=r['actions']

       if len(actions)==0:
          h+='    Not described yet ...\n'
       else:
          for q in sorted(actions.keys()):
              s=q
              desc=actions[q].get('desc','')
              if desc!='': s+=' - '+desc
              h+='    '+s+'\n'

    if m=='<module_uoa>':
       h+='\n'
       h+=cfg['help_examples']

    h+='\n'
    h+=cfg['help_web']

    if o=='con': out(h)

    return {'return':0, 'help':h}",python,"def help(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              help         - help text
            }

    """"""

    o=i.get('out','')

    m=i.get('module_uoa','')
    if m=='':
       m='<module_uoa>'

    h= 'Usage: '+cfg['cmd'].replace('$#module_uoa#$', m)+'\n'

    h+='\n'
    h+='  Common actions:\n'

    for q in sorted(cfg['common_actions']):
        s=q
        desc=cfg['actions'][q].get('desc','')
        if desc!='': s+=' - '+desc
        h+='    '+s+'\n'

    h+='\n'
    h+='  Module actions:\n'

    if m=='<module_uoa>':
       # Internal actions (for this kernel)
       for q in sorted(cfg['actions']):
           if q not in cfg['common_actions']:
              s=q
              desc=cfg['actions'][q].get('desc','')
              if desc!='': s+=' - '+desc
              h+='    '+s+'\n'
    else:
       # Attempt to load 
       r=list_actions({'module_uoa':m}) 
       if r['return']>0: return r
       actions=r['actions']

       if len(actions)==0:
          h+='    Not described yet ...\n'
       else:
          for q in sorted(actions.keys()):
              s=q
              desc=actions[q].get('desc','')
              if desc!='': s+=' - '+desc
              h+='    '+s+'\n'

    if m=='<module_uoa>':
       h+='\n'
       h+=cfg['help_examples']

    h+='\n'
    h+=cfg['help_web']

    if o=='con': out(h)

    return {'return':0, 'help':h}","['def' 'help' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'm' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'if' 'm' '=='
 ""''"" ':' 'm' '=' ""'<module_uoa>'"" 'h' '=' ""'Usage: '"" '+' 'cfg' '['
 ""'cmd'"" ']' '.' 'replace' '(' ""'$#module_uoa#$'"" ',' 'm' ')' '+' ""'\\n'""
 'h' '+=' ""'\\n'"" 'h' '+=' ""'  Common actions:\\n'"" 'for' 'q' 'in'
 'sorted' '(' 'cfg' '[' ""'common_actions'"" ']' ')' ':' 's' '=' 'q' 'desc'
 '=' 'cfg' '[' ""'actions'"" ']' '[' 'q' ']' '.' 'get' '(' ""'desc'"" ',' ""''""
 ')' 'if' 'desc' '!=' ""''"" ':' 's' '+=' ""' - '"" '+' 'desc' 'h' '+='
 ""'    '"" '+' 's' '+' ""'\\n'"" 'h' '+=' ""'\\n'"" 'h' '+='
 ""'  Module actions:\\n'"" 'if' 'm' '==' ""'<module_uoa>'"" ':'
 '# Internal actions (for this kernel)' 'for' 'q' 'in' 'sorted' '(' 'cfg'
 '[' ""'actions'"" ']' ')' ':' 'if' 'q' 'not' 'in' 'cfg' '['
 ""'common_actions'"" ']' ':' 's' '=' 'q' 'desc' '=' 'cfg' '[' ""'actions'""
 ']' '[' 'q' ']' '.' 'get' '(' ""'desc'"" ',' ""''"" ')' 'if' 'desc' '!=' ""''""
 ':' 's' '+=' ""' - '"" '+' 'desc' 'h' '+=' ""'    '"" '+' 's' '+' ""'\\n'""
 'else' ':' '# Attempt to load ' 'r' '=' 'list_actions' '(' '{'
 ""'module_uoa'"" ':' 'm' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'actions' '=' 'r' '[' ""'actions'"" ']' 'if' 'len' '('
 'actions' ')' '==' '0' ':' 'h' '+=' ""'    Not described yet ...\\n'""
 'else' ':' 'for' 'q' 'in' 'sorted' '(' 'actions' '.' 'keys' '(' ')' ')'
 ':' 's' '=' 'q' 'desc' '=' 'actions' '[' 'q' ']' '.' 'get' '(' ""'desc'""
 ',' ""''"" ')' 'if' 'desc' '!=' ""''"" ':' 's' '+=' ""' - '"" '+' 'desc' 'h'
 '+=' ""'    '"" '+' 's' '+' ""'\\n'"" 'if' 'm' '==' ""'<module_uoa>'"" ':' 'h'
 '+=' ""'\\n'"" 'h' '+=' 'cfg' '[' ""'help_examples'"" ']' 'h' '+=' ""'\\n'""
 'h' '+=' 'cfg' '[' ""'help_web'"" ']' 'if' 'o' '==' ""'con'"" ':' 'out' '('
 'h' ')' 'return' '{' ""'return'"" ':' '0' ',' ""'help'"" ':' 'h' '}']","Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              help         - help text
            }",['Input' ':' '{' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5033-L5100
ctuning/ck,ck/kernel.py,short_help,"def short_help(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              help         - help text
            }



    """"""

    o=i.get('out','')

    r=version({})
    if r['return']>0: return r

    h='CK version: '+r['version_str']+'\n'

    r=python_version({})
    if r['return']>0: return r

    h+='\nPython version used by CK: '+r['version']+'\n'

    h+='\nAll internal CK commands: ck help\n'

    h+='\n'+cfg['help_web'].replace('\n','').strip().replace('   ','')

    if o=='con': 
       out(h)

    return {'return':0, 'help':h}",python,"def short_help(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              help         - help text
            }



    """"""

    o=i.get('out','')

    r=version({})
    if r['return']>0: return r

    h='CK version: '+r['version_str']+'\n'

    r=python_version({})
    if r['return']>0: return r

    h+='\nPython version used by CK: '+r['version']+'\n'

    h+='\nAll internal CK commands: ck help\n'

    h+='\n'+cfg['help_web'].replace('\n','').strip().replace('   ','')

    if o=='con': 
       out(h)

    return {'return':0, 'help':h}","['def' 'short_help' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ','
 ""''"" ')' 'r' '=' 'version' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']'
 '>' '0' ':' 'return' 'r' 'h' '=' ""'CK version: '"" '+' 'r' '['
 ""'version_str'"" ']' '+' ""'\\n'"" 'r' '=' 'python_version' '(' '{' '}' ')'
 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'h' '+='
 ""'\\nPython version used by CK: '"" '+' 'r' '[' ""'version'"" ']' '+'
 ""'\\n'"" 'h' '+=' ""'\\nAll internal CK commands: ck help\\n'"" 'h' '+='
 ""'\\n'"" '+' 'cfg' '[' ""'help_web'"" ']' '.' 'replace' '(' ""'\\n'"" ',' ""''""
 ')' '.' 'strip' '(' ')' '.' 'replace' '(' ""'   '"" ',' ""''"" ')' 'if' 'o'
 '==' ""'con'"" ':' 'out' '(' 'h' ')' 'return' '{' ""'return'"" ':' '0' ','
 ""'help'"" ':' 'h' '}']","Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              help         - help text
            }",['Input' ':' '{' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5107-L5143
ctuning/ck,ck/kernel.py,print_input,"def print_input(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              html         - input as JSON
            }

    """"""

    o=i.get('out','')

    rx=dumps_json({'dict':i, 'sort_keys':'yes'})
    if rx['return']>0: return rx

    h=rx['string']

    if o=='con': out(h)

    return {'return':0, 'html':h}",python,"def print_input(i):
    """"""
    Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              html         - input as JSON
            }

    """"""

    o=i.get('out','')

    rx=dumps_json({'dict':i, 'sort_keys':'yes'})
    if rx['return']>0: return rx

    h=rx['string']

    if o=='con': out(h)

    return {'return':0, 'html':h}","['def' 'print_input' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ','
 ""''"" ')' 'rx' '=' 'dumps_json' '(' '{' ""'dict'"" ':' 'i' ',' ""'sort_keys'""
 ':' ""'yes'"" '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return'
 'rx' 'h' '=' 'rx' '[' ""'string'"" ']' 'if' 'o' '==' ""'con'"" ':' 'out' '('
 'h' ')' 'return' '{' ""'return'"" ':' '0' ',' ""'html'"" ':' 'h' '}']","Input:  {
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              html         - input as JSON
            }",['Input' ':' '{' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5150-L5174
ctuning/ck,ck/kernel.py,info,"def info(i):
    """"""
    Input:  {
              (repo_uoa)
              module_uoa
              (data_uoa)
            }

    Output: {
              Output of 'load' function
            }

    """"""

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if muoa=='':
       return {'return':1, 'error':'module UOA is not defined'}

    module_info=False
    if duoa=='':
       module_info=True
       duoa=muoa
       muoa=cfg['module_name']

    ii={'module_uoa':muoa, 'data_uoa':duoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r

    if o=='con':
       if module_info:
          p=r['path']
          dd=r['dict']

          developer=dd.get('developer','')
          license=dd.get('license','')
          desc=dd.get('desc','')

          # Get user-friendly CID
          rx=convert_entry_to_cid(r)
          if rx['return']>0: return rx

          cuoa=rx['cuoa']
          cid=rx['cid']
          xcuoa=rx['xcuoa']
          xcid=rx['xcid']

          out('*** CID ***')
          out(cuoa+' ('+cid+')')

          out('')
          out('*** Path ***')
          out(p)

          if desc!='':
             out('')
             out('*** Description ***')
             out(desc)

          if developer!='':
             out('')
             out('*** Developer ***')
             out(developer)

          if license!='':
             out('')
             out('*** License ***')
             out(license)

       else:
          p=r['path']
          duid=r['data_uid']
          dalias=r['data_alias']
          muid=r['module_uid']
          malias=r['module_alias']

          out('Path  =        '+p)
          out('')
          out('Data alias =   '+dalias)
          out('Data UID   =   '+duid)
          out('')
          out('Module alias = '+malias)
          out('Module UID   = '+muid)

    return r",python,"def info(i):
    """"""
    Input:  {
              (repo_uoa)
              module_uoa
              (data_uoa)
            }

    Output: {
              Output of 'load' function
            }

    """"""

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if muoa=='':
       return {'return':1, 'error':'module UOA is not defined'}

    module_info=False
    if duoa=='':
       module_info=True
       duoa=muoa
       muoa=cfg['module_name']

    ii={'module_uoa':muoa, 'data_uoa':duoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r

    if o=='con':
       if module_info:
          p=r['path']
          dd=r['dict']

          developer=dd.get('developer','')
          license=dd.get('license','')
          desc=dd.get('desc','')

          # Get user-friendly CID
          rx=convert_entry_to_cid(r)
          if rx['return']>0: return rx

          cuoa=rx['cuoa']
          cid=rx['cid']
          xcuoa=rx['xcuoa']
          xcid=rx['xcid']

          out('*** CID ***')
          out(cuoa+' ('+cid+')')

          out('')
          out('*** Path ***')
          out(p)

          if desc!='':
             out('')
             out('*** Description ***')
             out(desc)

          if developer!='':
             out('')
             out('*** Developer ***')
             out(developer)

          if license!='':
             out('')
             out('*** License ***')
             out(license)

       else:
          p=r['path']
          duid=r['data_uid']
          dalias=r['data_alias']
          muid=r['module_uid']
          malias=r['module_alias']

          out('Path  =        '+p)
          out('')
          out('Data alias =   '+dalias)
          out('Data UID   =   '+duid)
          out('')
          out('Module alias = '+malias)
          out('Module UID   = '+muid)

    return r","['def' 'info' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'muoa' '=' 'i'
 '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.' 'get' '('
 ""'data_uoa'"" ',' ""''"" ')' 'if' 'muoa' '==' ""''"" ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':' ""'module UOA is not defined'"" '}'
 'module_info' '=' 'False' 'if' 'duoa' '==' ""''"" ':' 'module_info' '='
 'True' 'duoa' '=' 'muoa' 'muoa' '=' 'cfg' '[' ""'module_name'"" ']' 'ii'
 '=' '{' ""'module_uoa'"" ':' 'muoa' ',' ""'data_uoa'"" ':' 'duoa' '}' 'if'
 'ruoa' '!=' ""''"" ':' 'ii' '[' ""'repo_uoa'"" ']' '=' 'ruoa' 'r' '=' 'load'
 '(' 'ii' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'if'
 'o' '==' ""'con'"" ':' 'if' 'module_info' ':' 'p' '=' 'r' '[' ""'path'"" ']'
 'dd' '=' 'r' '[' ""'dict'"" ']' 'developer' '=' 'dd' '.' 'get' '('
 ""'developer'"" ',' ""''"" ')' 'license' '=' 'dd' '.' 'get' '(' ""'license'""
 ',' ""''"" ')' 'desc' '=' 'dd' '.' 'get' '(' ""'desc'"" ',' ""''"" ')'
 '# Get user-friendly CID' 'rx' '=' 'convert_entry_to_cid' '(' 'r' ')'
 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'cuoa' '=' 'rx'
 '[' ""'cuoa'"" ']' 'cid' '=' 'rx' '[' ""'cid'"" ']' 'xcuoa' '=' 'rx' '['
 ""'xcuoa'"" ']' 'xcid' '=' 'rx' '[' ""'xcid'"" ']' 'out' '(' ""'*** CID ***'""
 ')' 'out' '(' 'cuoa' '+' ""' ('"" '+' 'cid' '+' ""')'"" ')' 'out' '(' ""''""
 ')' 'out' '(' ""'*** Path ***'"" ')' 'out' '(' 'p' ')' 'if' 'desc' '!='
 ""''"" ':' 'out' '(' ""''"" ')' 'out' '(' ""'*** Description ***'"" ')' 'out'
 '(' 'desc' ')' 'if' 'developer' '!=' ""''"" ':' 'out' '(' ""''"" ')' 'out'
 '(' ""'*** Developer ***'"" ')' 'out' '(' 'developer' ')' 'if' 'license'
 '!=' ""''"" ':' 'out' '(' ""''"" ')' 'out' '(' ""'*** License ***'"" ')' 'out'
 '(' 'license' ')' 'else' ':' 'p' '=' 'r' '[' ""'path'"" ']' 'duid' '=' 'r'
 '[' ""'data_uid'"" ']' 'dalias' '=' 'r' '[' ""'data_alias'"" ']' 'muid' '='
 'r' '[' ""'module_uid'"" ']' 'malias' '=' 'r' '[' ""'module_alias'"" ']'
 'out' '(' ""'Path  =        '"" '+' 'p' ')' 'out' '(' ""''"" ')' 'out' '('
 ""'Data alias =   '"" '+' 'dalias' ')' 'out' '(' ""'Data UID   =   '"" '+'
 'duid' ')' 'out' '(' ""''"" ')' 'out' '(' ""'Module alias = '"" '+' 'malias'
 ')' 'out' '(' ""'Module UID   = '"" '+' 'muid' ')' 'return' 'r']","Input:  {
              (repo_uoa)
              module_uoa
              (data_uoa)
            }

    Output: {
              Output of 'load' function
            }",['Input' ':' '{' '(' 'repo_uoa' ')' 'module_uoa' '(' 'data_uoa' ')' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5181-L5270
ctuning/ck,ck/kernel.py,path,"def path(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output from from 'detect_cid_in_current_path' function
            }

    """"""

    o=i.get('out','')

    r=detect_cid_in_current_path(i)
    if r['return']>0: return r

    rx=convert_entry_to_cid(r)
    if rx['return']>0: return rx

    cuoa=rx['cuoa']
    cid=rx['cid']
    xcuoa=rx['xcuoa']
    xcid=rx['xcid']

    # If console, print CIDs
    if o=='con':
       out(cuoa)
       out(cid)
       out(xcuoa)
       out(xcid)

    return r",python,"def path(i):
    """"""
    Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output from from 'detect_cid_in_current_path' function
            }

    """"""

    o=i.get('out','')

    r=detect_cid_in_current_path(i)
    if r['return']>0: return r

    rx=convert_entry_to_cid(r)
    if rx['return']>0: return rx

    cuoa=rx['cuoa']
    cid=rx['cid']
    xcuoa=rx['xcuoa']
    xcid=rx['xcid']

    # If console, print CIDs
    if o=='con':
       out(cuoa)
       out(cid)
       out(xcuoa)
       out(xcid)

    return r","['def' 'path' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'r' '=' 'detect_cid_in_current_path' '(' 'i' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'rx' '=' 'convert_entry_to_cid'
 '(' 'r' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'cuoa'
 '=' 'rx' '[' ""'cuoa'"" ']' 'cid' '=' 'rx' '[' ""'cid'"" ']' 'xcuoa' '=' 'rx'
 '[' ""'xcuoa'"" ']' 'xcid' '=' 'rx' '[' ""'xcid'"" ']'
 '# If console, print CIDs' 'if' 'o' '==' ""'con'"" ':' 'out' '(' 'cuoa' ')'
 'out' '(' 'cid' ')' 'out' '(' 'xcuoa' ')' 'out' '(' 'xcid' ')' 'return'
 'r']","Input:  {}

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output from from 'detect_cid_in_current_path' function
            }",['Input' ':' '{}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5277-L5311
ctuning/ck,ck/kernel.py,cid,"def cid(i):
    """"""
    Input:  {
              (repo_uoa)   - repo UOA
              (module_uoa) - module UOA
              (data_uoa)   - data UOA

                 If above is empty, detect in current path !

            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output from from 'detect_cid_in_current_path' function

              data_uoa     - data UOA
              module_uoa   - module UOA
              (repo_uoa)   - repo UOA
            }

    """"""

    o=i.get('out','')

    # Check which CID to detect
    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if ruoa=='' and muoa=='' and duoa=='':
       r=detect_cid_in_current_path(i)
    else:
       r=find({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    rx=convert_entry_to_cid(r)
    if rx['return']>0: return rx

    cid=rx['cid']

    # If console, print CIDs
    if o=='con':
       out(cid)
       # Try to copy to Clipboard if supported by OS
       rx=copy_to_clipboard({'string':cid})
       # Ignore error

    return r",python,"def cid(i):
    """"""
    Input:  {
              (repo_uoa)   - repo UOA
              (module_uoa) - module UOA
              (data_uoa)   - data UOA

                 If above is empty, detect in current path !

            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output from from 'detect_cid_in_current_path' function

              data_uoa     - data UOA
              module_uoa   - module UOA
              (repo_uoa)   - repo UOA
            }

    """"""

    o=i.get('out','')

    # Check which CID to detect
    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if ruoa=='' and muoa=='' and duoa=='':
       r=detect_cid_in_current_path(i)
    else:
       r=find({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    rx=convert_entry_to_cid(r)
    if rx['return']>0: return rx

    cid=rx['cid']

    # If console, print CIDs
    if o=='con':
       out(cid)
       # Try to copy to Clipboard if supported by OS
       rx=copy_to_clipboard({'string':cid})
       # Ignore error

    return r","['def' 'cid' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' '# Check which CID to detect' 'ruoa' '=' 'i' '.' 'get' '('
 ""'repo_uoa'"" ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ','
 ""''"" ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if'
 'ruoa' '==' ""''"" 'and' 'muoa' '==' ""''"" 'and' 'duoa' '==' ""''"" ':' 'r'
 '=' 'detect_cid_in_current_path' '(' 'i' ')' 'else' ':' 'r' '=' 'find'
 '(' '{' ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ','
 ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'rx' '=' 'convert_entry_to_cid' '(' 'r' ')' 'if' 'rx' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'cid' '=' 'rx' '[' ""'cid'"" ']'
 '# If console, print CIDs' 'if' 'o' '==' ""'con'"" ':' 'out' '(' 'cid' ')'
 '# Try to copy to Clipboard if supported by OS' 'rx' '='
 'copy_to_clipboard' '(' '{' ""'string'"" ':' 'cid' '}' ')' '# Ignore error'
 'return' 'r']","Input:  {
              (repo_uoa)   - repo UOA
              (module_uoa) - module UOA
              (data_uoa)   - data UOA

                 If above is empty, detect in current path !

            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output from from 'detect_cid_in_current_path' function

              data_uoa     - data UOA
              module_uoa   - module UOA
              (repo_uoa)   - repo UOA
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' '(' 'module_uoa' ')'
 '-' 'module' 'UOA' '(' 'data_uoa' ')' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5318-L5368
ctuning/ck,ck/kernel.py,copy_path_to_clipboard,"def copy_path_to_clipboard(i):
    """"""
    Input:  {
              (add_quotes) - if 'yes', add quotes
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    import os
    p=os.getcwd()

    if i.get('add_quotes','')=='yes':
       p='""'+p+'""'

    rx=copy_to_clipboard({'string':p})
    # Ignore error

    return {'return':0}",python,"def copy_path_to_clipboard(i):
    """"""
    Input:  {
              (add_quotes) - if 'yes', add quotes
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    import os
    p=os.getcwd()

    if i.get('add_quotes','')=='yes':
       p='""'+p+'""'

    rx=copy_to_clipboard({'string':p})
    # Ignore error

    return {'return':0}","['def' 'copy_path_to_clipboard' '(' 'i' ')' ':' 'import' 'os' 'p' '=' 'os'
 '.' 'getcwd' '(' ')' 'if' 'i' '.' 'get' '(' ""'add_quotes'"" ',' ""''"" ')'
 '==' ""'yes'"" ':' 'p' '=' '\'""\'' '+' 'p' '+' '\'""\'' 'rx' '='
 'copy_to_clipboard' '(' '{' ""'string'"" ':' 'p' '}' ')' '# Ignore error'
 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              (add_quotes) - if 'yes', add quotes
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }",['Input' ':' '{' '(' 'add_quotes' ')' '-' 'if' 'yes' 'add' 'quotes' '}'],train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5375-L5398
ctuning/ck,ck/kernel.py,load,"def load(i):
    """"""
    Input:  {
              (repo_uoa)              - repo UOA
              module_uoa              - module UOA
              data_uoa                - data UOA

              (get_lock)              - if 'yes', lock this entry
              (lock_retries)          - number of retries to aquire lock (default=5)
              (lock_retry_delay)      - delay in seconds before trying to aquire lock again (default=10)
              (lock_expire_time)      - number of seconds before lock expires (default=30)

              (skip_updates)          - if 'yes', do not load updates
              (skip_desc)             - if 'yes', do not load descriptions

              (load_extra_json_files) - list of files to load from the entry

              (unlock_uid)            - UID of the lock to release it

              (min)                   - show minimum when output to console (i.e. meta and desc)

              (create_if_not_found)   - if 'yes', create, if entry is not found - useful to create and lock entries
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - entry meta description
              (info)       - entry info
              (updates)    - entry updates
              (desc)       - entry description

              path         - path to data entry
              path_module  - path to module entry with this entry
              path_repo    - path to the repository of this entry
              repo_uoa     - repo UOA 
              repo_uid     - repo UID
              repo_alias   - repo alias
              module_uoa   - module UOA 
              module_uid   - module UID
              module_alias - module alias
              data_uoa     - data UOA
              data_uid     - data UID
              data_alias   - data alias
              data_name    - user friendly name

              (extra_json_files) - dict with extra json files (key is the filename from 'load_extra_json_files')

              (lock_uid)   - unlock UID, if locked successfully
            }
    """"""

    o=i.get('out','')

    a=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    d=i.get('data_uoa','')

    if d=='':
       return {'return':1, 'error':'data UOA is not defined'}

    r=find_path_to_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':d})
    if r['return']>0: 
       if r['return']==16 and i.get('create_if_not_found','')=='yes':
          r=add({'repo_uoa':a, 'module_uoa':m, 'data_uoa':d})
          if r['return']>0:
             return r
          r=find_path_to_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':d})
          if r['return']>0: return r
       else:
          return r

    p=r['path']

    slu=i.get('skip_updates','')
    sld=i.get('skip_desc','')

    # Set/check lock
    i['path']=p
    rx=set_lock(i)
    if rx['return']>0: return rx

    luid=rx.get('lock_uid','')

    # Load meta description
    r1=load_meta_from_path({'path':p, 'skip_updates':slu, 'skip_desc':sld})
    if r1['return']>0: return r1

    r.update(r1)
    r['path']=p

    r['data_name']=r1.get('info',{}).get('data_name','')

    if luid!='': r['lock_uid']=luid

    # If load extra files
    lejf=i.get('load_extra_json_files',[])
    if len(lejf)>0:
       ejf={}
       for ff in lejf:
           rx=load_json_file({'json_file':os.path.join(p,ff)})
           if rx['return']>0: return rx
           ejf[ff]=rx['dict']
       r['extra_json_files']=ejf

    # If console mode, print json
    if o=='con':
       dd=r
       if i.get('min','')=='yes':
          dd={
              'desc':r.get('desc',{}),
              'dict':r.get('dict',{})
             }

       rr=dumps_json({'dict':dd, 'sort_keys':'yes'})
       if rr['return']==0:
          out(rr['string'])

    return r",python,"def load(i):
    """"""
    Input:  {
              (repo_uoa)              - repo UOA
              module_uoa              - module UOA
              data_uoa                - data UOA

              (get_lock)              - if 'yes', lock this entry
              (lock_retries)          - number of retries to aquire lock (default=5)
              (lock_retry_delay)      - delay in seconds before trying to aquire lock again (default=10)
              (lock_expire_time)      - number of seconds before lock expires (default=30)

              (skip_updates)          - if 'yes', do not load updates
              (skip_desc)             - if 'yes', do not load descriptions

              (load_extra_json_files) - list of files to load from the entry

              (unlock_uid)            - UID of the lock to release it

              (min)                   - show minimum when output to console (i.e. meta and desc)

              (create_if_not_found)   - if 'yes', create, if entry is not found - useful to create and lock entries
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - entry meta description
              (info)       - entry info
              (updates)    - entry updates
              (desc)       - entry description

              path         - path to data entry
              path_module  - path to module entry with this entry
              path_repo    - path to the repository of this entry
              repo_uoa     - repo UOA 
              repo_uid     - repo UID
              repo_alias   - repo alias
              module_uoa   - module UOA 
              module_uid   - module UID
              module_alias - module alias
              data_uoa     - data UOA
              data_uid     - data UID
              data_alias   - data alias
              data_name    - user friendly name

              (extra_json_files) - dict with extra json files (key is the filename from 'load_extra_json_files')

              (lock_uid)   - unlock UID, if locked successfully
            }
    """"""

    o=i.get('out','')

    a=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    d=i.get('data_uoa','')

    if d=='':
       return {'return':1, 'error':'data UOA is not defined'}

    r=find_path_to_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':d})
    if r['return']>0: 
       if r['return']==16 and i.get('create_if_not_found','')=='yes':
          r=add({'repo_uoa':a, 'module_uoa':m, 'data_uoa':d})
          if r['return']>0:
             return r
          r=find_path_to_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':d})
          if r['return']>0: return r
       else:
          return r

    p=r['path']

    slu=i.get('skip_updates','')
    sld=i.get('skip_desc','')

    # Set/check lock
    i['path']=p
    rx=set_lock(i)
    if rx['return']>0: return rx

    luid=rx.get('lock_uid','')

    # Load meta description
    r1=load_meta_from_path({'path':p, 'skip_updates':slu, 'skip_desc':sld})
    if r1['return']>0: return r1

    r.update(r1)
    r['path']=p

    r['data_name']=r1.get('info',{}).get('data_name','')

    if luid!='': r['lock_uid']=luid

    # If load extra files
    lejf=i.get('load_extra_json_files',[])
    if len(lejf)>0:
       ejf={}
       for ff in lejf:
           rx=load_json_file({'json_file':os.path.join(p,ff)})
           if rx['return']>0: return rx
           ejf[ff]=rx['dict']
       r['extra_json_files']=ejf

    # If console mode, print json
    if o=='con':
       dd=r
       if i.get('min','')=='yes':
          dd={
              'desc':r.get('desc',{}),
              'dict':r.get('dict',{})
             }

       rr=dumps_json({'dict':dd, 'sort_keys':'yes'})
       if rr['return']==0:
          out(rr['string'])

    return r","['def' 'load' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'a' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'm' '=' 'i' '.'
 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'd' '=' 'i' '.' 'get' '('
 ""'data_uoa'"" ',' ""''"" ')' 'if' 'd' '==' ""''"" ':' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'data UOA is not defined'"" '}' 'r' '='
 'find_path_to_data' '(' '{' ""'repo_uoa'"" ':' 'a' ',' ""'module_uoa'"" ':'
 'm' ',' ""'data_uoa'"" ':' 'd' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'if' 'r' '[' ""'return'"" ']' '==' '16' 'and' 'i' '.' 'get' '('
 ""'create_if_not_found'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'r' '=' 'add' '('
 '{' ""'repo_uoa'"" ':' 'a' ',' ""'module_uoa'"" ':' 'm' ',' ""'data_uoa'"" ':'
 'd' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'r' '='
 'find_path_to_data' '(' '{' ""'repo_uoa'"" ':' 'a' ',' ""'module_uoa'"" ':'
 'm' ',' ""'data_uoa'"" ':' 'd' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' 'else' ':' 'return' 'r' 'p' '=' 'r' '[' ""'path'"" ']'
 'slu' '=' 'i' '.' 'get' '(' ""'skip_updates'"" ',' ""''"" ')' 'sld' '=' 'i'
 '.' 'get' '(' ""'skip_desc'"" ',' ""''"" ')' '# Set/check lock' 'i' '['
 ""'path'"" ']' '=' 'p' 'rx' '=' 'set_lock' '(' 'i' ')' 'if' 'rx' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'luid' '=' 'rx' '.' 'get' '('
 ""'lock_uid'"" ',' ""''"" ')' '# Load meta description' 'r1' '='
 'load_meta_from_path' '(' '{' ""'path'"" ':' 'p' ',' ""'skip_updates'"" ':'
 'slu' ',' ""'skip_desc'"" ':' 'sld' '}' ')' 'if' 'r1' '[' ""'return'"" ']'
 '>' '0' ':' 'return' 'r1' 'r' '.' 'update' '(' 'r1' ')' 'r' '[' ""'path'""
 ']' '=' 'p' 'r' '[' ""'data_name'"" ']' '=' 'r1' '.' 'get' '(' ""'info'"" ','
 '{' '}' ')' '.' 'get' '(' ""'data_name'"" ',' ""''"" ')' 'if' 'luid' '!='
 ""''"" ':' 'r' '[' ""'lock_uid'"" ']' '=' 'luid' '# If load extra files'
 'lejf' '=' 'i' '.' 'get' '(' ""'load_extra_json_files'"" ',' '[' ']' ')'
 'if' 'len' '(' 'lejf' ')' '>' '0' ':' 'ejf' '=' '{' '}' 'for' 'ff' 'in'
 'lejf' ':' 'rx' '=' 'load_json_file' '(' '{' ""'json_file'"" ':' 'os' '.'
 'path' '.' 'join' '(' 'p' ',' 'ff' ')' '}' ')' 'if' 'rx' '[' ""'return'""
 ']' '>' '0' ':' 'return' 'rx' 'ejf' '[' 'ff' ']' '=' 'rx' '[' ""'dict'""
 ']' 'r' '[' ""'extra_json_files'"" ']' '=' 'ejf'
 '# If console mode, print json' 'if' 'o' '==' ""'con'"" ':' 'dd' '=' 'r'
 'if' 'i' '.' 'get' '(' ""'min'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'dd' '=' '{'
 ""'desc'"" ':' 'r' '.' 'get' '(' ""'desc'"" ',' '{' '}' ')' ',' ""'dict'"" ':'
 'r' '.' 'get' '(' ""'dict'"" ',' '{' '}' ')' '}' 'rr' '=' 'dumps_json' '('
 '{' ""'dict'"" ':' 'dd' ',' ""'sort_keys'"" ':' ""'yes'"" '}' ')' 'if' 'rr' '['
 ""'return'"" ']' '==' '0' ':' 'out' '(' 'rr' '[' ""'string'"" ']' ')'
 'return' 'r']","Input:  {
              (repo_uoa)              - repo UOA
              module_uoa              - module UOA
              data_uoa                - data UOA

              (get_lock)              - if 'yes', lock this entry
              (lock_retries)          - number of retries to aquire lock (default=5)
              (lock_retry_delay)      - delay in seconds before trying to aquire lock again (default=10)
              (lock_expire_time)      - number of seconds before lock expires (default=30)

              (skip_updates)          - if 'yes', do not load updates
              (skip_desc)             - if 'yes', do not load descriptions

              (load_extra_json_files) - list of files to load from the entry

              (unlock_uid)            - UID of the lock to release it

              (min)                   - show minimum when output to console (i.e. meta and desc)

              (create_if_not_found)   - if 'yes', create, if entry is not found - useful to create and lock entries
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - entry meta description
              (info)       - entry info
              (updates)    - entry updates
              (desc)       - entry description

              path         - path to data entry
              path_module  - path to module entry with this entry
              path_repo    - path to the repository of this entry
              repo_uoa     - repo UOA 
              repo_uid     - repo UID
              repo_alias   - repo alias
              module_uoa   - module UOA 
              module_uid   - module UID
              module_alias - module alias
              data_uoa     - data UOA
              data_uid     - data UID
              data_alias   - data alias
              data_name    - user friendly name

              (extra_json_files) - dict with extra json files (key is the filename from 'load_extra_json_files')

              (lock_uid)   - unlock UID, if locked successfully
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5405-L5525
ctuning/ck,ck/kernel.py,find,"def find(i):
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA
            }

    Output: { 
              Output of the 'load' function 

              number_of_entries - total number of found entries
            }
    """"""

    o=i.get('out','')
    i['out']=''

    # Check wildcards
    lst=[]

    a=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if m=='':
       return {'return':1, 'error':'module UOA is not defined'}
    if duoa=='':
       return {'return':1, 'error':'data UOA is not defined'}

    if a.find('*')>=0 or a.find('?')>=0 or m.find('*')>=0 or m.find('?')>=0 or duoa.find('*')>=0 or duoa.find('?')>=0: 
       r=list_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
       if r['return']>0: return r

       lst=r['lst']

       r={'return':0}

       if len(lst)>0:
          r.update(lst[0])
       else:
          return {'return':1, 'error':'entry was not found'}

    else:
       # Find path to data
       r=find_path_to_data(i)
       if r['return']>0: return r

       p=r['path']
       ruoa=r.get('repo_uoa','')
       ruid=r.get('repo_uid','')
       muoa=r.get('module_uoa','')
       muid=r.get('module_uid','')
       duid=r.get('data_uid','')
       duoa=r.get('data_alias','')
       if duoa=='': duoa=duid

       lst.append({'path':p, 'repo_uoa':ruoa, 'repo_uid':ruid, 
                             'module_uoa':muoa, 'module_uid':muid, 
                             'data_uoa':duoa, 'data_uid': duid})

    if o=='con':
       pf='' 
       for q in lst:
           p=q['path']
           out(p)
           if pf=='': pf=p

    i['out']=o

    r['number_of_entries']=len(lst)

    return r",python,"def find(i):
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA
            }

    Output: { 
              Output of the 'load' function 

              number_of_entries - total number of found entries
            }
    """"""

    o=i.get('out','')
    i['out']=''

    # Check wildcards
    lst=[]

    a=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if m=='':
       return {'return':1, 'error':'module UOA is not defined'}
    if duoa=='':
       return {'return':1, 'error':'data UOA is not defined'}

    if a.find('*')>=0 or a.find('?')>=0 or m.find('*')>=0 or m.find('?')>=0 or duoa.find('*')>=0 or duoa.find('?')>=0: 
       r=list_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
       if r['return']>0: return r

       lst=r['lst']

       r={'return':0}

       if len(lst)>0:
          r.update(lst[0])
       else:
          return {'return':1, 'error':'entry was not found'}

    else:
       # Find path to data
       r=find_path_to_data(i)
       if r['return']>0: return r

       p=r['path']
       ruoa=r.get('repo_uoa','')
       ruid=r.get('repo_uid','')
       muoa=r.get('module_uoa','')
       muid=r.get('module_uid','')
       duid=r.get('data_uid','')
       duoa=r.get('data_alias','')
       if duoa=='': duoa=duid

       lst.append({'path':p, 'repo_uoa':ruoa, 'repo_uid':ruid, 
                             'module_uoa':muoa, 'module_uid':muid, 
                             'data_uoa':duoa, 'data_uid': duid})

    if o=='con':
       pf='' 
       for q in lst:
           p=q['path']
           out(p)
           if pf=='': pf=p

    i['out']=o

    r['number_of_entries']=len(lst)

    return r","['def' 'find' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'i' '[' ""'out'"" ']' '=' ""''"" '# Check wildcards' 'lst' '=' '[' ']'
 'a' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'm' '=' 'i' '.' 'get'
 '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'""
 ',' ""''"" ')' 'if' 'm' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'module UOA is not defined'"" '}' 'if' 'duoa' '==' ""''"" ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'data UOA is not defined'"" '}' 'if' 'a' '.' 'find' '(' ""'*'"" ')' '>='
 '0' 'or' 'a' '.' 'find' '(' ""'?'"" ')' '>=' '0' 'or' 'm' '.' 'find' '('
 ""'*'"" ')' '>=' '0' 'or' 'm' '.' 'find' '(' ""'?'"" ')' '>=' '0' 'or' 'duoa'
 '.' 'find' '(' ""'*'"" ')' '>=' '0' 'or' 'duoa' '.' 'find' '(' ""'?'"" ')'
 '>=' '0' ':' 'r' '=' 'list_data' '(' '{' ""'repo_uoa'"" ':' 'a' ','
 ""'module_uoa'"" ':' 'm' ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'lst' '=' 'r' '[' ""'lst'"" ']' 'r'
 '=' '{' ""'return'"" ':' '0' '}' 'if' 'len' '(' 'lst' ')' '>' '0' ':' 'r'
 '.' 'update' '(' 'lst' '[' '0' ']' ')' 'else' ':' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'entry was not found'"" '}' 'else' ':'
 '# Find path to data' 'r' '=' 'find_path_to_data' '(' 'i' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'p' '=' 'r' '[' ""'path'"" ']'
 'ruoa' '=' 'r' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'ruid' '=' 'r' '.'
 'get' '(' ""'repo_uid'"" ',' ""''"" ')' 'muoa' '=' 'r' '.' 'get' '('
 ""'module_uoa'"" ',' ""''"" ')' 'muid' '=' 'r' '.' 'get' '(' ""'module_uid'""
 ',' ""''"" ')' 'duid' '=' 'r' '.' 'get' '(' ""'data_uid'"" ',' ""''"" ')'
 'duoa' '=' 'r' '.' 'get' '(' ""'data_alias'"" ',' ""''"" ')' 'if' 'duoa' '=='
 ""''"" ':' 'duoa' '=' 'duid' 'lst' '.' 'append' '(' '{' ""'path'"" ':' 'p'
 ',' ""'repo_uoa'"" ':' 'ruoa' ',' ""'repo_uid'"" ':' 'ruid' ','
 ""'module_uoa'"" ':' 'muoa' ',' ""'module_uid'"" ':' 'muid' ',' ""'data_uoa'""
 ':' 'duoa' ',' ""'data_uid'"" ':' 'duid' '}' ')' 'if' 'o' '==' ""'con'"" ':'
 'pf' '=' ""''"" 'for' 'q' 'in' 'lst' ':' 'p' '=' 'q' '[' ""'path'"" ']' 'out'
 '(' 'p' ')' 'if' 'pf' '==' ""''"" ':' 'pf' '=' 'p' 'i' '[' ""'out'"" ']' '='
 'o' 'r' '[' ""'number_of_entries'"" ']' '=' 'len' '(' 'lst' ')' 'return'
 'r']","Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA
            }

    Output: { 
              Output of the 'load' function 

              number_of_entries - total number of found entries
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5532-L5604
ctuning/ck,ck/kernel.py,cd,"def cd(i):
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA
                 or
              cid

            }

    Output: { 
              Output of the 'load' function 

              string - prepared string 'cd {path to entry}'
            }
    """"""

    o=i.get('out','')

    i['out']=''
    r=find(i)
    i['out']=o

    if r['return']>0: return r

    noe=r.get('number_of_entries','')
    if noe=='': noe=0

    if noe>1 and o=='con':
       out('CK warning: '+str(noe)+' entries found! Selecting the first one ...')
       out('')

    p=r.get('path','')
    if p!='':
       rx=get_os_ck({})
       if rx['return']>0: return rx

       plat=rx['platform']

       s='cd '
       if plat=='win':
          s+='/D '

       if p.find(' ')>0:
          p='""'+p+'""'
       s+=p

       out(s)

       r['string']=s

       import platform
       import subprocess

       out('')
       out('Warning: you are in a new shell with a reused environment. Enter ""exit"" to return to the original one!')

       if platform.system().lower().startswith('win'): # pragma: no cover
          p = subprocess.Popen([""cmd"", ""/k"", s], shell = True, env=os.environ)
          p.wait()

       else:
          rx=gen_tmp_file({})
          if rx['return']>0: return rx
          fn=rx['file_name']

          rx=save_text_file({'text_file':fn, 'string':s})
          if rx['return']>0: return rx

          os.system(""bash --rcfile ""+fn)

    return r",python,"def cd(i):
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA
                 or
              cid

            }

    Output: { 
              Output of the 'load' function 

              string - prepared string 'cd {path to entry}'
            }
    """"""

    o=i.get('out','')

    i['out']=''
    r=find(i)
    i['out']=o

    if r['return']>0: return r

    noe=r.get('number_of_entries','')
    if noe=='': noe=0

    if noe>1 and o=='con':
       out('CK warning: '+str(noe)+' entries found! Selecting the first one ...')
       out('')

    p=r.get('path','')
    if p!='':
       rx=get_os_ck({})
       if rx['return']>0: return rx

       plat=rx['platform']

       s='cd '
       if plat=='win':
          s+='/D '

       if p.find(' ')>0:
          p='""'+p+'""'
       s+=p

       out(s)

       r['string']=s

       import platform
       import subprocess

       out('')
       out('Warning: you are in a new shell with a reused environment. Enter ""exit"" to return to the original one!')

       if platform.system().lower().startswith('win'): # pragma: no cover
          p = subprocess.Popen([""cmd"", ""/k"", s], shell = True, env=os.environ)
          p.wait()

       else:
          rx=gen_tmp_file({})
          if rx['return']>0: return rx
          fn=rx['file_name']

          rx=save_text_file({'text_file':fn, 'string':s})
          if rx['return']>0: return rx

          os.system(""bash --rcfile ""+fn)

    return r","['def' 'cd' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')'
 'i' '[' ""'out'"" ']' '=' ""''"" 'r' '=' 'find' '(' 'i' ')' 'i' '[' ""'out'""
 ']' '=' 'o' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'noe'
 '=' 'r' '.' 'get' '(' ""'number_of_entries'"" ',' ""''"" ')' 'if' 'noe' '=='
 ""''"" ':' 'noe' '=' '0' 'if' 'noe' '>' '1' 'and' 'o' '==' ""'con'"" ':'
 'out' '(' ""'CK warning: '"" '+' 'str' '(' 'noe' ')' '+'
 ""' entries found! Selecting the first one ...'"" ')' 'out' '(' ""''"" ')'
 'p' '=' 'r' '.' 'get' '(' ""'path'"" ',' ""''"" ')' 'if' 'p' '!=' ""''"" ':'
 'rx' '=' 'get_os_ck' '(' '{' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'rx' 'plat' '=' 'rx' '[' ""'platform'"" ']' 's' '=' ""'cd '""
 'if' 'plat' '==' ""'win'"" ':' 's' '+=' ""'/D '"" 'if' 'p' '.' 'find' '('
 ""' '"" ')' '>' '0' ':' 'p' '=' '\'""\'' '+' 'p' '+' '\'""\'' 's' '+=' 'p'
 'out' '(' 's' ')' 'r' '[' ""'string'"" ']' '=' 's' 'import' 'platform'
 'import' 'subprocess' 'out' '(' ""''"" ')' 'out' '('
 '\'Warning: you are in a new shell with a reused environment. Enter ""exit"" to return to the original one!\''
 ')' 'if' 'platform' '.' 'system' '(' ')' '.' 'lower' '(' ')' '.'
 'startswith' '(' ""'win'"" ')' ':' '# pragma: no cover' 'p' '='
 'subprocess' '.' 'Popen' '(' '[' '""cmd""' ',' '""/k""' ',' 's' ']' ','
 'shell' '=' 'True' ',' 'env' '=' 'os' '.' 'environ' ')' 'p' '.' 'wait'
 '(' ')' 'else' ':' 'rx' '=' 'gen_tmp_file' '(' '{' '}' ')' 'if' 'rx' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'fn' '=' 'rx' '[' ""'file_name'""
 ']' 'rx' '=' 'save_text_file' '(' '{' ""'text_file'"" ':' 'fn' ','
 ""'string'"" ':' 's' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'rx' 'os' '.' 'system' '(' '""bash --rcfile ""' '+' 'fn' ')'
 'return' 'r']","Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA
                 or
              cid

            }

    Output: { 
              Output of the 'load' function 

              string - prepared string 'cd {path to entry}'
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA' 'or' 'cid']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5611-L5683
ctuning/ck,ck/kernel.py,cdc,"def cdc(i): # pragma: no cover
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA
                 or
              cid

            }

    Output: { 
              Output of the 'load' function 
            }
    """"""

    r=cd(i)
    if r['return']>0: return r

    s=r.get('string','')
    if s!='':
       rx=copy_to_clipboard({'string':s})
       if rx['return']>0: return rx

    return r",python,"def cdc(i): # pragma: no cover
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA
                 or
              cid

            }

    Output: { 
              Output of the 'load' function 
            }
    """"""

    r=cd(i)
    if r['return']>0: return r

    s=r.get('string','')
    if s!='':
       rx=copy_to_clipboard({'string':s})
       if rx['return']>0: return rx

    return r","['def' 'cdc' '(' 'i' ')' ':' '# pragma: no cover' 'r' '=' 'cd' '(' 'i' ')'
 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 's' '=' 'r' '.'
 'get' '(' ""'string'"" ',' ""''"" ')' 'if' 's' '!=' ""''"" ':' 'rx' '='
 'copy_to_clipboard' '(' '{' ""'string'"" ':' 's' '}' ')' 'if' 'rx' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'return' 'r']","Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA
                 or
              cid

            }

    Output: { 
              Output of the 'load' function 
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA' 'or' 'cid']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5690-L5714
ctuning/ck,ck/kernel.py,add,"def add(i):
    """"""
    Input:  {
              (repo_uoa)             - repo UOA
              module_uoa             - module UOA
              data_uoa               - data UOA
              (data_uid)             - data UID (if uoa is an alias)
              (data_name)            - user friendly data name

              (dict_from_cid)        -
              (dict_from_repo_uoa)   - 
              (dict_from_module_uoa) - 
              (dict_from_data_uoa)   - if present, pre-load dict 
                                       from this (module_uoa):data_uoa (analog of copy)

              (update)               - if == 'yes' and entry exists, update it

              (dict)                 - meta description to record
              (substitute)           - if 'yes' and update=='yes' substitute dictionaries, otherwise merge!

              (desc)                 - description of an entry (gradually adding API description in flat format)

              (extra_json_files)     - dict with extra json files to save to entry (key is a filename)

              (tags)                 - list or comma separated list of tags to add to entry

              (info)                 - entry info to record - normally, should not use it!
              (extra_info)           - enforce extra info such as
                                          author
                                          author_email
                                          author_webpage
                                          license
                                          copyright
                                       If not specified then taken from kernel (prefix 'default_')

              (updates)              - entry updates info to record - normally, should not use it!
              (ignore_update)        - if 'yes', do not add info about update

              (ask)                  - if 'yes', ask questions, otherwise silent

              (unlock_uid)           - unlock UID if was previously locked

              (sort_keys)            - by default, 'yes'

              (share)                - if 'yes', try to add via GIT
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if entry already exists
                                         >  0, if error
              (error)      - error text if return > 0

              Output from the 'create_entry' function
            }

    """"""

    o=i.get('out','')

    t='added'

    ra=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    d=i.get('data_uoa','')
    di=i.get('data_uid','')
    dn=i.get('data_name','')

    uuid=i.get('unlock_uid','')

    up=i.get('update','')

    ask=i.get('ask','')

    # Get repo path
    r=find_path_to_repo({'repo_uoa':ra})
    if r['return']>0: return r
    pr=r['path']

    ruoa=r['repo_uoa']
    ruid=r['repo_uid']
    ralias=r['repo_alias']

    rd=r['dict']
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    if i.get('share','')=='yes': rsync='yes'

    # Check if writing is allowed
    ii={'module_uoa':m, 'repo_uoa':r['repo_uoa'], 'repo_uid':r['repo_uid'], 'repo_dict':rd}
    r=check_writing(ii)
    if r['return']>0: return r

    # Load info about module
    r=load({'module_uoa':cfg['module_name'],
            'data_uoa':m})
    if r['return']>0: return r
    elif r['return']==16: 
       return {'return':8, 'error':'can\'t find path to module ""'+m+'""'}
    muoa=r['data_uoa']
    muid=r['data_uid']
    malias=r['data_alias']
    pm=r['path']

    uid=r['data_uid']
    alias=r['data_alias']
    if alias=='': alias=uid
    module_desc=r['dict']

    # Ask additional questions
    if o=='con' and ask=='yes':
       # Asking for alias
       if d=='' or is_uid(d):
          r=inp({'text':'Enter an alias (or Enter to skip it): '})
          d=r['string']

       # Asking for user-friendly name
       if dn=='' and up!='yes':
          r=inp({'text':'Enter a user-friendly name of this entry (or Enter to reuse alias): '})
          dn=r['string']

    # Load dictionary from other entry if needed
    dfcid=i.get('dict_from_cid','')
    dfruoa=i.get('dict_from_repo_uoa','')
    dfmuoa=i.get('dict_from_module_uoa','')
    dfduoa=i.get('dict_from_data_uoa','')

    if dfcid!='':
       r=parse_cid({'cid':dfcid})
       if r['return']>0: return r
       dfruoa=r.get('repo_uoa','')
       dfmuoa=r.get('module_uoa','')
       dfduoa=r.get('data_uoa','')

    if d!='' and not is_uoa(d):
       return {'return':1, 'error':'alias has disallowed characters'}

    if dfduoa!='':
       if dfmuoa=='': dfmuoa=m

       ii={'module_uoa':dfmuoa, 'data_uoa':dfduoa}
       if dfruoa!='': ii['repo_uoa']=dfruoa

       r=load(ii)
       if r['return']>0: return r

       df=r.get('dict',{})

    # Create first level entry (module) 
    r=create_entry({'path':pr, 'data_uoa':alias, 'data_uid':uid})
    if r['return']>0 and r['return']!=16: return r
    p1=r['path']

    # Create second level entry (data)
    i1={'path':p1}
    pdd=''
    if di!='': 
       i1['data_uid']=di
    if d!='': 
       i1['data_uoa']=d
    rr=create_entry(i1)
    if rr['return']>0 and rr['return']!=16: return rr

    duid=rr['data_uid']
    pdd=rr['data_uoa']
    dalias=rr['data_alias']

    # Preparing meta-description
    a={}
    info={}
    updates={}
    desc={}

    p2=rr['path']
    p3=os.path.join(p2, cfg['subdir_ck_ext'])
    p4=os.path.join(p3, cfg['file_meta'])
    p4i=os.path.join(p3, cfg['file_info'])
    p4u=os.path.join(p3, cfg['file_updates'])
    p4d=os.path.join(p3, cfg['file_desc'])

    # If last entry exists
    if rr['return']==16:
       if up=='yes':
          t='updated'

          # Check if locked
          rl=check_lock({'path':p2, 'unlock_uid':uuid})
          if rl['return']>0: 
             if rl['return']==32:
                rl['data_uoa']=pdd
                rl['data_uid']=duid
             return rl

          # Entry exists, load configuration if update
          r2=load_meta_from_path({'path':p2})
          if r2['return']>0: return r2
          a=r2['dict']
          info=r2.get('info',{})
          updates=r2.get('updates',{})
          desc=r2.get('desc',{})

          if dn=='': dn=info.get('data_name','')
       else:
          return {'return':16,'error':'entry already exists in path ('+p2+')'}
    else:
       # Create configuration directory
       if not os.path.isdir(p3):
          try:
             os.mkdir(p3)
          except Exception as e:
             return {'return':1, 'error':format(e)}

    if dn=='' and not is_uid(d):
       dn=d

    if dfduoa!='':
       r=merge_dicts({'dict1':a, 'dict2':df})
       if r['return']>0: return r

    # If dict, info and updates are in input, try to merge ...
    cma=i.get('dict',{})
    cmad=i.get('desc',{})
    if i.get('substitute','')=='yes':
       a=cma
       desc=cmad
    else:
       r=merge_dicts({'dict1':a, 'dict2':cma})
       if r['return']>0: return r
       r=merge_dicts({'dict1':desc, 'dict2':cmad})
       if r['return']>0: return r

    # Check tags 
    xtags=a.get('tags',[])

    tags=i.get('tags','')
    if tags=='': tags=[]
    elif type(tags)!=list:
       tags=tags.split(',')

    for l in range(0,len(tags)):
        ll=tags[l].strip()
        if ll not in xtags:
           xtags.append(ll)

    if len(xtags)>0:
       a['tags']=xtags

    # Process info
    cminfo=i.get('info',{})
    if len(cminfo)!=0:
       info=cminfo
#       r=merge_dicts({'dict1':info, 'dict2':cminfo})
#       if r['return']>0: return r

    cmupdates=i.get('updates',{})
    if len(cmupdates)!=0:
       updates=cmupdates
#       r=merge_dicts({'dict1':updates, 'dict2':cmupdates})
#       if r['return']>0: return r

    # If name exists, add
    info['backup_module_uoa']=muoa
    info['backup_module_uid']=muid
    info['backup_data_uid']=duid
    if dn!='': info['data_name']=dn

    # Add control info
    ri=prepare_special_info_about_entry({})
    if ri['return']>0: return ri
    x=ri['dict']

    # Check if pre-set control params such as author, copyright, license
    ei=i.get('extra_info',{})
    if len(ei)!=0: x.update(ei)

    y=info.get('control',{})

    if i.get('ignore_update','')!='yes':
       if len(y)==0:
          info['control']=x
       else:
          y=updates.get('control',[])
          y.append(x)
          updates['control']=y

    sk=i.get('sort_keys','')
    if sk=='': sk='yes'

    if len(updates)>0:
       # Record updates
       rx=save_json_to_file({'json_file':p4u, 'dict':updates, 'sort_keys':sk})
       if rx['return']>0: return rx

    # Record meta description
    rx=save_json_to_file({'json_file':p4, 'dict':a, 'sort_keys':sk})
    if rx['return']>0: return rx

    # Record info
    rx=save_json_to_file({'json_file':p4i, 'dict':info, 'sort_keys':sk})
    if rx['return']>0: return rx

    # Record desc
    rx=save_json_to_file({'json_file':p4d, 'dict':desc, 'sort_keys':sk})
    if rx['return']>0: return rx

    # Record extra files if there
    ejf=i.get('extra_json_files',{})
    if len(ejf)>0:
       for ff in ejf:
           dff=ejf[ff]
           rz=save_json_to_file({'json_file':os.path.join(p2,ff), 'dict':dff, 'sort_keys':sk})
           if rz['return']>0: return rz

    if o=='con':
       out('Entry '+d+' ('+duid+', '+p2+') '+t+' successfully!')

    # Check if needs to be synced
    if rshared!='' and rsync=='yes':
       ppp=os.getcwd()

       os.chdir(pr)
       if os.path.isdir(cfg['subdir_ck_ext']):
          ss=cfg['repo_types'][rshared]['add'].replace('$#path#$', pr).replace('$#files#$', cfg['subdir_ck_ext'])
          rx=os.system(ss)

       os.chdir(p1)
       if os.path.isdir(cfg['subdir_ck_ext']):
          ss=cfg['repo_types'][rshared]['add'].replace('$#path#$', pr).replace('$#files#$', cfg['subdir_ck_ext'])
          rx=os.system(ss)

       ss=cfg['repo_types'][rshared]['add'].replace('$#path#$', pr).replace('$#files#$', pdd)
       rx=os.system(ss)

       os.chdir(ppp)

    # Prepare output
    rr={'return':0,
        'dict': a,
        'info': info,
        'updates': updates, 
        'path':p2,
        'path_module': pm,
        'path_repo': pr,
        'repo_uoa':ruoa,
        'repo_uid':ruid,
        'repo_alias':ralias,
        'module_uoa':muoa,
        'module_uid':muid,
        'module_alias':malias,
        'data_uoa':pdd,
        'data_uid':duid,
        'data_alias':dalias,
        'data_name':dn}

    # Check if need to add index
    if cfg.get('use_indexing','')=='yes':
       muid=rr['module_uid']
       duid=rr['data_uid']
       path='/'+muid+'/'+duid+'/1'
       ri=access_index_server({'request':'DELETE', 'path':path})
       if ri['return']>0: return ri
       ri=access_index_server({'request':'PUT', 'path':path, 'dict':rr})
       if ri['return']>0: return ri

    # Remove lock after update if needed
    if uuid!='':
       pl=os.path.join(p2, cfg['subdir_ck_ext'], cfg['file_for_lock'])
       if os.path.isfile(pl): os.remove(pl)

    rr['return']=0

    return rr",python,"def add(i):
    """"""
    Input:  {
              (repo_uoa)             - repo UOA
              module_uoa             - module UOA
              data_uoa               - data UOA
              (data_uid)             - data UID (if uoa is an alias)
              (data_name)            - user friendly data name

              (dict_from_cid)        -
              (dict_from_repo_uoa)   - 
              (dict_from_module_uoa) - 
              (dict_from_data_uoa)   - if present, pre-load dict 
                                       from this (module_uoa):data_uoa (analog of copy)

              (update)               - if == 'yes' and entry exists, update it

              (dict)                 - meta description to record
              (substitute)           - if 'yes' and update=='yes' substitute dictionaries, otherwise merge!

              (desc)                 - description of an entry (gradually adding API description in flat format)

              (extra_json_files)     - dict with extra json files to save to entry (key is a filename)

              (tags)                 - list or comma separated list of tags to add to entry

              (info)                 - entry info to record - normally, should not use it!
              (extra_info)           - enforce extra info such as
                                          author
                                          author_email
                                          author_webpage
                                          license
                                          copyright
                                       If not specified then taken from kernel (prefix 'default_')

              (updates)              - entry updates info to record - normally, should not use it!
              (ignore_update)        - if 'yes', do not add info about update

              (ask)                  - if 'yes', ask questions, otherwise silent

              (unlock_uid)           - unlock UID if was previously locked

              (sort_keys)            - by default, 'yes'

              (share)                - if 'yes', try to add via GIT
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if entry already exists
                                         >  0, if error
              (error)      - error text if return > 0

              Output from the 'create_entry' function
            }

    """"""

    o=i.get('out','')

    t='added'

    ra=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    d=i.get('data_uoa','')
    di=i.get('data_uid','')
    dn=i.get('data_name','')

    uuid=i.get('unlock_uid','')

    up=i.get('update','')

    ask=i.get('ask','')

    # Get repo path
    r=find_path_to_repo({'repo_uoa':ra})
    if r['return']>0: return r
    pr=r['path']

    ruoa=r['repo_uoa']
    ruid=r['repo_uid']
    ralias=r['repo_alias']

    rd=r['dict']
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    if i.get('share','')=='yes': rsync='yes'

    # Check if writing is allowed
    ii={'module_uoa':m, 'repo_uoa':r['repo_uoa'], 'repo_uid':r['repo_uid'], 'repo_dict':rd}
    r=check_writing(ii)
    if r['return']>0: return r

    # Load info about module
    r=load({'module_uoa':cfg['module_name'],
            'data_uoa':m})
    if r['return']>0: return r
    elif r['return']==16: 
       return {'return':8, 'error':'can\'t find path to module ""'+m+'""'}
    muoa=r['data_uoa']
    muid=r['data_uid']
    malias=r['data_alias']
    pm=r['path']

    uid=r['data_uid']
    alias=r['data_alias']
    if alias=='': alias=uid
    module_desc=r['dict']

    # Ask additional questions
    if o=='con' and ask=='yes':
       # Asking for alias
       if d=='' or is_uid(d):
          r=inp({'text':'Enter an alias (or Enter to skip it): '})
          d=r['string']

       # Asking for user-friendly name
       if dn=='' and up!='yes':
          r=inp({'text':'Enter a user-friendly name of this entry (or Enter to reuse alias): '})
          dn=r['string']

    # Load dictionary from other entry if needed
    dfcid=i.get('dict_from_cid','')
    dfruoa=i.get('dict_from_repo_uoa','')
    dfmuoa=i.get('dict_from_module_uoa','')
    dfduoa=i.get('dict_from_data_uoa','')

    if dfcid!='':
       r=parse_cid({'cid':dfcid})
       if r['return']>0: return r
       dfruoa=r.get('repo_uoa','')
       dfmuoa=r.get('module_uoa','')
       dfduoa=r.get('data_uoa','')

    if d!='' and not is_uoa(d):
       return {'return':1, 'error':'alias has disallowed characters'}

    if dfduoa!='':
       if dfmuoa=='': dfmuoa=m

       ii={'module_uoa':dfmuoa, 'data_uoa':dfduoa}
       if dfruoa!='': ii['repo_uoa']=dfruoa

       r=load(ii)
       if r['return']>0: return r

       df=r.get('dict',{})

    # Create first level entry (module) 
    r=create_entry({'path':pr, 'data_uoa':alias, 'data_uid':uid})
    if r['return']>0 and r['return']!=16: return r
    p1=r['path']

    # Create second level entry (data)
    i1={'path':p1}
    pdd=''
    if di!='': 
       i1['data_uid']=di
    if d!='': 
       i1['data_uoa']=d
    rr=create_entry(i1)
    if rr['return']>0 and rr['return']!=16: return rr

    duid=rr['data_uid']
    pdd=rr['data_uoa']
    dalias=rr['data_alias']

    # Preparing meta-description
    a={}
    info={}
    updates={}
    desc={}

    p2=rr['path']
    p3=os.path.join(p2, cfg['subdir_ck_ext'])
    p4=os.path.join(p3, cfg['file_meta'])
    p4i=os.path.join(p3, cfg['file_info'])
    p4u=os.path.join(p3, cfg['file_updates'])
    p4d=os.path.join(p3, cfg['file_desc'])

    # If last entry exists
    if rr['return']==16:
       if up=='yes':
          t='updated'

          # Check if locked
          rl=check_lock({'path':p2, 'unlock_uid':uuid})
          if rl['return']>0: 
             if rl['return']==32:
                rl['data_uoa']=pdd
                rl['data_uid']=duid
             return rl

          # Entry exists, load configuration if update
          r2=load_meta_from_path({'path':p2})
          if r2['return']>0: return r2
          a=r2['dict']
          info=r2.get('info',{})
          updates=r2.get('updates',{})
          desc=r2.get('desc',{})

          if dn=='': dn=info.get('data_name','')
       else:
          return {'return':16,'error':'entry already exists in path ('+p2+')'}
    else:
       # Create configuration directory
       if not os.path.isdir(p3):
          try:
             os.mkdir(p3)
          except Exception as e:
             return {'return':1, 'error':format(e)}

    if dn=='' and not is_uid(d):
       dn=d

    if dfduoa!='':
       r=merge_dicts({'dict1':a, 'dict2':df})
       if r['return']>0: return r

    # If dict, info and updates are in input, try to merge ...
    cma=i.get('dict',{})
    cmad=i.get('desc',{})
    if i.get('substitute','')=='yes':
       a=cma
       desc=cmad
    else:
       r=merge_dicts({'dict1':a, 'dict2':cma})
       if r['return']>0: return r
       r=merge_dicts({'dict1':desc, 'dict2':cmad})
       if r['return']>0: return r

    # Check tags 
    xtags=a.get('tags',[])

    tags=i.get('tags','')
    if tags=='': tags=[]
    elif type(tags)!=list:
       tags=tags.split(',')

    for l in range(0,len(tags)):
        ll=tags[l].strip()
        if ll not in xtags:
           xtags.append(ll)

    if len(xtags)>0:
       a['tags']=xtags

    # Process info
    cminfo=i.get('info',{})
    if len(cminfo)!=0:
       info=cminfo
#       r=merge_dicts({'dict1':info, 'dict2':cminfo})
#       if r['return']>0: return r

    cmupdates=i.get('updates',{})
    if len(cmupdates)!=0:
       updates=cmupdates
#       r=merge_dicts({'dict1':updates, 'dict2':cmupdates})
#       if r['return']>0: return r

    # If name exists, add
    info['backup_module_uoa']=muoa
    info['backup_module_uid']=muid
    info['backup_data_uid']=duid
    if dn!='': info['data_name']=dn

    # Add control info
    ri=prepare_special_info_about_entry({})
    if ri['return']>0: return ri
    x=ri['dict']

    # Check if pre-set control params such as author, copyright, license
    ei=i.get('extra_info',{})
    if len(ei)!=0: x.update(ei)

    y=info.get('control',{})

    if i.get('ignore_update','')!='yes':
       if len(y)==0:
          info['control']=x
       else:
          y=updates.get('control',[])
          y.append(x)
          updates['control']=y

    sk=i.get('sort_keys','')
    if sk=='': sk='yes'

    if len(updates)>0:
       # Record updates
       rx=save_json_to_file({'json_file':p4u, 'dict':updates, 'sort_keys':sk})
       if rx['return']>0: return rx

    # Record meta description
    rx=save_json_to_file({'json_file':p4, 'dict':a, 'sort_keys':sk})
    if rx['return']>0: return rx

    # Record info
    rx=save_json_to_file({'json_file':p4i, 'dict':info, 'sort_keys':sk})
    if rx['return']>0: return rx

    # Record desc
    rx=save_json_to_file({'json_file':p4d, 'dict':desc, 'sort_keys':sk})
    if rx['return']>0: return rx

    # Record extra files if there
    ejf=i.get('extra_json_files',{})
    if len(ejf)>0:
       for ff in ejf:
           dff=ejf[ff]
           rz=save_json_to_file({'json_file':os.path.join(p2,ff), 'dict':dff, 'sort_keys':sk})
           if rz['return']>0: return rz

    if o=='con':
       out('Entry '+d+' ('+duid+', '+p2+') '+t+' successfully!')

    # Check if needs to be synced
    if rshared!='' and rsync=='yes':
       ppp=os.getcwd()

       os.chdir(pr)
       if os.path.isdir(cfg['subdir_ck_ext']):
          ss=cfg['repo_types'][rshared]['add'].replace('$#path#$', pr).replace('$#files#$', cfg['subdir_ck_ext'])
          rx=os.system(ss)

       os.chdir(p1)
       if os.path.isdir(cfg['subdir_ck_ext']):
          ss=cfg['repo_types'][rshared]['add'].replace('$#path#$', pr).replace('$#files#$', cfg['subdir_ck_ext'])
          rx=os.system(ss)

       ss=cfg['repo_types'][rshared]['add'].replace('$#path#$', pr).replace('$#files#$', pdd)
       rx=os.system(ss)

       os.chdir(ppp)

    # Prepare output
    rr={'return':0,
        'dict': a,
        'info': info,
        'updates': updates, 
        'path':p2,
        'path_module': pm,
        'path_repo': pr,
        'repo_uoa':ruoa,
        'repo_uid':ruid,
        'repo_alias':ralias,
        'module_uoa':muoa,
        'module_uid':muid,
        'module_alias':malias,
        'data_uoa':pdd,
        'data_uid':duid,
        'data_alias':dalias,
        'data_name':dn}

    # Check if need to add index
    if cfg.get('use_indexing','')=='yes':
       muid=rr['module_uid']
       duid=rr['data_uid']
       path='/'+muid+'/'+duid+'/1'
       ri=access_index_server({'request':'DELETE', 'path':path})
       if ri['return']>0: return ri
       ri=access_index_server({'request':'PUT', 'path':path, 'dict':rr})
       if ri['return']>0: return ri

    # Remove lock after update if needed
    if uuid!='':
       pl=os.path.join(p2, cfg['subdir_ck_ext'], cfg['file_for_lock'])
       if os.path.isfile(pl): os.remove(pl)

    rr['return']=0

    return rr",['def' 'add' '(' ... '0' 'return' 'rr'],"Input:  {
              (repo_uoa)             - repo UOA
              module_uoa             - module UOA
              data_uoa               - data UOA
              (data_uid)             - data UID (if uoa is an alias)
              (data_name)            - user friendly data name

              (dict_from_cid)        -
              (dict_from_repo_uoa)   - 
              (dict_from_module_uoa) - 
              (dict_from_data_uoa)   - if present, pre-load dict 
                                       from this (module_uoa):data_uoa (analog of copy)

              (update)               - if == 'yes' and entry exists, update it

              (dict)                 - meta description to record
              (substitute)           - if 'yes' and update=='yes' substitute dictionaries, otherwise merge!

              (desc)                 - description of an entry (gradually adding API description in flat format)

              (extra_json_files)     - dict with extra json files to save to entry (key is a filename)

              (tags)                 - list or comma separated list of tags to add to entry

              (info)                 - entry info to record - normally, should not use it!
              (extra_info)           - enforce extra info such as
                                          author
                                          author_email
                                          author_webpage
                                          license
                                          copyright
                                       If not specified then taken from kernel (prefix 'default_')

              (updates)              - entry updates info to record - normally, should not use it!
              (ignore_update)        - if 'yes', do not add info about update

              (ask)                  - if 'yes', ask questions, otherwise silent

              (unlock_uid)           - unlock UID if was previously locked

              (sort_keys)            - by default, 'yes'

              (share)                - if 'yes', try to add via GIT
            }

    Output: {
              return       - return code =  0, if successful
                                           16, if entry already exists
                                         >  0, if error
              (error)      - error text if return > 0

              Output from the 'create_entry' function
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA' '(' 'data_uid' ')' '-' 'data'
 'UID' '(' 'if' 'uoa' 'is' 'an' 'alias' ')' '(' 'data_name' ')' '-' 'user'
 'friendly' 'data' 'name']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L5721-L6093
ctuning/ck,ck/kernel.py,update,"def update(i):
    """"""
    Input:  {
              (repo_uoa)             - repo UOA
              module_uoa             - module UOA
              data_uoa               - data UOA
              (data_uid)             - data UID (if uoa is an alias)
              (data_name)            - user friendly data name

              (dict_from_cid)        -
              (dict_from_repo_uoa)   - 
              (dict_from_module_uoa) - 
              (dict_from_data_uoa)   - if present, pre-load dict 
                                       from this (module_uoa):data_uoa (analog of copy)

              (dict)                 - meta description to record
              (substitute)           - if 'yes', substitute dictionaries, otherwise merge!

              (tags)                 - list or comma separated list of tags to add to entry

              (info)                 - entry info to record - normally, should not use it!
              (updates)              - entry updates info to record - normally, should not use it!
              (ignore_update)        - if 'yes', do not add info about update

              (ask)                  - if 'yes', ask questions, otherwise silent

              (unlock_uid)           - unlock UID if was previously locked

              (sort_keys)            - if 'yes', sort keys
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output from the 'add' function (the last one in case of wildcards)
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    # Try to load entry, if doesn't exist, add entry
    dd={}

    o=i.get('out','')
    i['out']=''

    # Check wildcards
    lst=[]

    a=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if duoa=='': duoa='*'

    single_not_found=False # If no wild cards and entry not found, then add

    if a.find('*')>=0 or a.find('?')>=0 or m.find('*')>=0 or m.find('?')>=0 or duoa.find('*')>=0 or duoa.find('?')>=0: 
       r=list_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
       if r['return']>0: return r

       lst=r['lst']
    else:
       # Find path to data
       r=find_path_to_data(i)
       if r['return']>0: 
          single_not_found=True
       else:
          p=r['path']
          ruoa=r.get('repo_uoa','')
          ruid=r.get('repo_uid','')
          muoa=r.get('module_uoa','')
          muid=r.get('module_uid','')
          duid=r.get('data_uid','')
          duoa=r.get('data_alias','')
          if duoa=='': duoa=duid

          lst.append({'path':p, 'repo_uoa':ruoa, 'repo_uid':ruid, 
                                'module_uoa':muoa, 'module_uid':muid, 
                                'data_uoa':duoa, 'data_uid': duid})

    # Update entries
    i['out']=o

    r={'return':0}
    if single_not_found:
       r=add(i)
    else:
       i['update']='yes'

       for q in lst:
           ii={}
           ii.update(i)
           ii.update(q)
           r=add(ii)
           if r['return']>0: return r

    return r",python,"def update(i):
    """"""
    Input:  {
              (repo_uoa)             - repo UOA
              module_uoa             - module UOA
              data_uoa               - data UOA
              (data_uid)             - data UID (if uoa is an alias)
              (data_name)            - user friendly data name

              (dict_from_cid)        -
              (dict_from_repo_uoa)   - 
              (dict_from_module_uoa) - 
              (dict_from_data_uoa)   - if present, pre-load dict 
                                       from this (module_uoa):data_uoa (analog of copy)

              (dict)                 - meta description to record
              (substitute)           - if 'yes', substitute dictionaries, otherwise merge!

              (tags)                 - list or comma separated list of tags to add to entry

              (info)                 - entry info to record - normally, should not use it!
              (updates)              - entry updates info to record - normally, should not use it!
              (ignore_update)        - if 'yes', do not add info about update

              (ask)                  - if 'yes', ask questions, otherwise silent

              (unlock_uid)           - unlock UID if was previously locked

              (sort_keys)            - if 'yes', sort keys
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output from the 'add' function (the last one in case of wildcards)
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    # Try to load entry, if doesn't exist, add entry
    dd={}

    o=i.get('out','')
    i['out']=''

    # Check wildcards
    lst=[]

    a=i.get('repo_uoa','')
    m=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if duoa=='': duoa='*'

    single_not_found=False # If no wild cards and entry not found, then add

    if a.find('*')>=0 or a.find('?')>=0 or m.find('*')>=0 or m.find('?')>=0 or duoa.find('*')>=0 or duoa.find('?')>=0: 
       r=list_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
       if r['return']>0: return r

       lst=r['lst']
    else:
       # Find path to data
       r=find_path_to_data(i)
       if r['return']>0: 
          single_not_found=True
       else:
          p=r['path']
          ruoa=r.get('repo_uoa','')
          ruid=r.get('repo_uid','')
          muoa=r.get('module_uoa','')
          muid=r.get('module_uid','')
          duid=r.get('data_uid','')
          duoa=r.get('data_alias','')
          if duoa=='': duoa=duid

          lst.append({'path':p, 'repo_uoa':ruoa, 'repo_uid':ruid, 
                                'module_uoa':muoa, 'module_uid':muid, 
                                'data_uoa':duoa, 'data_uid': duid})

    # Update entries
    i['out']=o

    r={'return':0}
    if single_not_found:
       r=add(i)
    else:
       i['update']='yes'

       for q in lst:
           ii={}
           ii.update(i)
           ii.update(q)
           r=add(ii)
           if r['return']>0: return r

    return r","['def' 'update' '(' 'i' ')' ':' '# Check if global writing is allowed' 'r'
 '=' 'check_writing' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' ""# Try to load entry, if doesn't exist, add entry"" 'dd'
 '=' '{' '}' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')' 'i' '['
 ""'out'"" ']' '=' ""''"" '# Check wildcards' 'lst' '=' '[' ']' 'a' '=' 'i'
 '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'm' '=' 'i' '.' 'get' '('
 ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ','
 ""''"" ')' 'if' 'duoa' '==' ""''"" ':' 'duoa' '=' ""'*'"" 'single_not_found'
 '=' 'False' '# If no wild cards and entry not found, then add' 'if' 'a'
 '.' 'find' '(' ""'*'"" ')' '>=' '0' 'or' 'a' '.' 'find' '(' ""'?'"" ')' '>='
 '0' 'or' 'm' '.' 'find' '(' ""'*'"" ')' '>=' '0' 'or' 'm' '.' 'find' '('
 ""'?'"" ')' '>=' '0' 'or' 'duoa' '.' 'find' '(' ""'*'"" ')' '>=' '0' 'or'
 'duoa' '.' 'find' '(' ""'?'"" ')' '>=' '0' ':' 'r' '=' 'list_data' '(' '{'
 ""'repo_uoa'"" ':' 'a' ',' ""'module_uoa'"" ':' 'm' ',' ""'data_uoa'"" ':'
 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'lst'
 '=' 'r' '[' ""'lst'"" ']' 'else' ':' '# Find path to data' 'r' '='
 'find_path_to_data' '(' 'i' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'single_not_found' '=' 'True' 'else' ':' 'p' '=' 'r' '[' ""'path'"" ']'
 'ruoa' '=' 'r' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'ruid' '=' 'r' '.'
 'get' '(' ""'repo_uid'"" ',' ""''"" ')' 'muoa' '=' 'r' '.' 'get' '('
 ""'module_uoa'"" ',' ""''"" ')' 'muid' '=' 'r' '.' 'get' '(' ""'module_uid'""
 ',' ""''"" ')' 'duid' '=' 'r' '.' 'get' '(' ""'data_uid'"" ',' ""''"" ')'
 'duoa' '=' 'r' '.' 'get' '(' ""'data_alias'"" ',' ""''"" ')' 'if' 'duoa' '=='
 ""''"" ':' 'duoa' '=' 'duid' 'lst' '.' 'append' '(' '{' ""'path'"" ':' 'p'
 ',' ""'repo_uoa'"" ':' 'ruoa' ',' ""'repo_uid'"" ':' 'ruid' ','
 ""'module_uoa'"" ':' 'muoa' ',' ""'module_uid'"" ':' 'muid' ',' ""'data_uoa'""
 ':' 'duoa' ',' ""'data_uid'"" ':' 'duid' '}' ')' '# Update entries' 'i' '['
 ""'out'"" ']' '=' 'o' 'r' '=' '{' ""'return'"" ':' '0' '}' 'if'
 'single_not_found' ':' 'r' '=' 'add' '(' 'i' ')' 'else' ':' 'i' '['
 ""'update'"" ']' '=' ""'yes'"" 'for' 'q' 'in' 'lst' ':' 'ii' '=' '{' '}' 'ii'
 '.' 'update' '(' 'i' ')' 'ii' '.' 'update' '(' 'q' ')' 'r' '=' 'add' '('
 'ii' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'return'
 'r']","Input:  {
              (repo_uoa)             - repo UOA
              module_uoa             - module UOA
              data_uoa               - data UOA
              (data_uid)             - data UID (if uoa is an alias)
              (data_name)            - user friendly data name

              (dict_from_cid)        -
              (dict_from_repo_uoa)   - 
              (dict_from_module_uoa) - 
              (dict_from_data_uoa)   - if present, pre-load dict 
                                       from this (module_uoa):data_uoa (analog of copy)

              (dict)                 - meta description to record
              (substitute)           - if 'yes', substitute dictionaries, otherwise merge!

              (tags)                 - list or comma separated list of tags to add to entry

              (info)                 - entry info to record - normally, should not use it!
              (updates)              - entry updates info to record - normally, should not use it!
              (ignore_update)        - if 'yes', do not add info about update

              (ask)                  - if 'yes', ask questions, otherwise silent

              (unlock_uid)           - unlock UID if was previously locked

              (sort_keys)            - if 'yes', sort keys
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output from the 'add' function (the last one in case of wildcards)
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA' '(' 'data_uid' ')' '-' 'data'
 'UID' '(' 'if' 'uoa' 'is' 'an' 'alias' ')' '(' 'data_name' ')' '-' 'user'
 'friendly' 'data' 'name']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L6100-L6202
ctuning/ck,ck/kernel.py,edit,"def edit(i): # pragma: no cover
    """"""
    Input:  {
              (repo_uoa)             - repo UOA
              module_uoa             - module UOA
              data_uoa               - data UOA

              (ignore_update)        - (default==yes) if 'yes', do not add info about update
              (sort_keys)            - (default==yes) if 'yes', sort keys

              (edit_desc)            - if 'yes', edit description rather than meta 
                                       (useful for compiler descriptions)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    iu=i.get('ignore_update','')
    if iu=='': iu='yes'

    ed=i.get('edit_desc','')

    sk=i.get('sort_keys','')
    if sk=='': sk='yes'

    ii={'action':'load',
        'repo_uoa':ruoa,
        'module_uoa':muoa,
        'data_uoa':duoa,
        'common_func':'yes'}
    r=access(ii)
    if r['return']>0: return r

    desc=r.get('desc',{})
    meta=r['dict']

    # Record to tmp file
    import tempfile
    fd, fn=tempfile.mkstemp(suffix='.tmp', prefix='ck-') # suffix is important - CK will delete such file!
    os.close(fd)
    os.remove(fn)

    if ed=='yes': dd=desc
    else:         dd=meta

    r=save_json_to_file({'json_file':fn, 'dict':dd, 'sort_keys':sk})
    if r['return']>0: return r

    # Get OS
    r=get_os_ck({})
    if r['return']>0: return r
    plat=r['platform']

    x=cfg['external_editor'][plat].replace('$#filename#$', fn)

    os.system(x)

    # Load file
    r=load_json_file({'json_file':fn})
    if r['return']>0: return r

    if ed=='yes': desc=r['dict']
    else:         meta=r['dict']

    # Update entry to finish sync/indexing
    ii={'action':'update',
        'repo_uoa':ruoa,
        'module_uoa':muoa,
        'data_uoa':duoa,
        'common_func':'yes',
        'ignore_update':iu,
        'dict':meta,
        'desc':desc,
        'substitute':'yes',
        'sort_keys':sk,
        'out':o}
    r=access(ii)

    # Delete tmp file
    if os.path.isfile(fn): 
       os.remove(fn)

    return r",python,"def edit(i): # pragma: no cover
    """"""
    Input:  {
              (repo_uoa)             - repo UOA
              module_uoa             - module UOA
              data_uoa               - data UOA

              (ignore_update)        - (default==yes) if 'yes', do not add info about update
              (sort_keys)            - (default==yes) if 'yes', sort keys

              (edit_desc)            - if 'yes', edit description rather than meta 
                                       (useful for compiler descriptions)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    iu=i.get('ignore_update','')
    if iu=='': iu='yes'

    ed=i.get('edit_desc','')

    sk=i.get('sort_keys','')
    if sk=='': sk='yes'

    ii={'action':'load',
        'repo_uoa':ruoa,
        'module_uoa':muoa,
        'data_uoa':duoa,
        'common_func':'yes'}
    r=access(ii)
    if r['return']>0: return r

    desc=r.get('desc',{})
    meta=r['dict']

    # Record to tmp file
    import tempfile
    fd, fn=tempfile.mkstemp(suffix='.tmp', prefix='ck-') # suffix is important - CK will delete such file!
    os.close(fd)
    os.remove(fn)

    if ed=='yes': dd=desc
    else:         dd=meta

    r=save_json_to_file({'json_file':fn, 'dict':dd, 'sort_keys':sk})
    if r['return']>0: return r

    # Get OS
    r=get_os_ck({})
    if r['return']>0: return r
    plat=r['platform']

    x=cfg['external_editor'][plat].replace('$#filename#$', fn)

    os.system(x)

    # Load file
    r=load_json_file({'json_file':fn})
    if r['return']>0: return r

    if ed=='yes': desc=r['dict']
    else:         meta=r['dict']

    # Update entry to finish sync/indexing
    ii={'action':'update',
        'repo_uoa':ruoa,
        'module_uoa':muoa,
        'data_uoa':duoa,
        'common_func':'yes',
        'ignore_update':iu,
        'dict':meta,
        'desc':desc,
        'substitute':'yes',
        'sort_keys':sk,
        'out':o}
    r=access(ii)

    # Delete tmp file
    if os.path.isfile(fn): 
       os.remove(fn)

    return r","['def' 'edit' '(' 'i' ')' ':' '# pragma: no cover' 'o' '=' 'i' '.' 'get'
 '(' ""'out'"" ',' ""''"" ')' 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ','
 ""''"" ')' 'muoa' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa'
 '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'iu' '=' 'i' '.' 'get'
 '(' ""'ignore_update'"" ',' ""''"" ')' 'if' 'iu' '==' ""''"" ':' 'iu' '='
 ""'yes'"" 'ed' '=' 'i' '.' 'get' '(' ""'edit_desc'"" ',' ""''"" ')' 'sk' '='
 'i' '.' 'get' '(' ""'sort_keys'"" ',' ""''"" ')' 'if' 'sk' '==' ""''"" ':' 'sk'
 '=' ""'yes'"" 'ii' '=' '{' ""'action'"" ':' ""'load'"" ',' ""'repo_uoa'"" ':'
 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ',' ""'data_uoa'"" ':' 'duoa' ','
 ""'common_func'"" ':' ""'yes'"" '}' 'r' '=' 'access' '(' 'ii' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'desc' '=' 'r' '.' 'get' '('
 ""'desc'"" ',' '{' '}' ')' 'meta' '=' 'r' '[' ""'dict'"" ']'
 '# Record to tmp file' 'import' 'tempfile' 'fd' ',' 'fn' '=' 'tempfile'
 '.' 'mkstemp' '(' 'suffix' '=' ""'.tmp'"" ',' 'prefix' '=' ""'ck-'"" ')'
 '# suffix is important - CK will delete such file!' 'os' '.' 'close' '('
 'fd' ')' 'os' '.' 'remove' '(' 'fn' ')' 'if' 'ed' '==' ""'yes'"" ':' 'dd'
 '=' 'desc' 'else' ':' 'dd' '=' 'meta' 'r' '=' 'save_json_to_file' '(' '{'
 ""'json_file'"" ':' 'fn' ',' ""'dict'"" ':' 'dd' ',' ""'sort_keys'"" ':' 'sk'
 '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' '# Get OS'
 'r' '=' 'get_os_ck' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' 'plat' '=' 'r' '[' ""'platform'"" ']' 'x' '=' 'cfg' '['
 ""'external_editor'"" ']' '[' 'plat' ']' '.' 'replace' '(' ""'$#filename#$'""
 ',' 'fn' ')' 'os' '.' 'system' '(' 'x' ')' '# Load file' 'r' '='
 'load_json_file' '(' '{' ""'json_file'"" ':' 'fn' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'if' 'ed' '==' ""'yes'"" ':' 'desc'
 '=' 'r' '[' ""'dict'"" ']' 'else' ':' 'meta' '=' 'r' '[' ""'dict'"" ']'
 '# Update entry to finish sync/indexing' 'ii' '=' '{' ""'action'"" ':'
 ""'update'"" ',' ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ','
 ""'data_uoa'"" ':' 'duoa' ',' ""'common_func'"" ':' ""'yes'"" ','
 ""'ignore_update'"" ':' 'iu' ',' ""'dict'"" ':' 'meta' ',' ""'desc'"" ':'
 'desc' ',' ""'substitute'"" ':' ""'yes'"" ',' ""'sort_keys'"" ':' 'sk' ','
 ""'out'"" ':' 'o' '}' 'r' '=' 'access' '(' 'ii' ')' '# Delete tmp file'
 'if' 'os' '.' 'path' '.' 'isfile' '(' 'fn' ')' ':' 'os' '.' 'remove' '('
 'fn' ')' 'return' 'r']","Input:  {
              (repo_uoa)             - repo UOA
              module_uoa             - module UOA
              data_uoa               - data UOA

              (ignore_update)        - (default==yes) if 'yes', do not add info about update
              (sort_keys)            - (default==yes) if 'yes', sort keys

              (edit_desc)            - if 'yes', edit description rather than meta 
                                       (useful for compiler descriptions)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L6209-L6302
ctuning/ck,ck/kernel.py,rm,"def rm(i):
    """"""
    Input:  {
              (repo_uoa)      - repo UOA    ; can be wild cards
              module_uoa      - module UOA  ; can be wild cards
              data_uoa        - data UOA    ; can be wild cards

              (force)         - if 'yes', force deleting without questions
                 or
              (f)             - to be compatible with rm -f 

              (share)         - if 'yes', try to remove via GIT

              (tags)          - use these tags in format tags=x,y,z to prune rm
                   or
              (search_string) - prune entries with expression *?
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    a=i.get('repo_uoa','')

    # Check if global writing is allowed
    r=check_writing({'repo_uoa':a, 'delete':'yes'})
    if r['return']>0: return r

    o=i.get('out','')

    m=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if duoa=='':
       return {'return':1, 'error':'data UOA is not defined'}

    lst=[]

    tags=i.get('tags','')
    ss=i.get('search_string','')

    # Check wildcards
    if a.find('*')>=0 or a.find('?')>=0 or m.find('*')>=0 or m.find('?')>=0 or duoa.find('*')>=0 or duoa.find('?')>=0: 
       if tags=='' and ss=='':
          r=list_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
          if r['return']>0: return r
       else:
          r=search({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa, 'tags':tags, 'search_string':ss})
          if r['return']>0: return r

       lst=r['lst']
    else:
       # Find path to data
       r=find_path_to_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
       if r['return']>0: return r
       p=r['path']
       ruoa=r.get('repo_uoa','')
       ruid=r.get('repo_uid','')
       muoa=r.get('module_uoa','')
       muid=r.get('module_uid','')
       duid=r.get('data_uid','')
       duoa=r.get('data_alias','')
       if duoa=='': duoa=duid

       lst.append({'path':p, 'repo_uoa':ruoa, 'repo_uid':ruid, 
                             'module_uoa':muoa, 'module_uid':muid, 
                             'data_uoa':duoa, 'data_uid': duid})

    force=i.get('force','')
    if force=='':
       force=i.get('f','')

    first=True
    for ll in lst:
        p=ll['path']
        pm=os.path.split(p)[0]

        muid=ll['module_uid']
        muoa=ll['module_uoa']
        duid=ll['data_uid']
        duoa=ll['data_uoa']

        if duoa!=duid: dalias=duoa
        else: dalias=''

        # Get user-friendly CID
        x=muoa+':'+duoa
        if o=='con':
           # Try to check if has data name (useful for env)
           p2=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_info'])
           if os.path.isfile(p2):
              r2=load_json_file({'json_file':p2})
              if r2['return']==0:
                 x2=r2['dict'].get('data_name','')
                 if x2!='':
                    x='""'+x2+'""\n    '+x

        xcuoa=x+' ('+muid+':'+duid+')'

        # Check repo/module writing
        ii={'module_uoa':m, 'repo_uoa':ll['repo_uoa'], 'repo_uid':ll['repo_uid']}
        r=check_writing(ii)
        if r['return']>0: return r

        rd=r.get('repo_dict',{})
        rshared=rd.get('shared','')
        rsync=rd.get('sync','')

        shr=i.get('share','')
        if shr=='yes': 
           rshared='git'
           rsync='yes'

        # If interactive
        to_delete=True
        if o=='con' and force!='yes':
           r=inp({'text':'Are you sure to delete CK entry '+xcuoa+' ? (y/N): '})
           c=r['string'].lower()
           if c!='y' and c!='yes': to_delete=False

        # If deleting
        if to_delete:
           # First remove alias if exists
           if dalias!='':
              # Delete alias
              r=delete_alias({'path':pm, 'data_alias':dalias, 'data_uid':duid, 'repo_dict':rd, 'share':shr})
              if r['return']>0: return r

           if rshared!='':
              pp=os.path.split(p)
              pp0=pp[0]
              pp1=pp[1]

              ppp=os.getcwd()
              os.chdir(pp0)

              ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', pp1)
              rx=os.system(ss)

           # Delete directory
           r={'return':0}
           if os.path.isdir(p):
              r=delete_directory({'path':p})

           if rshared!='':
              os.chdir(ppp)

           if r['return']>0: return r

           # Check if need to delete index
           if cfg.get('use_indexing','')=='yes':
              path='/'+muid+'/'+duid+'/1'
              ri=access_index_server({'request':'DELETE', 'path':path})
              if ri['return']>0: return ri

           if o=='con':
              out('   Entry '+xcuoa+' was successfully deleted!')

    return {'return':0}",python,"def rm(i):
    """"""
    Input:  {
              (repo_uoa)      - repo UOA    ; can be wild cards
              module_uoa      - module UOA  ; can be wild cards
              data_uoa        - data UOA    ; can be wild cards

              (force)         - if 'yes', force deleting without questions
                 or
              (f)             - to be compatible with rm -f 

              (share)         - if 'yes', try to remove via GIT

              (tags)          - use these tags in format tags=x,y,z to prune rm
                   or
              (search_string) - prune entries with expression *?
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    a=i.get('repo_uoa','')

    # Check if global writing is allowed
    r=check_writing({'repo_uoa':a, 'delete':'yes'})
    if r['return']>0: return r

    o=i.get('out','')

    m=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if duoa=='':
       return {'return':1, 'error':'data UOA is not defined'}

    lst=[]

    tags=i.get('tags','')
    ss=i.get('search_string','')

    # Check wildcards
    if a.find('*')>=0 or a.find('?')>=0 or m.find('*')>=0 or m.find('?')>=0 or duoa.find('*')>=0 or duoa.find('?')>=0: 
       if tags=='' and ss=='':
          r=list_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
          if r['return']>0: return r
       else:
          r=search({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa, 'tags':tags, 'search_string':ss})
          if r['return']>0: return r

       lst=r['lst']
    else:
       # Find path to data
       r=find_path_to_data({'repo_uoa':a, 'module_uoa':m, 'data_uoa':duoa})
       if r['return']>0: return r
       p=r['path']
       ruoa=r.get('repo_uoa','')
       ruid=r.get('repo_uid','')
       muoa=r.get('module_uoa','')
       muid=r.get('module_uid','')
       duid=r.get('data_uid','')
       duoa=r.get('data_alias','')
       if duoa=='': duoa=duid

       lst.append({'path':p, 'repo_uoa':ruoa, 'repo_uid':ruid, 
                             'module_uoa':muoa, 'module_uid':muid, 
                             'data_uoa':duoa, 'data_uid': duid})

    force=i.get('force','')
    if force=='':
       force=i.get('f','')

    first=True
    for ll in lst:
        p=ll['path']
        pm=os.path.split(p)[0]

        muid=ll['module_uid']
        muoa=ll['module_uoa']
        duid=ll['data_uid']
        duoa=ll['data_uoa']

        if duoa!=duid: dalias=duoa
        else: dalias=''

        # Get user-friendly CID
        x=muoa+':'+duoa
        if o=='con':
           # Try to check if has data name (useful for env)
           p2=os.path.join(p, cfg['subdir_ck_ext'], cfg['file_info'])
           if os.path.isfile(p2):
              r2=load_json_file({'json_file':p2})
              if r2['return']==0:
                 x2=r2['dict'].get('data_name','')
                 if x2!='':
                    x='""'+x2+'""\n    '+x

        xcuoa=x+' ('+muid+':'+duid+')'

        # Check repo/module writing
        ii={'module_uoa':m, 'repo_uoa':ll['repo_uoa'], 'repo_uid':ll['repo_uid']}
        r=check_writing(ii)
        if r['return']>0: return r

        rd=r.get('repo_dict',{})
        rshared=rd.get('shared','')
        rsync=rd.get('sync','')

        shr=i.get('share','')
        if shr=='yes': 
           rshared='git'
           rsync='yes'

        # If interactive
        to_delete=True
        if o=='con' and force!='yes':
           r=inp({'text':'Are you sure to delete CK entry '+xcuoa+' ? (y/N): '})
           c=r['string'].lower()
           if c!='y' and c!='yes': to_delete=False

        # If deleting
        if to_delete:
           # First remove alias if exists
           if dalias!='':
              # Delete alias
              r=delete_alias({'path':pm, 'data_alias':dalias, 'data_uid':duid, 'repo_dict':rd, 'share':shr})
              if r['return']>0: return r

           if rshared!='':
              pp=os.path.split(p)
              pp0=pp[0]
              pp1=pp[1]

              ppp=os.getcwd()
              os.chdir(pp0)

              ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', pp1)
              rx=os.system(ss)

           # Delete directory
           r={'return':0}
           if os.path.isdir(p):
              r=delete_directory({'path':p})

           if rshared!='':
              os.chdir(ppp)

           if r['return']>0: return r

           # Check if need to delete index
           if cfg.get('use_indexing','')=='yes':
              path='/'+muid+'/'+duid+'/1'
              ri=access_index_server({'request':'DELETE', 'path':path})
              if ri['return']>0: return ri

           if o=='con':
              out('   Entry '+xcuoa+' was successfully deleted!')

    return {'return':0}","['def' 'rm' '(' 'i' ')' ':' 'a' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ','
 ""''"" ')' '# Check if global writing is allowed' 'r' '=' 'check_writing'
 '(' '{' ""'repo_uoa'"" ':' 'a' ',' ""'delete'"" ':' ""'yes'"" '}' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'o' '=' 'i' '.' 'get' '('
 ""'out'"" ',' ""''"" ')' 'm' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''""
 ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if' 'duoa'
 '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'data UOA is not defined'"" '}' 'lst' '=' '[' ']' 'tags' '=' 'i' '.'
 'get' '(' ""'tags'"" ',' ""''"" ')' 'ss' '=' 'i' '.' 'get' '('
 ""'search_string'"" ',' ""''"" ')' '# Check wildcards' 'if' 'a' '.' 'find'
 '(' ""'*'"" ')' '>=' '0' 'or' 'a' '.' 'find' '(' ""'?'"" ')' '>=' '0' 'or'
 'm' '.' 'find' '(' ""'*'"" ')' '>=' '0' 'or' 'm' '.' 'find' '(' ""'?'"" ')'
 '>=' '0' 'or' 'duoa' '.' 'find' '(' ""'*'"" ')' '>=' '0' 'or' 'duoa' '.'
 'find' '(' ""'?'"" ')' '>=' '0' ':' 'if' 'tags' '==' ""''"" 'and' 'ss' '=='
 ""''"" ':' 'r' '=' 'list_data' '(' '{' ""'repo_uoa'"" ':' 'a' ','
 ""'module_uoa'"" ':' 'm' ',' ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'else' ':' 'r' '=' 'search' '('
 '{' ""'repo_uoa'"" ':' 'a' ',' ""'module_uoa'"" ':' 'm' ',' ""'data_uoa'"" ':'
 'duoa' ',' ""'tags'"" ':' 'tags' ',' ""'search_string'"" ':' 'ss' '}' ')'
 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'lst' '=' 'r' '['
 ""'lst'"" ']' 'else' ':' '# Find path to data' 'r' '=' 'find_path_to_data'
 '(' '{' ""'repo_uoa'"" ':' 'a' ',' ""'module_uoa'"" ':' 'm' ',' ""'data_uoa'""
 ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r'
 'p' '=' 'r' '[' ""'path'"" ']' 'ruoa' '=' 'r' '.' 'get' '(' ""'repo_uoa'""
 ',' ""''"" ')' 'ruid' '=' 'r' '.' 'get' '(' ""'repo_uid'"" ',' ""''"" ')'
 'muoa' '=' 'r' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'muid' '=' 'r'
 '.' 'get' '(' ""'module_uid'"" ',' ""''"" ')' 'duid' '=' 'r' '.' 'get' '('
 ""'data_uid'"" ',' ""''"" ')' 'duoa' '=' 'r' '.' 'get' '(' ""'data_alias'"" ','
 ""''"" ')' 'if' 'duoa' '==' ""''"" ':' 'duoa' '=' 'duid' 'lst' '.' 'append'
 '(' '{' ""'path'"" ':' 'p' ',' ""'repo_uoa'"" ':' 'ruoa' ',' ""'repo_uid'"" ':'
 'ruid' ',' ""'module_uoa'"" ':' 'muoa' ',' ""'module_uid'"" ':' 'muid' ','
 ""'data_uoa'"" ':' 'duoa' ',' ""'data_uid'"" ':' 'duid' '}' ')' 'force' '='
 'i' '.' 'get' '(' ""'force'"" ',' ""''"" ')' 'if' 'force' '==' ""''"" ':'
 'force' '=' 'i' '.' 'get' '(' ""'f'"" ',' ""''"" ')' 'first' '=' 'True' 'for'
 'll' 'in' 'lst' ':' 'p' '=' 'll' '[' ""'path'"" ']' 'pm' '=' 'os' '.'
 'path' '.' 'split' '(' 'p' ')' '[' '0' ']' 'muid' '=' 'll' '['
 ""'module_uid'"" ']' 'muoa' '=' 'll' '[' ""'module_uoa'"" ']' 'duid' '=' 'll'
 '[' ""'data_uid'"" ']' 'duoa' '=' 'll' '[' ""'data_uoa'"" ']' 'if' 'duoa'
 '!=' 'duid' ':' 'dalias' '=' 'duoa' 'else' ':' 'dalias' '=' ""''""
 '# Get user-friendly CID' 'x' '=' 'muoa' '+' ""':'"" '+' 'duoa' 'if' 'o'
 '==' ""'con'"" ':' '# Try to check if has data name (useful for env)' 'p2'
 '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'""
 ']' ',' 'cfg' '[' ""'file_info'"" ']' ')' 'if' 'os' '.' 'path' '.' 'isfile'
 '(' 'p2' ')' ':' 'r2' '=' 'load_json_file' '(' '{' ""'json_file'"" ':' 'p2'
 '}' ')' 'if' 'r2' '[' ""'return'"" ']' '==' '0' ':' 'x2' '=' 'r2' '['
 ""'dict'"" ']' '.' 'get' '(' ""'data_name'"" ',' ""''"" ')' 'if' 'x2' '!=' ""''""
 ':' 'x' '=' '\'""\'' '+' 'x2' '+' '\'""\\n    \'' '+' 'x' 'xcuoa' '=' 'x'
 '+' ""' ('"" '+' 'muid' '+' ""':'"" '+' 'duid' '+' ""')'""
 '# Check repo/module writing' 'ii' '=' '{' ""'module_uoa'"" ':' 'm' ','
 ""'repo_uoa'"" ':' 'll' '[' ""'repo_uoa'"" ']' ',' ""'repo_uid'"" ':' 'll' '['
 ""'repo_uid'"" ']' '}' 'r' '=' 'check_writing' '(' 'ii' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'rd' '=' 'r' '.' 'get' '('
 ""'repo_dict'"" ',' '{' '}' ')' 'rshared' '=' 'rd' '.' 'get' '(' ""'shared'""
 ',' ""''"" ')' 'rsync' '=' 'rd' '.' 'get' '(' ""'sync'"" ',' ""''"" ')' 'shr'
 '=' 'i' '.' 'get' '(' ""'share'"" ',' ""''"" ')' 'if' 'shr' '==' ""'yes'"" ':'
 'rshared' '=' ""'git'"" 'rsync' '=' ""'yes'"" '# If interactive' 'to_delete'
 '=' 'True' 'if' 'o' '==' ""'con'"" 'and' 'force' '!=' ""'yes'"" ':' 'r' '='
 'inp' '(' '{' ""'text'"" ':' ""'Are you sure to delete CK entry '"" '+'
 'xcuoa' '+' ""' ? (y/N): '"" '}' ')' 'c' '=' 'r' '[' ""'string'"" ']' '.'
 'lower' '(' ')' 'if' 'c' '!=' ""'y'"" 'and' 'c' '!=' ""'yes'"" ':'
 'to_delete' '=' 'False' '# If deleting' 'if' 'to_delete' ':'
 '# First remove alias if exists' 'if' 'dalias' '!=' ""''"" ':'
 '# Delete alias' 'r' '=' 'delete_alias' '(' '{' ""'path'"" ':' 'pm' ','
 ""'data_alias'"" ':' 'dalias' ',' ""'data_uid'"" ':' 'duid' ',' ""'repo_dict'""
 ':' 'rd' ',' ""'share'"" ':' 'shr' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'r' 'if' 'rshared' '!=' ""''"" ':' 'pp' '=' 'os' '.'
 'path' '.' 'split' '(' 'p' ')' 'pp0' '=' 'pp' '[' '0' ']' 'pp1' '=' 'pp'
 '[' '1' ']' 'ppp' '=' 'os' '.' 'getcwd' '(' ')' 'os' '.' 'chdir' '('
 'pp0' ')' 'ss' '=' 'cfg' '[' ""'repo_types'"" ']' '[' 'rshared' ']' '['
 ""'rm'"" ']' '.' 'replace' '(' ""'$#files#$'"" ',' 'pp1' ')' 'rx' '=' 'os'
 '.' 'system' '(' 'ss' ')' '# Delete directory' 'r' '=' '{' ""'return'"" ':'
 '0' '}' 'if' 'os' '.' 'path' '.' 'isdir' '(' 'p' ')' ':' 'r' '='
 'delete_directory' '(' '{' ""'path'"" ':' 'p' '}' ')' 'if' 'rshared' '!='
 ""''"" ':' 'os' '.' 'chdir' '(' 'ppp' ')' 'if' 'r' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'r' '# Check if need to delete index' 'if' 'cfg' '.'
 'get' '(' ""'use_indexing'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'path' '=' ""'/'""
 '+' 'muid' '+' ""'/'"" '+' 'duid' '+' ""'/1'"" 'ri' '=' 'access_index_server'
 '(' '{' ""'request'"" ':' ""'DELETE'"" ',' ""'path'"" ':' 'path' '}' ')' 'if'
 'ri' '[' ""'return'"" ']' '>' '0' ':' 'return' 'ri' 'if' 'o' '==' ""'con'""
 ':' 'out' '(' ""'   Entry '"" '+' 'xcuoa' '+'
 ""' was successfully deleted!'"" ')' 'return' '{' ""'return'"" ':' '0' '}']","Input:  {
              (repo_uoa)      - repo UOA    ; can be wild cards
              module_uoa      - module UOA  ; can be wild cards
              data_uoa        - data UOA    ; can be wild cards

              (force)         - if 'yes', force deleting without questions
                 or
              (f)             - to be compatible with rm -f 

              (share)         - if 'yes', try to remove via GIT

              (tags)          - use these tags in format tags=x,y,z to prune rm
                   or
              (search_string) - prune entries with expression *?
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' ';' 'can' 'be' 'wild'
 'cards' 'module_uoa' '-' 'module' 'UOA' ';' 'can' 'be' 'wild' 'cards'
 'data_uoa' '-' 'data' 'UOA' ';' 'can' 'be' 'wild' 'cards']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L6309-L6471
ctuning/ck,ck/kernel.py,ren,"def ren(i):
    """"""
    Input:  {
              (repo_uoa)         - repo UOA
              module_uoa         - module UOA
              data_uoa           - old data UOA

              new_data_uoa       - new data alias
                 or
              new_data_uid       - new data UID (leave empty to keep old one)
                 or
              xcids[0]           - {'data_uoa'} - new data UOA

              (new_uid)          - generate new UID

              (remove_alias)     - if 'yes', remove alias

              (add_uid_to_alias) - if 'yes', add UID to alias

              (share)            - if 'yes', try to remove old entry via GIT and add new one
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({'delete':'yes'})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if muoa=='': return {'return':1, 'error':'module UOA is not defined'}
    if duoa=='': return {'return':1, 'error':'data UOA is not defined'}

    # Attempt to load
    ii={'module_uoa':muoa, 'data_uoa':duoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r
    rdd=r
    muid=r['module_uid']
    pr=r['path_repo']
    ddi=r['info']

    duoa=r['data_uoa']
    duid=r['data_uid']
    dalias=r['data_alias']

    change_data_name=(ddi.get('data_name','')==dalias)

    p=r['path']
    pm=r['path_module'] 

    p1=os.path.join(pm, cfg['subdir_ck_ext'])
    pn=p

    # Check if writing is allowed
    ii={'module_uoa':muoa, 'module_uid':muid, 'repo_uoa':ruoa, 'repo_uid':r['repo_uid']}
    r=check_writing(ii)
    if r['return']>0: return r

    rd=r.get('repo_dict',{})
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    shr=i.get('share','')
    if shr=='yes': 
       rshared='git'
       rsync='yes'

    # Check if index -> delete old index
    if cfg.get('use_indexing','')=='yes':
       path='/'+muid+'/'+duid+'/1'
       ri=access_index_server({'request':'DELETE', 'path':path})
       if ri['return']>0: return ri

    # Check new data UOA
    nduoa=i.get('new_data_uoa','')
    nduid=i.get('new_data_uid','')

    if nduid=='' and i.get('new_uid','')=='yes':
       rx=gen_uid({})
       if rx['return']>0: return rx
       nduid=rx['data_uid']

    xcids=i.get('xcids',[])
    if len(xcids)>0: 
       xcid=xcids[0]
       nduoa=xcid.get('data_uoa','')

    if i.get('remove_alias','')=='yes':
       nduoa=duid

    if nduoa=='': nduoa=duoa

    if nduid!=duid:
       # Check that new UID doesn't exist
       p2=os.path.join(p1, cfg['file_alias_u'] + nduid)
       if os.path.isfile(p2):
          return {'return':1, 'error':'new UID already exists'}

    # Check if adding UID to alias
    if i.get('add_uid_to_alias','')=='yes':
       x=nduid
       if x=='': x=duid
       nduoa+='-'+x

    if nduoa!=duoa:
       if not is_uoa(nduoa):
          return {'return':1, 'error':'alias has disallowed characters'}

       # Need to rename directory
       if os.path.isdir(nduoa):
          return {'return':1, 'error': 'new alias already exists'}

       pn=os.path.join(pm, nduoa)

       if rshared!='' and rsync=='yes':
          import shutil

          shutil.copytree(p,pn)

          ppp=os.getcwd()

          pp=os.path.split(pn)
          pp0=pp[0]
          pp1=pp[1]

          os.chdir(pp0)
          ss=cfg['repo_types'][rshared]['add'].replace('$#files#$', pp1)
          rx=os.system(ss)

          pp=os.path.split(p)
          pp0=pp[0]
          pp1=pp[1]

          ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', pp1)
          rx=os.system(ss)

          os.chdir(ppp)

          if os.path.isdir(p):
             shutil.rmtree(p, onerror=rm_read_only)

       else:
          os.rename(p, pn)

    if nduid!='' or change_data_name:
       # Change backup_data_uid in info file
       ppi=os.path.join(pn,cfg['subdir_ck_ext'],cfg['file_info'])

       if nduid!='':
          ddi['backup_data_uid']=nduid

       if change_data_name:
          ddi['data_name']=nduoa

       rx=save_json_to_file({'json_file':ppi, 'dict':ddi, 'sort_keys':'yes'})
       if rx['return']>0: return rx

    if nduid=='': nduid=duid

    # Remove old alias disambiguator
    if not is_uid(duoa):
       r=delete_alias({'path':pm, 'data_uid':duid, 'data_alias':duoa, 'share':shr})
       if r['return']>0: return r

    # Add new disambiguator, if needed
    if not is_uid(nduoa):
       if not os.path.isdir(p1):
          # Create .cm directory
          try:
             os.mkdir(p1)
          except Exception as e:
             return {'return':1, 'error':format(e)}

       # Write UOA disambiguator
       p3=os.path.join(p1, cfg['file_alias_a'] + nduoa)

       ru=save_text_file({'text_file':p3, 'string':nduid+'\n'})
       if ru['return']>0: return ru

       # Write UID disambiguator
       p2=os.path.join(p1, cfg['file_alias_u'] + nduid)

       ru=save_text_file({'text_file':p2, 'string':nduoa+'\n'})
       if ru['return']>0: return ru

       if rshared!='' and rsync=='yes':
          ppp=os.getcwd()

          pp=os.path.split(p1)
          pp0=pp[0]
          pp1=pp[1]

          os.chdir(pp0)
          ss=cfg['repo_types'][rshared]['add'].replace('$#files#$', pp1)
          rx=os.system(ss)

          os.chdir(ppp)

    # Check if index and add new
    if cfg.get('use_indexing','')=='yes':
       if is_uid(nduoa): nduid=nduoa
       path='/'+muid+'/'+nduid+'/1'
       ri=access_index_server({'request':'DELETE', 'path':path})
       if ri['return']>0: return ri
       ri=access_index_server({'request':'PUT', 'path':path, 'dict':rdd})
       if ri['return']>0: return ri

    if o=='con':
       out('Entry was successfully renamed!')

    return {'return':0}",python,"def ren(i):
    """"""
    Input:  {
              (repo_uoa)         - repo UOA
              module_uoa         - module UOA
              data_uoa           - old data UOA

              new_data_uoa       - new data alias
                 or
              new_data_uid       - new data UID (leave empty to keep old one)
                 or
              xcids[0]           - {'data_uoa'} - new data UOA

              (new_uid)          - generate new UID

              (remove_alias)     - if 'yes', remove alias

              (add_uid_to_alias) - if 'yes', add UID to alias

              (share)            - if 'yes', try to remove old entry via GIT and add new one
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({'delete':'yes'})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if muoa=='': return {'return':1, 'error':'module UOA is not defined'}
    if duoa=='': return {'return':1, 'error':'data UOA is not defined'}

    # Attempt to load
    ii={'module_uoa':muoa, 'data_uoa':duoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r
    rdd=r
    muid=r['module_uid']
    pr=r['path_repo']
    ddi=r['info']

    duoa=r['data_uoa']
    duid=r['data_uid']
    dalias=r['data_alias']

    change_data_name=(ddi.get('data_name','')==dalias)

    p=r['path']
    pm=r['path_module'] 

    p1=os.path.join(pm, cfg['subdir_ck_ext'])
    pn=p

    # Check if writing is allowed
    ii={'module_uoa':muoa, 'module_uid':muid, 'repo_uoa':ruoa, 'repo_uid':r['repo_uid']}
    r=check_writing(ii)
    if r['return']>0: return r

    rd=r.get('repo_dict',{})
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    shr=i.get('share','')
    if shr=='yes': 
       rshared='git'
       rsync='yes'

    # Check if index -> delete old index
    if cfg.get('use_indexing','')=='yes':
       path='/'+muid+'/'+duid+'/1'
       ri=access_index_server({'request':'DELETE', 'path':path})
       if ri['return']>0: return ri

    # Check new data UOA
    nduoa=i.get('new_data_uoa','')
    nduid=i.get('new_data_uid','')

    if nduid=='' and i.get('new_uid','')=='yes':
       rx=gen_uid({})
       if rx['return']>0: return rx
       nduid=rx['data_uid']

    xcids=i.get('xcids',[])
    if len(xcids)>0: 
       xcid=xcids[0]
       nduoa=xcid.get('data_uoa','')

    if i.get('remove_alias','')=='yes':
       nduoa=duid

    if nduoa=='': nduoa=duoa

    if nduid!=duid:
       # Check that new UID doesn't exist
       p2=os.path.join(p1, cfg['file_alias_u'] + nduid)
       if os.path.isfile(p2):
          return {'return':1, 'error':'new UID already exists'}

    # Check if adding UID to alias
    if i.get('add_uid_to_alias','')=='yes':
       x=nduid
       if x=='': x=duid
       nduoa+='-'+x

    if nduoa!=duoa:
       if not is_uoa(nduoa):
          return {'return':1, 'error':'alias has disallowed characters'}

       # Need to rename directory
       if os.path.isdir(nduoa):
          return {'return':1, 'error': 'new alias already exists'}

       pn=os.path.join(pm, nduoa)

       if rshared!='' and rsync=='yes':
          import shutil

          shutil.copytree(p,pn)

          ppp=os.getcwd()

          pp=os.path.split(pn)
          pp0=pp[0]
          pp1=pp[1]

          os.chdir(pp0)
          ss=cfg['repo_types'][rshared]['add'].replace('$#files#$', pp1)
          rx=os.system(ss)

          pp=os.path.split(p)
          pp0=pp[0]
          pp1=pp[1]

          ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', pp1)
          rx=os.system(ss)

          os.chdir(ppp)

          if os.path.isdir(p):
             shutil.rmtree(p, onerror=rm_read_only)

       else:
          os.rename(p, pn)

    if nduid!='' or change_data_name:
       # Change backup_data_uid in info file
       ppi=os.path.join(pn,cfg['subdir_ck_ext'],cfg['file_info'])

       if nduid!='':
          ddi['backup_data_uid']=nduid

       if change_data_name:
          ddi['data_name']=nduoa

       rx=save_json_to_file({'json_file':ppi, 'dict':ddi, 'sort_keys':'yes'})
       if rx['return']>0: return rx

    if nduid=='': nduid=duid

    # Remove old alias disambiguator
    if not is_uid(duoa):
       r=delete_alias({'path':pm, 'data_uid':duid, 'data_alias':duoa, 'share':shr})
       if r['return']>0: return r

    # Add new disambiguator, if needed
    if not is_uid(nduoa):
       if not os.path.isdir(p1):
          # Create .cm directory
          try:
             os.mkdir(p1)
          except Exception as e:
             return {'return':1, 'error':format(e)}

       # Write UOA disambiguator
       p3=os.path.join(p1, cfg['file_alias_a'] + nduoa)

       ru=save_text_file({'text_file':p3, 'string':nduid+'\n'})
       if ru['return']>0: return ru

       # Write UID disambiguator
       p2=os.path.join(p1, cfg['file_alias_u'] + nduid)

       ru=save_text_file({'text_file':p2, 'string':nduoa+'\n'})
       if ru['return']>0: return ru

       if rshared!='' and rsync=='yes':
          ppp=os.getcwd()

          pp=os.path.split(p1)
          pp0=pp[0]
          pp1=pp[1]

          os.chdir(pp0)
          ss=cfg['repo_types'][rshared]['add'].replace('$#files#$', pp1)
          rx=os.system(ss)

          os.chdir(ppp)

    # Check if index and add new
    if cfg.get('use_indexing','')=='yes':
       if is_uid(nduoa): nduid=nduoa
       path='/'+muid+'/'+nduid+'/1'
       ri=access_index_server({'request':'DELETE', 'path':path})
       if ri['return']>0: return ri
       ri=access_index_server({'request':'PUT', 'path':path, 'dict':rdd})
       if ri['return']>0: return ri

    if o=='con':
       out('Entry was successfully renamed!')

    return {'return':0}",['def' 'ren' '(' ... ':' '0' '}'],"Input:  {
              (repo_uoa)         - repo UOA
              module_uoa         - module UOA
              data_uoa           - old data UOA

              new_data_uoa       - new data alias
                 or
              new_data_uid       - new data UID (leave empty to keep old one)
                 or
              xcids[0]           - {'data_uoa'} - new data UOA

              (new_uid)          - generate new UID

              (remove_alias)     - if 'yes', remove alias

              (add_uid_to_alias) - if 'yes', add UID to alias

              (share)            - if 'yes', try to remove old entry via GIT and add new one
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'old' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L6506-L6728
ctuning/ck,ck/kernel.py,cp,"def cp(i):
    """"""
    Input:  {
              (repo_uoa)       - repo UOA
              module_uoa       - module UOA
              data_uoa         - data UOA

              xcids[0]         - {'repo_uoa', 'module_uoa', 'data_uoa'} - new CID
                 or
              (new_repo_uoa)   - new repo UOA
              (new_module_uoa) - new module UOA
              new_data_uoa     - new data alias
              (new_data_uid)   - new data UID (leave empty to generate new one)

              (move)           - if 'yes', remove old
              (keep_old_uid)   - if 'yes', keep old UID

              (without_files)  - if 'yes', do not move/copy files
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of 'add' function
            }

    """"""

    move=i.get('move','')

    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    import shutil

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if muoa=='': return {'return':1, 'error':'module UOA is not defined'}
    if duoa=='': return {'return':1, 'error':'data UOA is not defined'}

    # Attempt to load
    ii={'module_uoa':muoa, 'data_uoa':duoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r
    rdd=r
    muid=r['module_uid']

    duoa=r['data_uoa']
    duid=r['data_uid']

    p=r['path']

    dd=r.get('dict',{})
    di=r.get('info',{})
    du=r.get('updates',{})
    dx=r.get('desc',{})

    if move!='yes':
       control=di.get('control',{})

       control['version']=cfg['version']

       rdt=get_current_date_time({})
       control['iso_datetime']=rdt['iso_datetime']

       di['control']=control

    # Check if writing is allowed
    ii={'module_uoa':muoa, 'module_uid':r['module_uid'], 'repo_uoa':ruoa, 'repo_uid':r['repo_uid']}
    r=check_writing(ii)
    if r['return']>0: return r

    # Check new CID
    nruoa=i.get('new_repo_uoa','')
    nmuoa=i.get('new_module_uoa','')
    nduoa=i.get('new_data_uoa','')
    nduid=i.get('new_data_uid','')

    xcids=i.get('xcids',[])
    if len(xcids)>0: 
       xcid=xcids[0]
       nduoa=xcid.get('data_uoa','')

       if nduoa=='': nduoa=duoa

       x=xcid.get('module_uoa','')
       if x!='': nmuoa=x

       x=xcid.get('repo_uoa','')
       if x!='': nruoa=x

    if i.get('keep_old_uid','')=='yes': nduid=duid

    if nmuoa=='': nmuoa=muoa
    if nruoa=='': nruoa=ruoa

    # Adding new entry 
    if nruoa==ruoa and nmuoa==muoa and nduid==duid:
       return {'return':1, 'error':'moving within the same directory - use ""rename"" instead'}

    # Check if writing is allowed to the new repo
    ii={'repo_uoa':nruoa}
    r=check_writing(ii)
    if r['return']>0: return r

    rd=r.get('repo_dict',{})
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    ii={'module_uoa':nmuoa, 'data_uoa': nduoa, 'dict':dd, 'info':di, 
        'updates':du, 'desc':dx, 'ignore_update':'yes'}
    if nduid!='': ii['data_uid']=nduid
    if nruoa!='': ii['repo_uoa']=nruoa
    r=add(ii)
    if r['return']>0: return r
    pn=r['path']
    nmuid=r['module_uid']

    # Recursively copying all files (except .cm)
    if i.get('without_files','')!='yes':
       rx=list_all_files({'path':p})
       if rx['return']>0: return rx

       for q in rx['list']:
           p1=os.path.join(p,q)
           pn1=os.path.join(pn,q)

           # Create if dir
           pn1d=os.path.dirname(pn1)
           if not os.path.isdir(pn1d): os.makedirs(pn1d)

           shutil.copy(p1,pn1)

    if rshared!='' and rsync=='yes':
       ppp=os.getcwd()

       pp=os.path.split(pn)
       pp0=pp[0]
       pp1=pp[1]

       os.chdir(pp0)
       ss=cfg['repo_types'][rshared]['add'].replace('$#files#$', pp1)
       rx=os.system(ss)

       os.chdir(ppp)

    tt='copied'
    # If move, remove old one
    if move=='yes':
       tt='moved'

       ii={'module_uoa':muoa, 'data_uoa': duoa}
       if ruoa!='': ii['repo_uoa']=ruoa
       rx=rm(ii)
       if rx['return']>0: return rx

    # Check if index and add new
    if cfg.get('use_indexing','')=='yes':
       if is_uid(nduoa): nduid=nduoa
       path='/'+nmuid+'/'+nduid+'/1'
       ri=access_index_server({'request':'DELETE', 'path':path})
       if ri['return']>0: return ri
       ri=access_index_server({'request':'PUT', 'path':path, 'dict':rdd})
       if ri['return']>0: return ri

    if o=='con':
       out('Entry '+muoa+':'+duoa+' was successfully '+tt+'!')

    return r",python,"def cp(i):
    """"""
    Input:  {
              (repo_uoa)       - repo UOA
              module_uoa       - module UOA
              data_uoa         - data UOA

              xcids[0]         - {'repo_uoa', 'module_uoa', 'data_uoa'} - new CID
                 or
              (new_repo_uoa)   - new repo UOA
              (new_module_uoa) - new module UOA
              new_data_uoa     - new data alias
              (new_data_uid)   - new data UID (leave empty to generate new one)

              (move)           - if 'yes', remove old
              (keep_old_uid)   - if 'yes', keep old UID

              (without_files)  - if 'yes', do not move/copy files
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of 'add' function
            }

    """"""

    move=i.get('move','')

    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    import shutil

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if muoa=='': return {'return':1, 'error':'module UOA is not defined'}
    if duoa=='': return {'return':1, 'error':'data UOA is not defined'}

    # Attempt to load
    ii={'module_uoa':muoa, 'data_uoa':duoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r
    rdd=r
    muid=r['module_uid']

    duoa=r['data_uoa']
    duid=r['data_uid']

    p=r['path']

    dd=r.get('dict',{})
    di=r.get('info',{})
    du=r.get('updates',{})
    dx=r.get('desc',{})

    if move!='yes':
       control=di.get('control',{})

       control['version']=cfg['version']

       rdt=get_current_date_time({})
       control['iso_datetime']=rdt['iso_datetime']

       di['control']=control

    # Check if writing is allowed
    ii={'module_uoa':muoa, 'module_uid':r['module_uid'], 'repo_uoa':ruoa, 'repo_uid':r['repo_uid']}
    r=check_writing(ii)
    if r['return']>0: return r

    # Check new CID
    nruoa=i.get('new_repo_uoa','')
    nmuoa=i.get('new_module_uoa','')
    nduoa=i.get('new_data_uoa','')
    nduid=i.get('new_data_uid','')

    xcids=i.get('xcids',[])
    if len(xcids)>0: 
       xcid=xcids[0]
       nduoa=xcid.get('data_uoa','')

       if nduoa=='': nduoa=duoa

       x=xcid.get('module_uoa','')
       if x!='': nmuoa=x

       x=xcid.get('repo_uoa','')
       if x!='': nruoa=x

    if i.get('keep_old_uid','')=='yes': nduid=duid

    if nmuoa=='': nmuoa=muoa
    if nruoa=='': nruoa=ruoa

    # Adding new entry 
    if nruoa==ruoa and nmuoa==muoa and nduid==duid:
       return {'return':1, 'error':'moving within the same directory - use ""rename"" instead'}

    # Check if writing is allowed to the new repo
    ii={'repo_uoa':nruoa}
    r=check_writing(ii)
    if r['return']>0: return r

    rd=r.get('repo_dict',{})
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    ii={'module_uoa':nmuoa, 'data_uoa': nduoa, 'dict':dd, 'info':di, 
        'updates':du, 'desc':dx, 'ignore_update':'yes'}
    if nduid!='': ii['data_uid']=nduid
    if nruoa!='': ii['repo_uoa']=nruoa
    r=add(ii)
    if r['return']>0: return r
    pn=r['path']
    nmuid=r['module_uid']

    # Recursively copying all files (except .cm)
    if i.get('without_files','')!='yes':
       rx=list_all_files({'path':p})
       if rx['return']>0: return rx

       for q in rx['list']:
           p1=os.path.join(p,q)
           pn1=os.path.join(pn,q)

           # Create if dir
           pn1d=os.path.dirname(pn1)
           if not os.path.isdir(pn1d): os.makedirs(pn1d)

           shutil.copy(p1,pn1)

    if rshared!='' and rsync=='yes':
       ppp=os.getcwd()

       pp=os.path.split(pn)
       pp0=pp[0]
       pp1=pp[1]

       os.chdir(pp0)
       ss=cfg['repo_types'][rshared]['add'].replace('$#files#$', pp1)
       rx=os.system(ss)

       os.chdir(ppp)

    tt='copied'
    # If move, remove old one
    if move=='yes':
       tt='moved'

       ii={'module_uoa':muoa, 'data_uoa': duoa}
       if ruoa!='': ii['repo_uoa']=ruoa
       rx=rm(ii)
       if rx['return']>0: return rx

    # Check if index and add new
    if cfg.get('use_indexing','')=='yes':
       if is_uid(nduoa): nduid=nduoa
       path='/'+nmuid+'/'+nduid+'/1'
       ri=access_index_server({'request':'DELETE', 'path':path})
       if ri['return']>0: return ri
       ri=access_index_server({'request':'PUT', 'path':path, 'dict':rdd})
       if ri['return']>0: return ri

    if o=='con':
       out('Entry '+muoa+':'+duoa+' was successfully '+tt+'!')

    return r","['def' 'cp' '(' 'i' ')' ':' 'move' '=' 'i' '.' 'get' '(' ""'move'"" ',' ""''""
 ')' '# Check if global writing is allowed' 'r' '=' 'check_writing' '('
 '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'import'
 'shutil' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')' 'ruoa' '=' 'i'
 '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get' '('
 ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ','
 ""''"" ')' 'if' 'muoa' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'module UOA is not defined'"" '}' 'if' 'duoa' '==' ""''"" ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'data UOA is not defined'"" '}' '# Attempt to load' 'ii' '=' '{'
 ""'module_uoa'"" ':' 'muoa' ',' ""'data_uoa'"" ':' 'duoa' '}' 'if' 'ruoa'
 '!=' ""''"" ':' 'ii' '[' ""'repo_uoa'"" ']' '=' 'ruoa' 'r' '=' 'load' '('
 'ii' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'rdd' '='
 'r' 'muid' '=' 'r' '[' ""'module_uid'"" ']' 'duoa' '=' 'r' '[' ""'data_uoa'""
 ']' 'duid' '=' 'r' '[' ""'data_uid'"" ']' 'p' '=' 'r' '[' ""'path'"" ']' 'dd'
 '=' 'r' '.' 'get' '(' ""'dict'"" ',' '{' '}' ')' 'di' '=' 'r' '.' 'get' '('
 ""'info'"" ',' '{' '}' ')' 'du' '=' 'r' '.' 'get' '(' ""'updates'"" ',' '{'
 '}' ')' 'dx' '=' 'r' '.' 'get' '(' ""'desc'"" ',' '{' '}' ')' 'if' 'move'
 '!=' ""'yes'"" ':' 'control' '=' 'di' '.' 'get' '(' ""'control'"" ',' '{' '}'
 ')' 'control' '[' ""'version'"" ']' '=' 'cfg' '[' ""'version'"" ']' 'rdt' '='
 'get_current_date_time' '(' '{' '}' ')' 'control' '[' ""'iso_datetime'""
 ']' '=' 'rdt' '[' ""'iso_datetime'"" ']' 'di' '[' ""'control'"" ']' '='
 'control' '# Check if writing is allowed' 'ii' '=' '{' ""'module_uoa'"" ':'
 'muoa' ',' ""'module_uid'"" ':' 'r' '[' ""'module_uid'"" ']' ',' ""'repo_uoa'""
 ':' 'ruoa' ',' ""'repo_uid'"" ':' 'r' '[' ""'repo_uid'"" ']' '}' 'r' '='
 'check_writing' '(' 'ii' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' '# Check new CID' 'nruoa' '=' 'i' '.' 'get' '('
 ""'new_repo_uoa'"" ',' ""''"" ')' 'nmuoa' '=' 'i' '.' 'get' '('
 ""'new_module_uoa'"" ',' ""''"" ')' 'nduoa' '=' 'i' '.' 'get' '('
 ""'new_data_uoa'"" ',' ""''"" ')' 'nduid' '=' 'i' '.' 'get' '('
 ""'new_data_uid'"" ',' ""''"" ')' 'xcids' '=' 'i' '.' 'get' '(' ""'xcids'"" ','
 '[' ']' ')' 'if' 'len' '(' 'xcids' ')' '>' '0' ':' 'xcid' '=' 'xcids' '['
 '0' ']' 'nduoa' '=' 'xcid' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if'
 'nduoa' '==' ""''"" ':' 'nduoa' '=' 'duoa' 'x' '=' 'xcid' '.' 'get' '('
 ""'module_uoa'"" ',' ""''"" ')' 'if' 'x' '!=' ""''"" ':' 'nmuoa' '=' 'x' 'x'
 '=' 'xcid' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'if' 'x' '!=' ""''"" ':'
 'nruoa' '=' 'x' 'if' 'i' '.' 'get' '(' ""'keep_old_uid'"" ',' ""''"" ')' '=='
 ""'yes'"" ':' 'nduid' '=' 'duid' 'if' 'nmuoa' '==' ""''"" ':' 'nmuoa' '='
 'muoa' 'if' 'nruoa' '==' ""''"" ':' 'nruoa' '=' 'ruoa'
 '# Adding new entry ' 'if' 'nruoa' '==' 'ruoa' 'and' 'nmuoa' '==' 'muoa'
 'and' 'nduid' '==' 'duid' ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':'
 '\'moving within the same directory - use ""rename"" instead\'' '}'
 '# Check if writing is allowed to the new repo' 'ii' '=' '{' ""'repo_uoa'""
 ':' 'nruoa' '}' 'r' '=' 'check_writing' '(' 'ii' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'rd' '=' 'r' '.' 'get' '('
 ""'repo_dict'"" ',' '{' '}' ')' 'rshared' '=' 'rd' '.' 'get' '(' ""'shared'""
 ',' ""''"" ')' 'rsync' '=' 'rd' '.' 'get' '(' ""'sync'"" ',' ""''"" ')' 'ii'
 '=' '{' ""'module_uoa'"" ':' 'nmuoa' ',' ""'data_uoa'"" ':' 'nduoa' ','
 ""'dict'"" ':' 'dd' ',' ""'info'"" ':' 'di' ',' ""'updates'"" ':' 'du' ','
 ""'desc'"" ':' 'dx' ',' ""'ignore_update'"" ':' ""'yes'"" '}' 'if' 'nduid' '!='
 ""''"" ':' 'ii' '[' ""'data_uid'"" ']' '=' 'nduid' 'if' 'nruoa' '!=' ""''"" ':'
 'ii' '[' ""'repo_uoa'"" ']' '=' 'nruoa' 'r' '=' 'add' '(' 'ii' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'pn' '=' 'r' '[' ""'path'"" ']'
 'nmuid' '=' 'r' '[' ""'module_uid'"" ']'
 '# Recursively copying all files (except .cm)' 'if' 'i' '.' 'get' '('
 ""'without_files'"" ',' ""''"" ')' '!=' ""'yes'"" ':' 'rx' '=' 'list_all_files'
 '(' '{' ""'path'"" ':' 'p' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'rx' 'for' 'q' 'in' 'rx' '[' ""'list'"" ']' ':' 'p1' '=' 'os' '.'
 'path' '.' 'join' '(' 'p' ',' 'q' ')' 'pn1' '=' 'os' '.' 'path' '.'
 'join' '(' 'pn' ',' 'q' ')' '# Create if dir' 'pn1d' '=' 'os' '.' 'path'
 '.' 'dirname' '(' 'pn1' ')' 'if' 'not' 'os' '.' 'path' '.' 'isdir' '('
 'pn1d' ')' ':' 'os' '.' 'makedirs' '(' 'pn1d' ')' 'shutil' '.' 'copy' '('
 'p1' ',' 'pn1' ')' 'if' 'rshared' '!=' ""''"" 'and' 'rsync' '==' ""'yes'""
 ':' 'ppp' '=' 'os' '.' 'getcwd' '(' ')' 'pp' '=' 'os' '.' 'path' '.'
 'split' '(' 'pn' ')' 'pp0' '=' 'pp' '[' '0' ']' 'pp1' '=' 'pp' '[' '1'
 ']' 'os' '.' 'chdir' '(' 'pp0' ')' 'ss' '=' 'cfg' '[' ""'repo_types'"" ']'
 '[' 'rshared' ']' '[' ""'add'"" ']' '.' 'replace' '(' ""'$#files#$'"" ','
 'pp1' ')' 'rx' '=' 'os' '.' 'system' '(' 'ss' ')' 'os' '.' 'chdir' '('
 'ppp' ')' 'tt' '=' ""'copied'"" '# If move, remove old one' 'if' 'move'
 '==' ""'yes'"" ':' 'tt' '=' ""'moved'"" 'ii' '=' '{' ""'module_uoa'"" ':'
 'muoa' ',' ""'data_uoa'"" ':' 'duoa' '}' 'if' 'ruoa' '!=' ""''"" ':' 'ii' '['
 ""'repo_uoa'"" ']' '=' 'ruoa' 'rx' '=' 'rm' '(' 'ii' ')' 'if' 'rx' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'rx' '# Check if index and add new'
 'if' 'cfg' '.' 'get' '(' ""'use_indexing'"" ',' ""''"" ')' '==' ""'yes'"" ':'
 'if' 'is_uid' '(' 'nduoa' ')' ':' 'nduid' '=' 'nduoa' 'path' '=' ""'/'""
 '+' 'nmuid' '+' ""'/'"" '+' 'nduid' '+' ""'/1'"" 'ri' '='
 'access_index_server' '(' '{' ""'request'"" ':' ""'DELETE'"" ',' ""'path'"" ':'
 'path' '}' ')' 'if' 'ri' '[' ""'return'"" ']' '>' '0' ':' 'return' 'ri'
 'ri' '=' 'access_index_server' '(' '{' ""'request'"" ':' ""'PUT'"" ','
 ""'path'"" ':' 'path' ',' ""'dict'"" ':' 'rdd' '}' ')' 'if' 'ri' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'ri' 'if' 'o' '==' ""'con'"" ':' 'out'
 '(' ""'Entry '"" '+' 'muoa' '+' ""':'"" '+' 'duoa' '+' ""' was successfully '""
 '+' 'tt' '+' ""'!'"" ')' 'return' 'r']","Input:  {
              (repo_uoa)       - repo UOA
              module_uoa       - module UOA
              data_uoa         - data UOA

              xcids[0]         - {'repo_uoa', 'module_uoa', 'data_uoa'} - new CID
                 or
              (new_repo_uoa)   - new repo UOA
              (new_module_uoa) - new module UOA
              new_data_uoa     - new data alias
              (new_data_uid)   - new data UID (leave empty to generate new one)

              (move)           - if 'yes', remove old
              (keep_old_uid)   - if 'yes', keep old UID

              (without_files)  - if 'yes', do not move/copy files
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of 'add' function
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L6749-L6925
ctuning/ck,ck/kernel.py,mv,"def mv(i):
    """"""
    Input:  {
              (repo_uoa)    - repo UOA
              module_uoa    - module UOA
              data_uoa      - data UOA

              xcids[0]         - {'repo_uoa', 'module_uoa', 'data_uoa'} - new CID
                 or
              (new_repo_uoa)   - new repo UOA
              (new_module_uoa) - new module UOA
              (new_data_uoa)   - new data alias
              (new_data_uid)   - new data UID (leave empty to generate new one)

            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of 'copy' function
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({'delete':'yes'})
    if r['return']>0: return r

    # Check if wild cards
    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')
    nduoa=i.get('new_data_uoa','')
    nduid=i.get('new_data_uid','')

    xcids=i.get('xcids',[])
    if len(xcids)>0: 
       xcid=xcids[0]
       nduoa=xcid.get('data_uoa','')

    if (duoa.find('*')>=0 or duoa.find('?')>=0) and nduoa=='' and nduid=='':
       r=list_data({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
       if r['return']>0: return r

       lst=r['lst']
    else:
       lst=[{'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa}]

    i['move']='yes'
    i['keep_old_uid']='yes'

    r={'return':0}
    for ll in lst:
        i['repo_uoa']=ll['repo_uoa']
        i['module_uoa']=ll['module_uoa']
        i['data_uoa']=ll['data_uoa']
        r=copy(i)
        if r['return']>0: return r

    return r",python,"def mv(i):
    """"""
    Input:  {
              (repo_uoa)    - repo UOA
              module_uoa    - module UOA
              data_uoa      - data UOA

              xcids[0]         - {'repo_uoa', 'module_uoa', 'data_uoa'} - new CID
                 or
              (new_repo_uoa)   - new repo UOA
              (new_module_uoa) - new module UOA
              (new_data_uoa)   - new data alias
              (new_data_uid)   - new data UID (leave empty to generate new one)

            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of 'copy' function
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({'delete':'yes'})
    if r['return']>0: return r

    # Check if wild cards
    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')
    nduoa=i.get('new_data_uoa','')
    nduid=i.get('new_data_uid','')

    xcids=i.get('xcids',[])
    if len(xcids)>0: 
       xcid=xcids[0]
       nduoa=xcid.get('data_uoa','')

    if (duoa.find('*')>=0 or duoa.find('?')>=0) and nduoa=='' and nduid=='':
       r=list_data({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
       if r['return']>0: return r

       lst=r['lst']
    else:
       lst=[{'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa}]

    i['move']='yes'
    i['keep_old_uid']='yes'

    r={'return':0}
    for ll in lst:
        i['repo_uoa']=ll['repo_uoa']
        i['module_uoa']=ll['module_uoa']
        i['data_uoa']=ll['data_uoa']
        r=copy(i)
        if r['return']>0: return r

    return r","['def' 'mv' '(' 'i' ')' ':' '# Check if global writing is allowed' 'r' '='
 'check_writing' '(' '{' ""'delete'"" ':' ""'yes'"" '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' '# Check if wild cards' 'ruoa'
 '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get'
 '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'""
 ',' ""''"" ')' 'nduoa' '=' 'i' '.' 'get' '(' ""'new_data_uoa'"" ',' ""''"" ')'
 'nduid' '=' 'i' '.' 'get' '(' ""'new_data_uid'"" ',' ""''"" ')' 'xcids' '='
 'i' '.' 'get' '(' ""'xcids'"" ',' '[' ']' ')' 'if' 'len' '(' 'xcids' ')'
 '>' '0' ':' 'xcid' '=' 'xcids' '[' '0' ']' 'nduoa' '=' 'xcid' '.' 'get'
 '(' ""'data_uoa'"" ',' ""''"" ')' 'if' '(' 'duoa' '.' 'find' '(' ""'*'"" ')'
 '>=' '0' 'or' 'duoa' '.' 'find' '(' ""'?'"" ')' '>=' '0' ')' 'and' 'nduoa'
 '==' ""''"" 'and' 'nduid' '==' ""''"" ':' 'r' '=' 'list_data' '(' '{'
 ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ',' ""'data_uoa'""
 ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r'
 'lst' '=' 'r' '[' ""'lst'"" ']' 'else' ':' 'lst' '=' '[' '{' ""'repo_uoa'""
 ':' 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ',' ""'data_uoa'"" ':' 'duoa' '}'
 ']' 'i' '[' ""'move'"" ']' '=' ""'yes'"" 'i' '[' ""'keep_old_uid'"" ']' '='
 ""'yes'"" 'r' '=' '{' ""'return'"" ':' '0' '}' 'for' 'll' 'in' 'lst' ':' 'i'
 '[' ""'repo_uoa'"" ']' '=' 'll' '[' ""'repo_uoa'"" ']' 'i' '[' ""'module_uoa'""
 ']' '=' 'll' '[' ""'module_uoa'"" ']' 'i' '[' ""'data_uoa'"" ']' '=' 'll' '['
 ""'data_uoa'"" ']' 'r' '=' 'copy' '(' 'i' ')' 'if' 'r' '[' ""'return'"" ']'
 '>' '0' ':' 'return' 'r' 'return' 'r']","Input:  {
              (repo_uoa)    - repo UOA
              module_uoa    - module UOA
              data_uoa      - data UOA

              xcids[0]         - {'repo_uoa', 'module_uoa', 'data_uoa'} - new CID
                 or
              (new_repo_uoa)   - new repo UOA
              (new_module_uoa) - new module UOA
              (new_data_uoa)   - new data alias
              (new_data_uid)   - new data UID (leave empty to generate new one)

            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of 'copy' function
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L6946-L7007
ctuning/ck,ck/kernel.py,delete_file,"def delete_file(i):
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA

              filename    - filename to delete including relative path
              (force)     - if 'yes', force deleting without questions
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({'delete':'yes'})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    # Check file
    fn=i.get('filename','')
    if fn=='':
       x=i.get('cids',[])
       if len(x)>0:
          fn=x[0]

    if fn=='':
       return {'return':1, 'error':'filename is empty'}

    if duoa=='':
       return {'return':1, 'error':'data UOA is not defined'}

    if fn=='':
       return {'return':1, 'error':'filename is not defined'}

    # Get info about entry
    r=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    p=r['path']

    ruoa=r['repo_uoa']
    ruid=r['repo_uid']

    # Check repo/module writing
    ii={'module_uoa':muoa, 'repo_uoa':ruoa, 'repo_uid':ruid}
    r=check_writing(ii)
    if r['return']>0: return r

    rd=r.get('repo_dict',{})
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    p1=os.path.normpath(os.path.join(p, fn))
    px=os.path.normpath(os.path.join(p, cfg['subdir_ck_ext']))

    if p1.startswith(px):
       return {'return':1, 'error':'path points to the special directory with meta info'}

    if not p1.startswith(p):
       return {'return':1, 'error':'path is outside entry'}

    if not os.path.isfile(p1) and not os.path.isdir(p1):
       return {'return':1, 'error':'file or directory is not found'}

    p2=os.path.split(p1)
    px0=p2[0]
    px1=p2[1]

    if rshared!='':
       ppp=os.getcwd()
       os.chdir(px0)

       ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', px1)
       rx=os.system(ss)

    if os.path.isfile(p1):
       os.remove(p1)

    if os.path.isdir(p1):
       import shutil
       shutil.rmtree(p1, onerror=rm_read_only)

    if rshared!='':
       os.chdir(ppp)

    return {'return':0}",python,"def delete_file(i):
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA

              filename    - filename to delete including relative path
              (force)     - if 'yes', force deleting without questions
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({'delete':'yes'})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    # Check file
    fn=i.get('filename','')
    if fn=='':
       x=i.get('cids',[])
       if len(x)>0:
          fn=x[0]

    if fn=='':
       return {'return':1, 'error':'filename is empty'}

    if duoa=='':
       return {'return':1, 'error':'data UOA is not defined'}

    if fn=='':
       return {'return':1, 'error':'filename is not defined'}

    # Get info about entry
    r=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    p=r['path']

    ruoa=r['repo_uoa']
    ruid=r['repo_uid']

    # Check repo/module writing
    ii={'module_uoa':muoa, 'repo_uoa':ruoa, 'repo_uid':ruid}
    r=check_writing(ii)
    if r['return']>0: return r

    rd=r.get('repo_dict',{})
    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    p1=os.path.normpath(os.path.join(p, fn))
    px=os.path.normpath(os.path.join(p, cfg['subdir_ck_ext']))

    if p1.startswith(px):
       return {'return':1, 'error':'path points to the special directory with meta info'}

    if not p1.startswith(p):
       return {'return':1, 'error':'path is outside entry'}

    if not os.path.isfile(p1) and not os.path.isdir(p1):
       return {'return':1, 'error':'file or directory is not found'}

    p2=os.path.split(p1)
    px0=p2[0]
    px1=p2[1]

    if rshared!='':
       ppp=os.getcwd()
       os.chdir(px0)

       ss=cfg['repo_types'][rshared]['rm'].replace('$#files#$', px1)
       rx=os.system(ss)

    if os.path.isfile(p1):
       os.remove(p1)

    if os.path.isdir(p1):
       import shutil
       shutil.rmtree(p1, onerror=rm_read_only)

    if rshared!='':
       os.chdir(ppp)

    return {'return':0}","['def' 'delete_file' '(' 'i' ')' ':'
 '# Check if global writing is allowed' 'r' '=' 'check_writing' '(' '{'
 ""'delete'"" ':' ""'yes'"" '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')' 'ruoa' '='
 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get' '('
 ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ','
 ""''"" ')' '# Check file' 'fn' '=' 'i' '.' 'get' '(' ""'filename'"" ',' ""''""
 ')' 'if' 'fn' '==' ""''"" ':' 'x' '=' 'i' '.' 'get' '(' ""'cids'"" ',' '['
 ']' ')' 'if' 'len' '(' 'x' ')' '>' '0' ':' 'fn' '=' 'x' '[' '0' ']' 'if'
 'fn' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'filename is empty'"" '}' 'if' 'duoa' '==' ""''"" ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':' ""'data UOA is not defined'"" '}' 'if'
 'fn' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'filename is not defined'"" '}' '# Get info about entry' 'r' '=' 'load'
 '(' '{' ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ','
 ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'p' '=' 'r' '[' ""'path'"" ']' 'ruoa' '=' 'r' '[' ""'repo_uoa'""
 ']' 'ruid' '=' 'r' '[' ""'repo_uid'"" ']' '# Check repo/module writing'
 'ii' '=' '{' ""'module_uoa'"" ':' 'muoa' ',' ""'repo_uoa'"" ':' 'ruoa' ','
 ""'repo_uid'"" ':' 'ruid' '}' 'r' '=' 'check_writing' '(' 'ii' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'rd' '=' 'r' '.' 'get' '('
 ""'repo_dict'"" ',' '{' '}' ')' 'rshared' '=' 'rd' '.' 'get' '(' ""'shared'""
 ',' ""''"" ')' 'rsync' '=' 'rd' '.' 'get' '(' ""'sync'"" ',' ""''"" ')' 'p1'
 '=' 'os' '.' 'path' '.' 'normpath' '(' 'os' '.' 'path' '.' 'join' '(' 'p'
 ',' 'fn' ')' ')' 'px' '=' 'os' '.' 'path' '.' 'normpath' '(' 'os' '.'
 'path' '.' 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'"" ']' ')' ')'
 'if' 'p1' '.' 'startswith' '(' 'px' ')' ':' 'return' '{' ""'return'"" ':'
 '1' ',' ""'error'"" ':'
 ""'path points to the special directory with meta info'"" '}' 'if' 'not'
 'p1' '.' 'startswith' '(' 'p' ')' ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'path is outside entry'"" '}' 'if' 'not' 'os' '.' 'path'
 '.' 'isfile' '(' 'p1' ')' 'and' 'not' 'os' '.' 'path' '.' 'isdir' '('
 'p1' ')' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'file or directory is not found'"" '}' 'p2' '=' 'os' '.' 'path' '.'
 'split' '(' 'p1' ')' 'px0' '=' 'p2' '[' '0' ']' 'px1' '=' 'p2' '[' '1'
 ']' 'if' 'rshared' '!=' ""''"" ':' 'ppp' '=' 'os' '.' 'getcwd' '(' ')' 'os'
 '.' 'chdir' '(' 'px0' ')' 'ss' '=' 'cfg' '[' ""'repo_types'"" ']' '['
 'rshared' ']' '[' ""'rm'"" ']' '.' 'replace' '(' ""'$#files#$'"" ',' 'px1'
 ')' 'rx' '=' 'os' '.' 'system' '(' 'ss' ')' 'if' 'os' '.' 'path' '.'
 'isfile' '(' 'p1' ')' ':' 'os' '.' 'remove' '(' 'p1' ')' 'if' 'os' '.'
 'path' '.' 'isdir' '(' 'p1' ')' ':' 'import' 'shutil' 'shutil' '.'
 'rmtree' '(' 'p1' ',' 'onerror' '=' 'rm_read_only' ')' 'if' 'rshared'
 '!=' ""''"" ':' 'os' '.' 'chdir' '(' 'ppp' ')' 'return' '{' ""'return'"" ':'
 '0' '}']","Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - module UOA
              data_uoa    - data UOA

              filename    - filename to delete including relative path
              (force)     - if 'yes', force deleting without questions
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L7028-L7124
ctuning/ck,ck/kernel.py,list_data,"def list_data(i):
    """"""
    Input:  {
              (repo_uoa)           - repo UOA
              (module_uoa)         - module UOA
              (data_uoa)           - data UOA

              (repo_uoa_list)      - list of repos to search
              (module_uoa_list)    - list of module to search
              (data_uoa_list)      - list of data to search

              (filter_func)        - name of filter function
              (filter_func_addr)   - address of filter function

              (add_if_date_before) - add only entries with date before this date 
              (add_if_date_after)  - add only entries with date after this date
              (add_if_date)        - add only entries with this date

              (ignore_update)      - if 'yes', do not add info about update (when updating in filter)

              (search_by_name)     - search by name

              (search_dict)        - search if this dict is a part of the entry

              (ignore_case)        - ignore case when searching!

              (print_time)         - if 'yes', print elapsed time at the end

              (do_not_add_to_lst)  - if 'yes', do not add entries to lst

              (time_out)           - in secs, default=30 (if -1, no timeout)

              (limit_size)         - if !='' limit size

              (print_full)         - if 'yes', show CID (repo_uoa:module_uoa:data_uoa)
                  or
              (all)

              (print_uid)          - if 'yes', print UID in brackets

              (print_name)         - if 'yes', print name (and add info to the list)
                  or
              (name)

              (add_info)           - if 'yes', add info about entry to the list
              (add_meta)           - if 'yes', add meta about entry to the list
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path' (,info) 
                               }]

              elapsed_time - elapsed time in string

              (timed_out)  - if 'yes', timed out or limited by size
            }

    """"""

    import time
    start_time = time.time()

    xls=i.get('limit_size','')
    if xls=='': xls='0'
    ls=int(xls)
    ils=0

    lst=[]

    o=i.get('out','')

    debug=(cfg.get('debug','').lower()=='yes' or cfg.get('debug','').lower()=='1')

    iu=i.get('ignore_update', '')

    prf=i.get('print_full','')
    if prf=='': prf=i.get('all','')
    iprf=(prf=='yes')

    prn=i.get('print_name','')
    if prn=='': prn=i.get('name','')
    iprn=(prn=='yes')

    ipru=(i.get('print_uid','')=='yes')

    # Add info about entry to the final list 
    # (particularly when searching by special keywords, 
    # such as name or date of creation

    iaf=(i.get('add_info','')=='yes')

    iam=(i.get('add_meta','')=='yes')

    aidb=i.get('add_if_date_before','')
    aida=i.get('add_if_date_after','')
    aid=i.get('add_if_date','')

    # Support ISO and human readable time
    aidb=aidb.strip().replace(' ','T')
    aida=aida.strip().replace(' ','T')
    aid=aid.strip().replace(' ','T')

    oaidb=None
    oaida=None
    oaid=None

    sn=i.get('search_by_name','')

    if aidb!='' or aida!='' or aid!='':

       import datetime
       if aidb!='': 
          rx=convert_iso_time({'iso_datetime':aidb})
          if rx['return']>0: return rx
          oaidb=rx['datetime_obj']
       if aida!='': 
          rx=convert_iso_time({'iso_datetime':aida})
          if rx['return']>0: return rx
          oaida=rx['datetime_obj']
       if aid!='':  
          rx=convert_iso_time({'iso_datetime':aid})
          if rx['return']>0: return rx
          oaid=rx['datetime_obj']

    if oaidb!=None or oaida!=None or oaid!=None or sn!='': 
       iaf=True

    dnatl=i.get('do_not_add_to_lst','')
    idnatl=False
    if dnatl=='yes': idnatl=True

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    muid=i.get('module_uid','')
    duoa=i.get('data_uoa','')

    lruoa=i.get('repo_uoa_list',[])
    lmuoa=i.get('module_uoa_list',[])
    lduoa=i.get('data_uoa_list',[])

    to=float(i.get('time_out','30'))
    elapsed_time=0

    if duoa=='': duoa='*'
    if muoa=='' and muid=='': muoa='*'
    if ruoa=='': ruoa='*'

    sff=i.get('filter_func','')
    ff=i.get('filter_func_addr',None)
    if sff!='':
       ff=getattr(sys.modules[__name__], sff)
    if ff!=None:
       sd=i.get('search_dict',{})
       ic=i.get('ignore_case','')
       ss=i.get('search_string','')
       if ic=='yes': ss=ss.lower()

    # Check if wild cards present (only repo or data)
    wr=''
    wm=''
    wd=''

    if ruoa.find('*')>=0 or ruoa.find('?')>=0: wr=ruoa
    if muoa.find('*')>=0 or muoa.find('?')>=0: wm=muoa
    if duoa.find('*')>=0 or duoa.find('?')>=0: wd=duoa

    if wr!='' or wm!='' or wd!='':
       import fnmatch

    zr={}

    fixed_repo=False
    if ruoa!='' and wr=='':
       # Try to load a given repository
       r=access({'action':'load',
                 'module_uoa':cfg['repo_name'],
                 'data_uoa':ruoa,
                 'common_func':'yes'})
       if r['return']>0: return r
       duid=r['data_uid']

       zr[duid]=r
       fixed_repo=True
    else:
       # Prepare all repositories
       r=reload_repo_cache({}) # Ignore errors
       if r['return']>0: return r
       zr=cache_repo_info 

    # Start iterating over repositories
    ir=0
    iir=True
    zrk=list(zr.keys())
    lr=len(zrk)
    finish=False
    while iir:
       skip=False
       if fixed_repo:
          if ir>0:
             skip=True
             iir=False
          else:
             ruid=zrk[0]
             d=zr[ruid]
             dd=d.get('dict',{})
             remote=dd.get('remote','')
             if remote=='yes':
                skip=True
             else:
                ruoa=d.get('data_uoa','')
                p=dd.get('path','')
                if ruid==cfg['repo_uid_default']: p=work.get('dir_default_repo','')
                elif ruid==cfg['repo_uid_local']: p=work.get('dir_local_repo','')
       elif ir==0:
          ruoa=cfg['repo_name_default']
          ruid=cfg['repo_uid_default']
          p=work.get('dir_default_repo','')
       elif ir==1:
          ruoa=cfg['repo_name_local']
          ruid=cfg['repo_uid_local']
          p=work.get('dir_local_repo','')
          if p=='': 
             skip=True
       else:
          if ir<lr+2:
             ruid=zrk[ir-2]
             d=zr[ruid]
             dd=d.get('dict',{})
             remote=dd.get('remote','')
             if remote=='yes':
                skip=True
             else:
                ruoa=d.get('data_uoa','')
                p=dd.get('path','')
          else:
             skip=True
             iir=False

       # Check if wild cards
       if not skip and p!='' and wr!='':
          if len(lruoa)>0 and (ruoa not in lruoa and ruid not in lruoa):
             skip=True
          elif wr=='*':
             pass
          elif is_uid(ruoa): 
             skip=True # If have wildcards, but not alias
          elif not fnmatch.fnmatch(ruoa, wr):
             skip=True

       # Check if got proper path
       if not skip and p!='':
          # Prepare modules in the current directory
          xm=[]

          if muoa!='' and wm=='': 
             xm.append(muoa)
          else:   
             # Now iterate over modules inside a given path
             try:
                lm=os.listdir(p)
             except Exception as e:
                None
             else:
                for fn in lm:
                    if os.path.isdir(os.path.join(p,fn)) and fn not in cfg['special_directories']:
                       xm.append(fn)

          # Iterate over modules
          for mu in xm:
              r=find_path_to_entry({'path':p, 'data_uoa':mu})
              if r['return']==0:
                 mp=r['path']
                 muid=r['data_uid']
                 muoa=r['data_uoa']

                 mskip=False

                 if wm!='':
                    if len(lmuoa)>0 and (muoa not in lmuoa and muid not in lmuoa):
                       mskip=True
                    elif wm=='*':
                       pass
                    elif is_uid(muoa): 
                       mskip=True # If have wildcards, but not alias
                    elif not fnmatch.fnmatch(muoa, wm):
                       mskip=True

                 if not mskip:
                    # Prepare data in the current directory
                    xd=[]

                    if duoa!='' and wd=='': 
                       r=find_path_to_entry({'path':mp, 'data_uoa':duoa})
                       if r['return']==0:
                          xd.append(duoa)
                    else:   
                       # Now iterate over data inside a given path
                       try:
                          ld=os.listdir(mp)
                       except Exception as e:
                          None
                       else:
                          for fn in ld:
                              if os.path.isdir(os.path.join(mp,fn)) and fn not in cfg['special_directories']:
                                 xd.append(fn)

                    # Iterate over data
                    if len(lduoa)>0:
                       xd=lduoa

                    for du in xd:
                        r=find_path_to_entry({'path':mp, 'data_uoa':du})
                        if r['return']!=0: continue

                        dp=r['path']
                        dpcfg=os.path.join(dp,cfg['subdir_ck_ext'])
                        dpinfo=os.path.join(dp,cfg['subdir_ck_ext'],cfg['file_info'])
                        dpmeta=os.path.join(dp,cfg['subdir_ck_ext'],cfg['file_meta'])
                        tduid=r['data_uid']
                        tduoa=r['data_uoa']

                        if os.path.isdir(dpcfg): # Check if really CK data entry
                           dskip=False

                           if wd!='':
                              if len(lduoa)>0 and (tduoa not in lduoa and tduid not in lduoa):
                                 dskip=True
                              elif wd=='*':
                                 pass
                              elif is_uid(tduoa): 
                                 dskip=True # If have wildcards, but not alias
                              elif not fnmatch.fnmatch(tduoa, wd):
                                 dskip=True

                           if not dskip:
                              # Iterate over data 
                              ll={'repo_uoa':ruoa, 'repo_uid':ruid,
                                 'module_uoa':muoa, 'module_uid':muid,
                                 'data_uoa':tduoa, 'data_uid':tduid,
                                 'path':dp}

                              # Need to load info?
                              if iaf or iprn:
                                 if os.path.isfile(dpinfo):
                                    y=load_json_file({'json_file':dpinfo})
                                    if y['return']>0: 
                                       if not debug: continue
                                       return y
                                    ll['info']=y['dict']

                              # Need to load meta?
                              if iam:
                                 if os.path.isfile(dpmeta):
                                    y=load_json_file({'json_file':dpmeta})
                                    if y['return']>0: 
                                       if not debug: continue
                                       return y
                                    ll['meta']=y['dict']

                              # Call filter
                              fskip=False

                              if ff!=None and ff!='':
                                 ll['out']=o
                                 ll['search_dict']=sd
                                 ll['search_string']=ss
                                 ll['ignore_case']=ic
                                 ll['ignore_update']=iu

                                 if oaidb!=None: ll['obj_date_before']=oaidb
                                 if oaida!=None: ll['obj_date_after']=oaida
                                 if oaid!=None: ll['obj_date']=oaid
                                 if sn!=None: ll['search_by_name']=sn

                                 rx=ff(ll)
                                 if rx['return']>0: 
                                    if not debug: continue
                                    return rx

                                 if rx.get('skip','')=='yes':
                                    fskip=True

                              # Append
                              if not fskip:
                                 ils+=1
 
                                 if not idnatl:
                                    lst.append(ll)

                                 if o=='con':
                                    x=''
                                    if iprf: x=ruoa+':'+muoa+':'
                                    if sys.version_info[0]<3: 
                                       y=tduoa
                                       try: y=y.decode(sys.stdin.encoding)
                                       except Exception as e: 
                                         try: y=y.decode('utf8')
                                         except Exception as e: pass
                                       x+=y
                                    else: x+=tduoa
                                    if ipru: x+=' ('+tduid+')'
                                    if iprn:
                                       name=ll.get('info',{}).get('data_name','')
                                       if name!='':
                                          x=name+' ('+x+')'
                                    out(x)

                              # Check timeout
                              elapsed_time = time.time() - start_time
                              if to!=-1 and elapsed_time>to:
                                 finish=True
                                 break

                              # Check size
                              if ls>0 and ils==ls:
                                 finish=True
                                 break

                    if finish: break
          if finish: break

       # Finish iteration over repositories
       ir+=1

    if o=='con' and i.get('print_time','')=='yes':
       out('Elapsed time: '+str(elapsed_time)+' sec., number of entries: '+str(ils))

    rr={'return':0, 'lst':lst, 'elapsed_time':str(elapsed_time)}
    if finish: rr['timed_out']='yes'

    return rr",python,"def list_data(i):
    """"""
    Input:  {
              (repo_uoa)           - repo UOA
              (module_uoa)         - module UOA
              (data_uoa)           - data UOA

              (repo_uoa_list)      - list of repos to search
              (module_uoa_list)    - list of module to search
              (data_uoa_list)      - list of data to search

              (filter_func)        - name of filter function
              (filter_func_addr)   - address of filter function

              (add_if_date_before) - add only entries with date before this date 
              (add_if_date_after)  - add only entries with date after this date
              (add_if_date)        - add only entries with this date

              (ignore_update)      - if 'yes', do not add info about update (when updating in filter)

              (search_by_name)     - search by name

              (search_dict)        - search if this dict is a part of the entry

              (ignore_case)        - ignore case when searching!

              (print_time)         - if 'yes', print elapsed time at the end

              (do_not_add_to_lst)  - if 'yes', do not add entries to lst

              (time_out)           - in secs, default=30 (if -1, no timeout)

              (limit_size)         - if !='' limit size

              (print_full)         - if 'yes', show CID (repo_uoa:module_uoa:data_uoa)
                  or
              (all)

              (print_uid)          - if 'yes', print UID in brackets

              (print_name)         - if 'yes', print name (and add info to the list)
                  or
              (name)

              (add_info)           - if 'yes', add info about entry to the list
              (add_meta)           - if 'yes', add meta about entry to the list
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path' (,info) 
                               }]

              elapsed_time - elapsed time in string

              (timed_out)  - if 'yes', timed out or limited by size
            }

    """"""

    import time
    start_time = time.time()

    xls=i.get('limit_size','')
    if xls=='': xls='0'
    ls=int(xls)
    ils=0

    lst=[]

    o=i.get('out','')

    debug=(cfg.get('debug','').lower()=='yes' or cfg.get('debug','').lower()=='1')

    iu=i.get('ignore_update', '')

    prf=i.get('print_full','')
    if prf=='': prf=i.get('all','')
    iprf=(prf=='yes')

    prn=i.get('print_name','')
    if prn=='': prn=i.get('name','')
    iprn=(prn=='yes')

    ipru=(i.get('print_uid','')=='yes')

    # Add info about entry to the final list 
    # (particularly when searching by special keywords, 
    # such as name or date of creation

    iaf=(i.get('add_info','')=='yes')

    iam=(i.get('add_meta','')=='yes')

    aidb=i.get('add_if_date_before','')
    aida=i.get('add_if_date_after','')
    aid=i.get('add_if_date','')

    # Support ISO and human readable time
    aidb=aidb.strip().replace(' ','T')
    aida=aida.strip().replace(' ','T')
    aid=aid.strip().replace(' ','T')

    oaidb=None
    oaida=None
    oaid=None

    sn=i.get('search_by_name','')

    if aidb!='' or aida!='' or aid!='':

       import datetime
       if aidb!='': 
          rx=convert_iso_time({'iso_datetime':aidb})
          if rx['return']>0: return rx
          oaidb=rx['datetime_obj']
       if aida!='': 
          rx=convert_iso_time({'iso_datetime':aida})
          if rx['return']>0: return rx
          oaida=rx['datetime_obj']
       if aid!='':  
          rx=convert_iso_time({'iso_datetime':aid})
          if rx['return']>0: return rx
          oaid=rx['datetime_obj']

    if oaidb!=None or oaida!=None or oaid!=None or sn!='': 
       iaf=True

    dnatl=i.get('do_not_add_to_lst','')
    idnatl=False
    if dnatl=='yes': idnatl=True

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    muid=i.get('module_uid','')
    duoa=i.get('data_uoa','')

    lruoa=i.get('repo_uoa_list',[])
    lmuoa=i.get('module_uoa_list',[])
    lduoa=i.get('data_uoa_list',[])

    to=float(i.get('time_out','30'))
    elapsed_time=0

    if duoa=='': duoa='*'
    if muoa=='' and muid=='': muoa='*'
    if ruoa=='': ruoa='*'

    sff=i.get('filter_func','')
    ff=i.get('filter_func_addr',None)
    if sff!='':
       ff=getattr(sys.modules[__name__], sff)
    if ff!=None:
       sd=i.get('search_dict',{})
       ic=i.get('ignore_case','')
       ss=i.get('search_string','')
       if ic=='yes': ss=ss.lower()

    # Check if wild cards present (only repo or data)
    wr=''
    wm=''
    wd=''

    if ruoa.find('*')>=0 or ruoa.find('?')>=0: wr=ruoa
    if muoa.find('*')>=0 or muoa.find('?')>=0: wm=muoa
    if duoa.find('*')>=0 or duoa.find('?')>=0: wd=duoa

    if wr!='' or wm!='' or wd!='':
       import fnmatch

    zr={}

    fixed_repo=False
    if ruoa!='' and wr=='':
       # Try to load a given repository
       r=access({'action':'load',
                 'module_uoa':cfg['repo_name'],
                 'data_uoa':ruoa,
                 'common_func':'yes'})
       if r['return']>0: return r
       duid=r['data_uid']

       zr[duid]=r
       fixed_repo=True
    else:
       # Prepare all repositories
       r=reload_repo_cache({}) # Ignore errors
       if r['return']>0: return r
       zr=cache_repo_info 

    # Start iterating over repositories
    ir=0
    iir=True
    zrk=list(zr.keys())
    lr=len(zrk)
    finish=False
    while iir:
       skip=False
       if fixed_repo:
          if ir>0:
             skip=True
             iir=False
          else:
             ruid=zrk[0]
             d=zr[ruid]
             dd=d.get('dict',{})
             remote=dd.get('remote','')
             if remote=='yes':
                skip=True
             else:
                ruoa=d.get('data_uoa','')
                p=dd.get('path','')
                if ruid==cfg['repo_uid_default']: p=work.get('dir_default_repo','')
                elif ruid==cfg['repo_uid_local']: p=work.get('dir_local_repo','')
       elif ir==0:
          ruoa=cfg['repo_name_default']
          ruid=cfg['repo_uid_default']
          p=work.get('dir_default_repo','')
       elif ir==1:
          ruoa=cfg['repo_name_local']
          ruid=cfg['repo_uid_local']
          p=work.get('dir_local_repo','')
          if p=='': 
             skip=True
       else:
          if ir<lr+2:
             ruid=zrk[ir-2]
             d=zr[ruid]
             dd=d.get('dict',{})
             remote=dd.get('remote','')
             if remote=='yes':
                skip=True
             else:
                ruoa=d.get('data_uoa','')
                p=dd.get('path','')
          else:
             skip=True
             iir=False

       # Check if wild cards
       if not skip and p!='' and wr!='':
          if len(lruoa)>0 and (ruoa not in lruoa and ruid not in lruoa):
             skip=True
          elif wr=='*':
             pass
          elif is_uid(ruoa): 
             skip=True # If have wildcards, but not alias
          elif not fnmatch.fnmatch(ruoa, wr):
             skip=True

       # Check if got proper path
       if not skip and p!='':
          # Prepare modules in the current directory
          xm=[]

          if muoa!='' and wm=='': 
             xm.append(muoa)
          else:   
             # Now iterate over modules inside a given path
             try:
                lm=os.listdir(p)
             except Exception as e:
                None
             else:
                for fn in lm:
                    if os.path.isdir(os.path.join(p,fn)) and fn not in cfg['special_directories']:
                       xm.append(fn)

          # Iterate over modules
          for mu in xm:
              r=find_path_to_entry({'path':p, 'data_uoa':mu})
              if r['return']==0:
                 mp=r['path']
                 muid=r['data_uid']
                 muoa=r['data_uoa']

                 mskip=False

                 if wm!='':
                    if len(lmuoa)>0 and (muoa not in lmuoa and muid not in lmuoa):
                       mskip=True
                    elif wm=='*':
                       pass
                    elif is_uid(muoa): 
                       mskip=True # If have wildcards, but not alias
                    elif not fnmatch.fnmatch(muoa, wm):
                       mskip=True

                 if not mskip:
                    # Prepare data in the current directory
                    xd=[]

                    if duoa!='' and wd=='': 
                       r=find_path_to_entry({'path':mp, 'data_uoa':duoa})
                       if r['return']==0:
                          xd.append(duoa)
                    else:   
                       # Now iterate over data inside a given path
                       try:
                          ld=os.listdir(mp)
                       except Exception as e:
                          None
                       else:
                          for fn in ld:
                              if os.path.isdir(os.path.join(mp,fn)) and fn not in cfg['special_directories']:
                                 xd.append(fn)

                    # Iterate over data
                    if len(lduoa)>0:
                       xd=lduoa

                    for du in xd:
                        r=find_path_to_entry({'path':mp, 'data_uoa':du})
                        if r['return']!=0: continue

                        dp=r['path']
                        dpcfg=os.path.join(dp,cfg['subdir_ck_ext'])
                        dpinfo=os.path.join(dp,cfg['subdir_ck_ext'],cfg['file_info'])
                        dpmeta=os.path.join(dp,cfg['subdir_ck_ext'],cfg['file_meta'])
                        tduid=r['data_uid']
                        tduoa=r['data_uoa']

                        if os.path.isdir(dpcfg): # Check if really CK data entry
                           dskip=False

                           if wd!='':
                              if len(lduoa)>0 and (tduoa not in lduoa and tduid not in lduoa):
                                 dskip=True
                              elif wd=='*':
                                 pass
                              elif is_uid(tduoa): 
                                 dskip=True # If have wildcards, but not alias
                              elif not fnmatch.fnmatch(tduoa, wd):
                                 dskip=True

                           if not dskip:
                              # Iterate over data 
                              ll={'repo_uoa':ruoa, 'repo_uid':ruid,
                                 'module_uoa':muoa, 'module_uid':muid,
                                 'data_uoa':tduoa, 'data_uid':tduid,
                                 'path':dp}

                              # Need to load info?
                              if iaf or iprn:
                                 if os.path.isfile(dpinfo):
                                    y=load_json_file({'json_file':dpinfo})
                                    if y['return']>0: 
                                       if not debug: continue
                                       return y
                                    ll['info']=y['dict']

                              # Need to load meta?
                              if iam:
                                 if os.path.isfile(dpmeta):
                                    y=load_json_file({'json_file':dpmeta})
                                    if y['return']>0: 
                                       if not debug: continue
                                       return y
                                    ll['meta']=y['dict']

                              # Call filter
                              fskip=False

                              if ff!=None and ff!='':
                                 ll['out']=o
                                 ll['search_dict']=sd
                                 ll['search_string']=ss
                                 ll['ignore_case']=ic
                                 ll['ignore_update']=iu

                                 if oaidb!=None: ll['obj_date_before']=oaidb
                                 if oaida!=None: ll['obj_date_after']=oaida
                                 if oaid!=None: ll['obj_date']=oaid
                                 if sn!=None: ll['search_by_name']=sn

                                 rx=ff(ll)
                                 if rx['return']>0: 
                                    if not debug: continue
                                    return rx

                                 if rx.get('skip','')=='yes':
                                    fskip=True

                              # Append
                              if not fskip:
                                 ils+=1
 
                                 if not idnatl:
                                    lst.append(ll)

                                 if o=='con':
                                    x=''
                                    if iprf: x=ruoa+':'+muoa+':'
                                    if sys.version_info[0]<3: 
                                       y=tduoa
                                       try: y=y.decode(sys.stdin.encoding)
                                       except Exception as e: 
                                         try: y=y.decode('utf8')
                                         except Exception as e: pass
                                       x+=y
                                    else: x+=tduoa
                                    if ipru: x+=' ('+tduid+')'
                                    if iprn:
                                       name=ll.get('info',{}).get('data_name','')
                                       if name!='':
                                          x=name+' ('+x+')'
                                    out(x)

                              # Check timeout
                              elapsed_time = time.time() - start_time
                              if to!=-1 and elapsed_time>to:
                                 finish=True
                                 break

                              # Check size
                              if ls>0 and ils==ls:
                                 finish=True
                                 break

                    if finish: break
          if finish: break

       # Finish iteration over repositories
       ir+=1

    if o=='con' and i.get('print_time','')=='yes':
       out('Elapsed time: '+str(elapsed_time)+' sec., number of entries: '+str(ils))

    rr={'return':0, 'lst':lst, 'elapsed_time':str(elapsed_time)}
    if finish: rr['timed_out']='yes'

    return rr","['def' 'list_data' '(' ... ""'yes'"" 'return' 'rr']","Input:  {
              (repo_uoa)           - repo UOA
              (module_uoa)         - module UOA
              (data_uoa)           - data UOA

              (repo_uoa_list)      - list of repos to search
              (module_uoa_list)    - list of module to search
              (data_uoa_list)      - list of data to search

              (filter_func)        - name of filter function
              (filter_func_addr)   - address of filter function

              (add_if_date_before) - add only entries with date before this date 
              (add_if_date_after)  - add only entries with date after this date
              (add_if_date)        - add only entries with this date

              (ignore_update)      - if 'yes', do not add info about update (when updating in filter)

              (search_by_name)     - search by name

              (search_dict)        - search if this dict is a part of the entry

              (ignore_case)        - ignore case when searching!

              (print_time)         - if 'yes', print elapsed time at the end

              (do_not_add_to_lst)  - if 'yes', do not add entries to lst

              (time_out)           - in secs, default=30 (if -1, no timeout)

              (limit_size)         - if !='' limit size

              (print_full)         - if 'yes', show CID (repo_uoa:module_uoa:data_uoa)
                  or
              (all)

              (print_uid)          - if 'yes', print UID in brackets

              (print_name)         - if 'yes', print name (and add info to the list)
                  or
              (name)

              (add_info)           - if 'yes', add info about entry to the list
              (add_meta)           - if 'yes', add meta about entry to the list
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path' (,info) 
                               }]

              elapsed_time - elapsed time in string

              (timed_out)  - if 'yes', timed out or limited by size
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' '(' 'module_uoa' ')'
 '-' 'module' 'UOA' '(' 'data_uoa' ')' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L7131-L7568
ctuning/ck,ck/kernel.py,search,"def search(i):
    """"""
    Input:  {
              (repo_uoa)           - repo UOA
              (module_uoa)         - module UOA
              (data_uoa)           - data UOA

              (repo_uoa_list)      - list of repos to search
              (module_uoa_list)    - list of module to search
              (data_uoa_list)      - list of data to search

              (add_if_date_before) - add only entries with date before this date 
              (add_if_date_after)  - add only entries with date after this date
              (add_if_date)        - add only entries with this date

              (search_by_name)     - search by name

              (print_time)         - if 'yes', print elapsed time at the end

              (search_flat_dict)   - search if these flat keys/values exist in entries
              (search_dict)        - search if this dict is a part of the entry
              (tags)               - add tags to search in format tags=x,y,z
                   or
              (search_string)      - search with expressions *?

              (ignore_case)        - if 'yes', ignore case of letters

              (time_out)           - in secs, default=30

              (internal)           - if 'yes', use internal search even if indexing is on

              (limit_size)         - by default 5000 or -1 if no limit

              (print_full)         - if 'yes', show CID (repo_uoa:module_uoa:data_uoa)
              (print_uid)          - if 'yes', print UID in brackets

              (print_name)         - if 'yes', print name (and add info to the list)
              (add_info)           - if 'yes', add info about entry to the list
              (add_meta)           - if 'yes', add meta about entry to the list
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path'}]
              elapsed_time - elapsed time in string

              (timed_out)  - if 'yes', timed out
            }

    """"""
    o=i.get('out','')
    ss=i.get('search_string','')
    ls=i.get('limit_size','5000')

    rr={'return':0}

    sd=i.get('search_dict',{})

    tags=i.get('tags','')
    if tags!='':
       xtags=tags.split(',')
       xtags1=[]
       for q in xtags:
           xtags1.append(q.strip())
       sd['tags']=xtags1

    # Check if index
    if cfg.get('use_indexing','')!='yes' or i.get('internal','')=='yes':
       if ss!='':
          i['filter_func']='search_string_filter'
       else:
          sfd=i.get('search_flat_dict',{})

          if len(sfd)>0:
             r=restore_flattened_dict({'dict':sfd})
             if r['return']>0: return r

             nd=r['dict']

             sd.update(nd)

             del (i['search_flat_dict'])

          i['filter_func']='search_filter'

       i['search_dict']=sd

       pf=i.get('print_full','')
       if pf=='': pf='yes'
       i['print_full']=pf

       rr=list_data(i)
    else:
       import time
       start_time = time.time()

       dss={}

       ruoa=i.get('repo_uoa','')
       muoa=i.get('module_uoa','')
       duoa=i.get('data_uoa','')

       lruoa=i.get('repo_uoa_list',[])
       lmuoa=i.get('module_uoa_list',[])
       lduoa=i.get('data_uoa_list',[])

       if ruoa!='': lruoa.append(ruoa)
       if muoa!='': lmuoa.append(muoa)
       if duoa!='': lduoa.append(duoa)

       if len(lruoa)>0:
          if ss!='': ss+=' AND '
          ss+=' ('
          first=True
          for x in lruoa:
              if first: first=False
              else: ss+=' OR '
              ss+='(repo_uid:""'+x+'"") OR (repo_uoa:""'+x+'"")'
          ss+=')'

       if len(lmuoa)>0:
          if ss!='': ss+=' AND '
          ss+='('
          first=True
          for x in lmuoa:
              if first: first=False
              else: ss+=' OR '
              ss+='(module_uid:""'+x+'"") OR (module_uoa:""'+x+'"")'
          ss+=')'

       if len(lduoa)>0:
          if ss!='': ss+=' AND '
          ss+='('
          first=True
          for x in lduoa:
              if first: first=False
              else: ss+=' OR '
              ss+='(data_uid:""'+x+'"") OR (data_uoa:""'+x+'"")'
          ss+=')'

       # Check search keys
       first=True
       for u in sd:
           v=sd[u]
           if first: 
              first=False
              if ss=='': ss+='('
              else: ss+=' AND ('
           else: 
              ss+=' AND '
           if type(v)==list:
              first1=True
              for lk in v:
                  if first1:
                     first1=False
                  else:
                     ss+=' AND '
                  ss+=u+':""'+str(lk)+'""'
           else:
              ss+=u+':""'+v+'""'

       # Check special parameters
       aidb=i.get('add_if_date_before','')
       aida=i.get('add_if_date_after','')
       aid=i.get('add_if_date','')

       # Support ISO and human readable time
       aidb=aidb.strip().replace(' ','T')
       aida=aida.strip().replace(' ','T')
       aid=aid.strip().replace(' ','T')

       sn=i.get('search_by_name','')

       if sn!='':
          if first: 
             first=False
             if ss=='': ss+='('
             else: ss+=' AND ('
          else: 
             ss+=' AND '

          if sn.find('*')<0 and sn.find('?')<0:
             ss+='data_name:""'+sn+'""'
          else:
             ss+='data_name:'+sn+''

       if aidb!='' or aida!='' or aid!='':
          if first: 
             first=False
             if ss=='': ss+='('
             else: ss+=' AND ('
          else: 
             ss+=' AND '

          ss+='iso_datetime:'
          if aid!='': ss+='""'+aid+'""'
          else:
             ss+='['
             if aida!='': 
                ss+='""'+aida+'""'
             else:
                ss+='*'
             if aidb!='':
                ss+=' TO ""'+aidb+'""'
             ss+='] '

       # Finish query
       if not first:
          ss+=')'

       # Prepare ElasticSearch query
       import urllib

       path='/_search?'
       if ss!='': path+='q='+urllib.quote_plus(ss.encode('utf-8'))
       if ls!='': path+='&size='+ls

#       dss={'query':{'filtered':{'filter':{'terms':sd}}}}
       dss={}

       ri=access_index_server({'request':'GET', 'path':path, 'dict':dss})
       if ri['return']>0: return ri

       dd=ri['dict'].get('hits',{}).get('hits',[])

       lst=[]
       for qx in dd:
           q=qx.get('_source',{})
           ruoa=q.get('repo_uoa','')
           ruid=q.get('repo_uid','')
           muoa=q.get('module_uoa','')
           muid=q.get('module_uid','')
           duoa=q.get('data_uoa','')
           duid=q.get('data_uid','')
           path=q.get('path','')

           lst.append({'repo_uoa':ruoa, 'repo_uid':ruid,
              'module_uoa':muoa, 'module_uid':muid,
              'data_uoa':duoa, 'data_uid':duid,
              'path':path})

           if o=='con':
              x=ruoa+':'+muoa+':'
              if sys.version_info[0]<3: 
                 y=duoa
                 try: y=y.decode(sys.stdin.encoding)
                 except Exception as e: 
                   try: y=y.decode('utf8')
                   except Exception as e: pass
                 x+=y
              else: x+=duoa
              out(x)

       rr['lst']=lst
       rr['elapsed_time']=str(time.time() - start_time)

       if o=='con' and i.get('print_time','')=='yes':
          out('Elapsed time: '+rr['elapsed_time']+' sec., number of entries: '+str(len(lst)))

    return rr",python,"def search(i):
    """"""
    Input:  {
              (repo_uoa)           - repo UOA
              (module_uoa)         - module UOA
              (data_uoa)           - data UOA

              (repo_uoa_list)      - list of repos to search
              (module_uoa_list)    - list of module to search
              (data_uoa_list)      - list of data to search

              (add_if_date_before) - add only entries with date before this date 
              (add_if_date_after)  - add only entries with date after this date
              (add_if_date)        - add only entries with this date

              (search_by_name)     - search by name

              (print_time)         - if 'yes', print elapsed time at the end

              (search_flat_dict)   - search if these flat keys/values exist in entries
              (search_dict)        - search if this dict is a part of the entry
              (tags)               - add tags to search in format tags=x,y,z
                   or
              (search_string)      - search with expressions *?

              (ignore_case)        - if 'yes', ignore case of letters

              (time_out)           - in secs, default=30

              (internal)           - if 'yes', use internal search even if indexing is on

              (limit_size)         - by default 5000 or -1 if no limit

              (print_full)         - if 'yes', show CID (repo_uoa:module_uoa:data_uoa)
              (print_uid)          - if 'yes', print UID in brackets

              (print_name)         - if 'yes', print name (and add info to the list)
              (add_info)           - if 'yes', add info about entry to the list
              (add_meta)           - if 'yes', add meta about entry to the list
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path'}]
              elapsed_time - elapsed time in string

              (timed_out)  - if 'yes', timed out
            }

    """"""
    o=i.get('out','')
    ss=i.get('search_string','')
    ls=i.get('limit_size','5000')

    rr={'return':0}

    sd=i.get('search_dict',{})

    tags=i.get('tags','')
    if tags!='':
       xtags=tags.split(',')
       xtags1=[]
       for q in xtags:
           xtags1.append(q.strip())
       sd['tags']=xtags1

    # Check if index
    if cfg.get('use_indexing','')!='yes' or i.get('internal','')=='yes':
       if ss!='':
          i['filter_func']='search_string_filter'
       else:
          sfd=i.get('search_flat_dict',{})

          if len(sfd)>0:
             r=restore_flattened_dict({'dict':sfd})
             if r['return']>0: return r

             nd=r['dict']

             sd.update(nd)

             del (i['search_flat_dict'])

          i['filter_func']='search_filter'

       i['search_dict']=sd

       pf=i.get('print_full','')
       if pf=='': pf='yes'
       i['print_full']=pf

       rr=list_data(i)
    else:
       import time
       start_time = time.time()

       dss={}

       ruoa=i.get('repo_uoa','')
       muoa=i.get('module_uoa','')
       duoa=i.get('data_uoa','')

       lruoa=i.get('repo_uoa_list',[])
       lmuoa=i.get('module_uoa_list',[])
       lduoa=i.get('data_uoa_list',[])

       if ruoa!='': lruoa.append(ruoa)
       if muoa!='': lmuoa.append(muoa)
       if duoa!='': lduoa.append(duoa)

       if len(lruoa)>0:
          if ss!='': ss+=' AND '
          ss+=' ('
          first=True
          for x in lruoa:
              if first: first=False
              else: ss+=' OR '
              ss+='(repo_uid:""'+x+'"") OR (repo_uoa:""'+x+'"")'
          ss+=')'

       if len(lmuoa)>0:
          if ss!='': ss+=' AND '
          ss+='('
          first=True
          for x in lmuoa:
              if first: first=False
              else: ss+=' OR '
              ss+='(module_uid:""'+x+'"") OR (module_uoa:""'+x+'"")'
          ss+=')'

       if len(lduoa)>0:
          if ss!='': ss+=' AND '
          ss+='('
          first=True
          for x in lduoa:
              if first: first=False
              else: ss+=' OR '
              ss+='(data_uid:""'+x+'"") OR (data_uoa:""'+x+'"")'
          ss+=')'

       # Check search keys
       first=True
       for u in sd:
           v=sd[u]
           if first: 
              first=False
              if ss=='': ss+='('
              else: ss+=' AND ('
           else: 
              ss+=' AND '
           if type(v)==list:
              first1=True
              for lk in v:
                  if first1:
                     first1=False
                  else:
                     ss+=' AND '
                  ss+=u+':""'+str(lk)+'""'
           else:
              ss+=u+':""'+v+'""'

       # Check special parameters
       aidb=i.get('add_if_date_before','')
       aida=i.get('add_if_date_after','')
       aid=i.get('add_if_date','')

       # Support ISO and human readable time
       aidb=aidb.strip().replace(' ','T')
       aida=aida.strip().replace(' ','T')
       aid=aid.strip().replace(' ','T')

       sn=i.get('search_by_name','')

       if sn!='':
          if first: 
             first=False
             if ss=='': ss+='('
             else: ss+=' AND ('
          else: 
             ss+=' AND '

          if sn.find('*')<0 and sn.find('?')<0:
             ss+='data_name:""'+sn+'""'
          else:
             ss+='data_name:'+sn+''

       if aidb!='' or aida!='' or aid!='':
          if first: 
             first=False
             if ss=='': ss+='('
             else: ss+=' AND ('
          else: 
             ss+=' AND '

          ss+='iso_datetime:'
          if aid!='': ss+='""'+aid+'""'
          else:
             ss+='['
             if aida!='': 
                ss+='""'+aida+'""'
             else:
                ss+='*'
             if aidb!='':
                ss+=' TO ""'+aidb+'""'
             ss+='] '

       # Finish query
       if not first:
          ss+=')'

       # Prepare ElasticSearch query
       import urllib

       path='/_search?'
       if ss!='': path+='q='+urllib.quote_plus(ss.encode('utf-8'))
       if ls!='': path+='&size='+ls

#       dss={'query':{'filtered':{'filter':{'terms':sd}}}}
       dss={}

       ri=access_index_server({'request':'GET', 'path':path, 'dict':dss})
       if ri['return']>0: return ri

       dd=ri['dict'].get('hits',{}).get('hits',[])

       lst=[]
       for qx in dd:
           q=qx.get('_source',{})
           ruoa=q.get('repo_uoa','')
           ruid=q.get('repo_uid','')
           muoa=q.get('module_uoa','')
           muid=q.get('module_uid','')
           duoa=q.get('data_uoa','')
           duid=q.get('data_uid','')
           path=q.get('path','')

           lst.append({'repo_uoa':ruoa, 'repo_uid':ruid,
              'module_uoa':muoa, 'module_uid':muid,
              'data_uoa':duoa, 'data_uid':duid,
              'path':path})

           if o=='con':
              x=ruoa+':'+muoa+':'
              if sys.version_info[0]<3: 
                 y=duoa
                 try: y=y.decode(sys.stdin.encoding)
                 except Exception as e: 
                   try: y=y.decode('utf8')
                   except Exception as e: pass
                 x+=y
              else: x+=duoa
              out(x)

       rr['lst']=lst
       rr['elapsed_time']=str(time.time() - start_time)

       if o=='con' and i.get('print_time','')=='yes':
          out('Elapsed time: '+rr['elapsed_time']+' sec., number of entries: '+str(len(lst)))

    return rr",['def' 'search' '(' ... ')' 'return' 'rr'],"Input:  {
              (repo_uoa)           - repo UOA
              (module_uoa)         - module UOA
              (data_uoa)           - data UOA

              (repo_uoa_list)      - list of repos to search
              (module_uoa_list)    - list of module to search
              (data_uoa_list)      - list of data to search

              (add_if_date_before) - add only entries with date before this date 
              (add_if_date_after)  - add only entries with date after this date
              (add_if_date)        - add only entries with this date

              (search_by_name)     - search by name

              (print_time)         - if 'yes', print elapsed time at the end

              (search_flat_dict)   - search if these flat keys/values exist in entries
              (search_dict)        - search if this dict is a part of the entry
              (tags)               - add tags to search in format tags=x,y,z
                   or
              (search_string)      - search with expressions *?

              (ignore_case)        - if 'yes', ignore case of letters

              (time_out)           - in secs, default=30

              (internal)           - if 'yes', use internal search even if indexing is on

              (limit_size)         - by default 5000 or -1 if no limit

              (print_full)         - if 'yes', show CID (repo_uoa:module_uoa:data_uoa)
              (print_uid)          - if 'yes', print UID in brackets

              (print_name)         - if 'yes', print name (and add info to the list)
              (add_info)           - if 'yes', add info about entry to the list
              (add_meta)           - if 'yes', add meta about entry to the list
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path'}]
              elapsed_time - elapsed time in string

              (timed_out)  - if 'yes', timed out
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' '(' 'module_uoa' ')'
 '-' 'module' 'UOA' '(' 'data_uoa' ')' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L7575-L7840
ctuning/ck,ck/kernel.py,search_filter,"def search_filter(i):
    """"""
    Input:  {
              repo_uoa             - repo UOA
              module_uoa           - module UOA
              data_uoa             - data UOA
              path                 - path  

              (search_dict)        - search if this dict is a part of the entry
              (ignore_case)        - if 'yes', ignore case of letters
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path'}]
            }

    """"""

    ic=i.get('ignore_case','')

    # Check special info
    info=i.get('info',{})
    if len(info)!='':
       oaidb=i.get('obj_date_before', None)
       oaida=i.get('obj_date_after', None)
       oaid=i.get('obj_date', None)
       sn=i.get('search_by_name','')

       # Check dates
       if oaidb!=None or oaida!=None or oaid!=None:
          idt=info.get('control',{}).get('iso_datetime','')
          if idt!='':
             rx=convert_iso_time({'iso_datetime':idt})
             if rx['return']>0: return rx
             oidt=rx['datetime_obj']

             if oaidb!=None and oidt>oaidb: return {'return':0, 'skip':'yes'}
             if oaida!=None and oidt<oaida: return {'return':0, 'skip':'yes'}
             if oaid!=None and oidt!=oaid: return {'return':0, 'skip':'yes'}

       # Check if search by name
       if sn!='':
          ro=find_string_in_dict_or_list({'dict':{'string':info.get('data_name','')}, 
                                          'search_string':sn,
                                          'ignore_case':ic})
          if ro['return']>0: return ro
          if ro['found']!='yes': return {'return':0, 'skip':'yes'}

    # To be fast, load directly
    p=i['path']

    skip='yes'

    sd=i.get('search_dict',{})

    p1=os.path.join(p,cfg['subdir_ck_ext'],cfg['file_meta'])
    if not os.path.isfile(p1):
       p1=os.path.join(p,cfg['subdir_ck_ext'],cfg['file_meta_old'])
       if not os.path.isfile(p1):
          return {'return':0, 'skip':'yes'}

    r=load_json_file({'json_file':p1})
    if r['return']>0: return r
    d=r['dict']

    # Check directly
    rx=compare_dicts({'dict1':d, 'dict2':sd, 'ignore_case':ic})
    if rx['return']>0: return rx
    equal=rx['equal']
    if equal=='yes': skip='no'

    return {'return':0, 'skip':skip}",python,"def search_filter(i):
    """"""
    Input:  {
              repo_uoa             - repo UOA
              module_uoa           - module UOA
              data_uoa             - data UOA
              path                 - path  

              (search_dict)        - search if this dict is a part of the entry
              (ignore_case)        - if 'yes', ignore case of letters
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path'}]
            }

    """"""

    ic=i.get('ignore_case','')

    # Check special info
    info=i.get('info',{})
    if len(info)!='':
       oaidb=i.get('obj_date_before', None)
       oaida=i.get('obj_date_after', None)
       oaid=i.get('obj_date', None)
       sn=i.get('search_by_name','')

       # Check dates
       if oaidb!=None or oaida!=None or oaid!=None:
          idt=info.get('control',{}).get('iso_datetime','')
          if idt!='':
             rx=convert_iso_time({'iso_datetime':idt})
             if rx['return']>0: return rx
             oidt=rx['datetime_obj']

             if oaidb!=None and oidt>oaidb: return {'return':0, 'skip':'yes'}
             if oaida!=None and oidt<oaida: return {'return':0, 'skip':'yes'}
             if oaid!=None and oidt!=oaid: return {'return':0, 'skip':'yes'}

       # Check if search by name
       if sn!='':
          ro=find_string_in_dict_or_list({'dict':{'string':info.get('data_name','')}, 
                                          'search_string':sn,
                                          'ignore_case':ic})
          if ro['return']>0: return ro
          if ro['found']!='yes': return {'return':0, 'skip':'yes'}

    # To be fast, load directly
    p=i['path']

    skip='yes'

    sd=i.get('search_dict',{})

    p1=os.path.join(p,cfg['subdir_ck_ext'],cfg['file_meta'])
    if not os.path.isfile(p1):
       p1=os.path.join(p,cfg['subdir_ck_ext'],cfg['file_meta_old'])
       if not os.path.isfile(p1):
          return {'return':0, 'skip':'yes'}

    r=load_json_file({'json_file':p1})
    if r['return']>0: return r
    d=r['dict']

    # Check directly
    rx=compare_dicts({'dict1':d, 'dict2':sd, 'ignore_case':ic})
    if rx['return']>0: return rx
    equal=rx['equal']
    if equal=='yes': skip='no'

    return {'return':0, 'skip':skip}","['def' 'search_filter' '(' 'i' ')' ':' 'ic' '=' 'i' '.' 'get' '('
 ""'ignore_case'"" ',' ""''"" ')' '# Check special info' 'info' '=' 'i' '.'
 'get' '(' ""'info'"" ',' '{' '}' ')' 'if' 'len' '(' 'info' ')' '!=' ""''""
 ':' 'oaidb' '=' 'i' '.' 'get' '(' ""'obj_date_before'"" ',' 'None' ')'
 'oaida' '=' 'i' '.' 'get' '(' ""'obj_date_after'"" ',' 'None' ')' 'oaid'
 '=' 'i' '.' 'get' '(' ""'obj_date'"" ',' 'None' ')' 'sn' '=' 'i' '.' 'get'
 '(' ""'search_by_name'"" ',' ""''"" ')' '# Check dates' 'if' 'oaidb' '!='
 'None' 'or' 'oaida' '!=' 'None' 'or' 'oaid' '!=' 'None' ':' 'idt' '='
 'info' '.' 'get' '(' ""'control'"" ',' '{' '}' ')' '.' 'get' '('
 ""'iso_datetime'"" ',' ""''"" ')' 'if' 'idt' '!=' ""''"" ':' 'rx' '='
 'convert_iso_time' '(' '{' ""'iso_datetime'"" ':' 'idt' '}' ')' 'if' 'rx'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'oidt' '=' 'rx' '['
 ""'datetime_obj'"" ']' 'if' 'oaidb' '!=' 'None' 'and' 'oidt' '>' 'oaidb'
 ':' 'return' '{' ""'return'"" ':' '0' ',' ""'skip'"" ':' ""'yes'"" '}' 'if'
 'oaida' '!=' 'None' 'and' 'oidt' '<' 'oaida' ':' 'return' '{' ""'return'""
 ':' '0' ',' ""'skip'"" ':' ""'yes'"" '}' 'if' 'oaid' '!=' 'None' 'and' 'oidt'
 '!=' 'oaid' ':' 'return' '{' ""'return'"" ':' '0' ',' ""'skip'"" ':' ""'yes'""
 '}' '# Check if search by name' 'if' 'sn' '!=' ""''"" ':' 'ro' '='
 'find_string_in_dict_or_list' '(' '{' ""'dict'"" ':' '{' ""'string'"" ':'
 'info' '.' 'get' '(' ""'data_name'"" ',' ""''"" ')' '}' ',' ""'search_string'""
 ':' 'sn' ',' ""'ignore_case'"" ':' 'ic' '}' ')' 'if' 'ro' '[' ""'return'""
 ']' '>' '0' ':' 'return' 'ro' 'if' 'ro' '[' ""'found'"" ']' '!=' ""'yes'""
 ':' 'return' '{' ""'return'"" ':' '0' ',' ""'skip'"" ':' ""'yes'"" '}'
 '# To be fast, load directly' 'p' '=' 'i' '[' ""'path'"" ']' 'skip' '='
 ""'yes'"" 'sd' '=' 'i' '.' 'get' '(' ""'search_dict'"" ',' '{' '}' ')' 'p1'
 '=' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'""
 ']' ',' 'cfg' '[' ""'file_meta'"" ']' ')' 'if' 'not' 'os' '.' 'path' '.'
 'isfile' '(' 'p1' ')' ':' 'p1' '=' 'os' '.' 'path' '.' 'join' '(' 'p' ','
 'cfg' '[' ""'subdir_ck_ext'"" ']' ',' 'cfg' '[' ""'file_meta_old'"" ']' ')'
 'if' 'not' 'os' '.' 'path' '.' 'isfile' '(' 'p1' ')' ':' 'return' '{'
 ""'return'"" ':' '0' ',' ""'skip'"" ':' ""'yes'"" '}' 'r' '=' 'load_json_file'
 '(' '{' ""'json_file'"" ':' 'p1' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'r' 'd' '=' 'r' '[' ""'dict'"" ']' '# Check directly' 'rx'
 '=' 'compare_dicts' '(' '{' ""'dict1'"" ':' 'd' ',' ""'dict2'"" ':' 'sd' ','
 ""'ignore_case'"" ':' 'ic' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'rx' 'equal' '=' 'rx' '[' ""'equal'"" ']' 'if' 'equal' '=='
 ""'yes'"" ':' 'skip' '=' ""'no'"" 'return' '{' ""'return'"" ':' '0' ','
 ""'skip'"" ':' 'skip' '}']","Input:  {
              repo_uoa             - repo UOA
              module_uoa           - module UOA
              data_uoa             - data UOA
              path                 - path  

              (search_dict)        - search if this dict is a part of the entry
              (ignore_case)        - if 'yes', ignore case of letters
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path'}]
            }","['Input' ':' '{' 'repo_uoa' '-' 'repo' 'UOA' 'module_uoa' '-' 'module'
 'UOA' 'data_uoa' '-' 'data' 'UOA' 'path' '-' 'path']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L7847-L7925
ctuning/ck,ck/kernel.py,compare_dicts,"def compare_dicts(i):
    """"""
    Input:  {
              dict1         - dictionary 1
              dict2         - dictionary 2
              (ignore_case) - ignore case of letters

              Note that if dict1 and dict2 has lists, the results will be as follows:

              * dict1={""key"":['a','b','c']}
                dict2={""key"":['a','b']}
                EQUAL

              * dict1={""key"":['a','b']}
                dict2={""key"":['a','b','c']}
                NOT EQUAL
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              equal        - if 'yes' dictionaries are equal
            }
    """"""

    d1=i.get('dict1',{})
    d2=i.get('dict2',{})

    equal='yes'

    bic=False
    ic=i.get('ignore_case','')
    if ic=='yes': bic=True

    for q2 in d2:
        v2=d2[q2]
        if type(v2)==dict:
           if q2 not in d1:
              equal='no'
              break

           v1=d1[q2]

           rx=compare_dicts({'dict1':v1,'dict2':v2, 'ignore_case':ic})
           if rx['return']>0: return rx
           equal=rx['equal']
           if equal=='no':
              break
        elif type(v2)==list:
           # For now can check only values in list
           if q2 not in d1:
              equal='no'
              break

           v1=d1[q2]

           if type(v1)!=list:
              equal='no'
              break

           for m in v2:
               if m not in v1:
                  equal='no'
                  break

           if equal=='no':
              break
        else:
           if q2 not in d1:
              equal='no'
              break

           if equal=='no':
              break

           v1=d1[q2]

           if bic and type(v1)!=int and type(v1)!=float and type(v1)!=bool: 
              v1=v1.lower()
              v2=v2.lower()

           if v2!=v1:
              equal='no'
              break

    return {'return':0, 'equal':equal}",python,"def compare_dicts(i):
    """"""
    Input:  {
              dict1         - dictionary 1
              dict2         - dictionary 2
              (ignore_case) - ignore case of letters

              Note that if dict1 and dict2 has lists, the results will be as follows:

              * dict1={""key"":['a','b','c']}
                dict2={""key"":['a','b']}
                EQUAL

              * dict1={""key"":['a','b']}
                dict2={""key"":['a','b','c']}
                NOT EQUAL
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              equal        - if 'yes' dictionaries are equal
            }
    """"""

    d1=i.get('dict1',{})
    d2=i.get('dict2',{})

    equal='yes'

    bic=False
    ic=i.get('ignore_case','')
    if ic=='yes': bic=True

    for q2 in d2:
        v2=d2[q2]
        if type(v2)==dict:
           if q2 not in d1:
              equal='no'
              break

           v1=d1[q2]

           rx=compare_dicts({'dict1':v1,'dict2':v2, 'ignore_case':ic})
           if rx['return']>0: return rx
           equal=rx['equal']
           if equal=='no':
              break
        elif type(v2)==list:
           # For now can check only values in list
           if q2 not in d1:
              equal='no'
              break

           v1=d1[q2]

           if type(v1)!=list:
              equal='no'
              break

           for m in v2:
               if m not in v1:
                  equal='no'
                  break

           if equal=='no':
              break
        else:
           if q2 not in d1:
              equal='no'
              break

           if equal=='no':
              break

           v1=d1[q2]

           if bic and type(v1)!=int and type(v1)!=float and type(v1)!=bool: 
              v1=v1.lower()
              v2=v2.lower()

           if v2!=v1:
              equal='no'
              break

    return {'return':0, 'equal':equal}","['def' 'compare_dicts' '(' 'i' ')' ':' 'd1' '=' 'i' '.' 'get' '('
 ""'dict1'"" ',' '{' '}' ')' 'd2' '=' 'i' '.' 'get' '(' ""'dict2'"" ',' '{'
 '}' ')' 'equal' '=' ""'yes'"" 'bic' '=' 'False' 'ic' '=' 'i' '.' 'get' '('
 ""'ignore_case'"" ',' ""''"" ')' 'if' 'ic' '==' ""'yes'"" ':' 'bic' '=' 'True'
 'for' 'q2' 'in' 'd2' ':' 'v2' '=' 'd2' '[' 'q2' ']' 'if' 'type' '(' 'v2'
 ')' '==' 'dict' ':' 'if' 'q2' 'not' 'in' 'd1' ':' 'equal' '=' ""'no'""
 'break' 'v1' '=' 'd1' '[' 'q2' ']' 'rx' '=' 'compare_dicts' '(' '{'
 ""'dict1'"" ':' 'v1' ',' ""'dict2'"" ':' 'v2' ',' ""'ignore_case'"" ':' 'ic'
 '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'equal'
 '=' 'rx' '[' ""'equal'"" ']' 'if' 'equal' '==' ""'no'"" ':' 'break' 'elif'
 'type' '(' 'v2' ')' '==' 'list' ':'
 '# For now can check only values in list' 'if' 'q2' 'not' 'in' 'd1' ':'
 'equal' '=' ""'no'"" 'break' 'v1' '=' 'd1' '[' 'q2' ']' 'if' 'type' '('
 'v1' ')' '!=' 'list' ':' 'equal' '=' ""'no'"" 'break' 'for' 'm' 'in' 'v2'
 ':' 'if' 'm' 'not' 'in' 'v1' ':' 'equal' '=' ""'no'"" 'break' 'if' 'equal'
 '==' ""'no'"" ':' 'break' 'else' ':' 'if' 'q2' 'not' 'in' 'd1' ':' 'equal'
 '=' ""'no'"" 'break' 'if' 'equal' '==' ""'no'"" ':' 'break' 'v1' '=' 'd1' '['
 'q2' ']' 'if' 'bic' 'and' 'type' '(' 'v1' ')' '!=' 'int' 'and' 'type' '('
 'v1' ')' '!=' 'float' 'and' 'type' '(' 'v1' ')' '!=' 'bool' ':' 'v1' '='
 'v1' '.' 'lower' '(' ')' 'v2' '=' 'v2' '.' 'lower' '(' ')' 'if' 'v2' '!='
 'v1' ':' 'equal' '=' ""'no'"" 'break' 'return' '{' ""'return'"" ':' '0' ','
 ""'equal'"" ':' 'equal' '}']","Input:  {
              dict1         - dictionary 1
              dict2         - dictionary 2
              (ignore_case) - ignore case of letters

              Note that if dict1 and dict2 has lists, the results will be as follows:

              * dict1={""key"":['a','b','c']}
                dict2={""key"":['a','b']}
                EQUAL

              * dict1={""key"":['a','b']}
                dict2={""key"":['a','b','c']}
                NOT EQUAL
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              equal        - if 'yes' dictionaries are equal
            }","['Input' ':' '{' 'dict1' '-' 'dictionary' '1' 'dict2' '-' 'dictionary' '2'
 '(' 'ignore_case' ')' '-' 'ignore' 'case' 'of' 'letters']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L7932-L8019
ctuning/ck,ck/kernel.py,compare_flat_dicts,"def compare_flat_dicts(i):
    """"""
    Input:  {
              dict1            - dictionary 1
              dict2            - dictionary 2
              (ignore_case)    - ignore case of letters
              (space_as_none)  - if 'yes', consider """" as None
              (keys_to_ignore) - list of keys to ignore (can be wildcards)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              equal        - if 'yes' dictionaries are equal
            }
    """"""

    d1=i.get('dict1',{})
    d2=i.get('dict2',{})

    equal='yes'

    ic=False
    x=i.get('ignore_case','')
    if x=='yes': ic=True

    san=None
    x=i.get('space_as_none','')
    if x=='yes': san=''

    # Create common set of keys
    keys=list(d1.keys())
    for q in d2:
        if q not in keys:
           keys.append(q)

    # If keys to ignore
    kti=i.get('keys_to_ignore',[])
    if len(kti)>0:
       import fnmatch

       x=[]
       for q in keys:
           skip=False
           for k in kti:
               if fnmatch.fnmatch(q,k):
                  skip=True
           if not skip:
              x.append(q)
       keys=x

    # Compare all keys
    for q in keys:
        v1=d1.get(q, san)
        v2=d2.get(q, san)

        if ic and type(v1)!=int and type(v1)!=float and type(v1)!=bool: 
           v1=v1.lower()
           v2=v2.lower()

        if v1!=v2:
           equal='no'
           break

    return {'return':0, 'equal':equal}",python,"def compare_flat_dicts(i):
    """"""
    Input:  {
              dict1            - dictionary 1
              dict2            - dictionary 2
              (ignore_case)    - ignore case of letters
              (space_as_none)  - if 'yes', consider """" as None
              (keys_to_ignore) - list of keys to ignore (can be wildcards)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              equal        - if 'yes' dictionaries are equal
            }
    """"""

    d1=i.get('dict1',{})
    d2=i.get('dict2',{})

    equal='yes'

    ic=False
    x=i.get('ignore_case','')
    if x=='yes': ic=True

    san=None
    x=i.get('space_as_none','')
    if x=='yes': san=''

    # Create common set of keys
    keys=list(d1.keys())
    for q in d2:
        if q not in keys:
           keys.append(q)

    # If keys to ignore
    kti=i.get('keys_to_ignore',[])
    if len(kti)>0:
       import fnmatch

       x=[]
       for q in keys:
           skip=False
           for k in kti:
               if fnmatch.fnmatch(q,k):
                  skip=True
           if not skip:
              x.append(q)
       keys=x

    # Compare all keys
    for q in keys:
        v1=d1.get(q, san)
        v2=d2.get(q, san)

        if ic and type(v1)!=int and type(v1)!=float and type(v1)!=bool: 
           v1=v1.lower()
           v2=v2.lower()

        if v1!=v2:
           equal='no'
           break

    return {'return':0, 'equal':equal}","['def' 'compare_flat_dicts' '(' 'i' ')' ':' 'd1' '=' 'i' '.' 'get' '('
 ""'dict1'"" ',' '{' '}' ')' 'd2' '=' 'i' '.' 'get' '(' ""'dict2'"" ',' '{'
 '}' ')' 'equal' '=' ""'yes'"" 'ic' '=' 'False' 'x' '=' 'i' '.' 'get' '('
 ""'ignore_case'"" ',' ""''"" ')' 'if' 'x' '==' ""'yes'"" ':' 'ic' '=' 'True'
 'san' '=' 'None' 'x' '=' 'i' '.' 'get' '(' ""'space_as_none'"" ',' ""''"" ')'
 'if' 'x' '==' ""'yes'"" ':' 'san' '=' ""''"" '# Create common set of keys'
 'keys' '=' 'list' '(' 'd1' '.' 'keys' '(' ')' ')' 'for' 'q' 'in' 'd2' ':'
 'if' 'q' 'not' 'in' 'keys' ':' 'keys' '.' 'append' '(' 'q' ')'
 '# If keys to ignore' 'kti' '=' 'i' '.' 'get' '(' ""'keys_to_ignore'"" ','
 '[' ']' ')' 'if' 'len' '(' 'kti' ')' '>' '0' ':' 'import' 'fnmatch' 'x'
 '=' '[' ']' 'for' 'q' 'in' 'keys' ':' 'skip' '=' 'False' 'for' 'k' 'in'
 'kti' ':' 'if' 'fnmatch' '.' 'fnmatch' '(' 'q' ',' 'k' ')' ':' 'skip' '='
 'True' 'if' 'not' 'skip' ':' 'x' '.' 'append' '(' 'q' ')' 'keys' '=' 'x'
 '# Compare all keys' 'for' 'q' 'in' 'keys' ':' 'v1' '=' 'd1' '.' 'get'
 '(' 'q' ',' 'san' ')' 'v2' '=' 'd2' '.' 'get' '(' 'q' ',' 'san' ')' 'if'
 'ic' 'and' 'type' '(' 'v1' ')' '!=' 'int' 'and' 'type' '(' 'v1' ')' '!='
 'float' 'and' 'type' '(' 'v1' ')' '!=' 'bool' ':' 'v1' '=' 'v1' '.'
 'lower' '(' ')' 'v2' '=' 'v2' '.' 'lower' '(' ')' 'if' 'v1' '!=' 'v2' ':'
 'equal' '=' ""'no'"" 'break' 'return' '{' ""'return'"" ':' '0' ',' ""'equal'""
 ':' 'equal' '}']","Input:  {
              dict1            - dictionary 1
              dict2            - dictionary 2
              (ignore_case)    - ignore case of letters
              (space_as_none)  - if 'yes', consider """" as None
              (keys_to_ignore) - list of keys to ignore (can be wildcards)
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              equal        - if 'yes' dictionaries are equal
            }","['Input' ':' '{' 'dict1' '-' 'dictionary' '1' 'dict2' '-' 'dictionary' '2'
 '(' 'ignore_case' ')' '-' 'ignore' 'case' 'of' 'letters' '('
 'space_as_none' ')' '-' 'if' 'yes' 'consider' 'as' 'None' '('
 'keys_to_ignore' ')' '-' 'list' 'of' 'keys' 'to' 'ignore' '(' 'can' 'be'
 'wildcards' ')' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8026-L8092
ctuning/ck,ck/kernel.py,find_string_in_dict_or_list,"def find_string_in_dict_or_list(i):
    """"""
    Input:  {
              dict            - dictionary 1
              (search_string) - search string
              (ignore_case)   - ignore case of letters
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              found        - if 'yes', string found
            }
    """"""

    d=i.get('dict',{})

    found='no'

    wc=False
    ss=i.get('search_string','')
    if ss.find('*')>=0 or ss.find('?')>=0:
       wc=True
       import fnmatch

    bic=False
    ic=i.get('ignore_case','')
    if ic=='yes': 
       bic=True
       ss=ss.lower()

    for q in d:
        if type(d)==dict:   v=d[q]
        elif type(d)==list: v=q
        else:               v=str(q)

        if type(v)==dict or type(v)==list:
           rx=find_string_in_dict_or_list({'dict':v, 'search_string':ss, 'ignore_case':ic})
           if rx['return']>0: return rx
           found=rx['found']
           if found=='yes':
              break
        else:
           try: v=str(v)
           except Exception as e: pass

           if bic: 
              v=v.lower()

           if (wc and fnmatch.fnmatch(v, ss)) or v==ss:
              found='yes'
              break

    return {'return':0, 'found':found}",python,"def find_string_in_dict_or_list(i):
    """"""
    Input:  {
              dict            - dictionary 1
              (search_string) - search string
              (ignore_case)   - ignore case of letters
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              found        - if 'yes', string found
            }
    """"""

    d=i.get('dict',{})

    found='no'

    wc=False
    ss=i.get('search_string','')
    if ss.find('*')>=0 or ss.find('?')>=0:
       wc=True
       import fnmatch

    bic=False
    ic=i.get('ignore_case','')
    if ic=='yes': 
       bic=True
       ss=ss.lower()

    for q in d:
        if type(d)==dict:   v=d[q]
        elif type(d)==list: v=q
        else:               v=str(q)

        if type(v)==dict or type(v)==list:
           rx=find_string_in_dict_or_list({'dict':v, 'search_string':ss, 'ignore_case':ic})
           if rx['return']>0: return rx
           found=rx['found']
           if found=='yes':
              break
        else:
           try: v=str(v)
           except Exception as e: pass

           if bic: 
              v=v.lower()

           if (wc and fnmatch.fnmatch(v, ss)) or v==ss:
              found='yes'
              break

    return {'return':0, 'found':found}","['def' 'find_string_in_dict_or_list' '(' 'i' ')' ':' 'd' '=' 'i' '.' 'get'
 '(' ""'dict'"" ',' '{' '}' ')' 'found' '=' ""'no'"" 'wc' '=' 'False' 'ss' '='
 'i' '.' 'get' '(' ""'search_string'"" ',' ""''"" ')' 'if' 'ss' '.' 'find' '('
 ""'*'"" ')' '>=' '0' 'or' 'ss' '.' 'find' '(' ""'?'"" ')' '>=' '0' ':' 'wc'
 '=' 'True' 'import' 'fnmatch' 'bic' '=' 'False' 'ic' '=' 'i' '.' 'get'
 '(' ""'ignore_case'"" ',' ""''"" ')' 'if' 'ic' '==' ""'yes'"" ':' 'bic' '='
 'True' 'ss' '=' 'ss' '.' 'lower' '(' ')' 'for' 'q' 'in' 'd' ':' 'if'
 'type' '(' 'd' ')' '==' 'dict' ':' 'v' '=' 'd' '[' 'q' ']' 'elif' 'type'
 '(' 'd' ')' '==' 'list' ':' 'v' '=' 'q' 'else' ':' 'v' '=' 'str' '(' 'q'
 ')' 'if' 'type' '(' 'v' ')' '==' 'dict' 'or' 'type' '(' 'v' ')' '=='
 'list' ':' 'rx' '=' 'find_string_in_dict_or_list' '(' '{' ""'dict'"" ':'
 'v' ',' ""'search_string'"" ':' 'ss' ',' ""'ignore_case'"" ':' 'ic' '}' ')'
 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'found' '=' 'rx'
 '[' ""'found'"" ']' 'if' 'found' '==' ""'yes'"" ':' 'break' 'else' ':' 'try'
 ':' 'v' '=' 'str' '(' 'v' ')' 'except' 'Exception' 'as' 'e' ':' 'pass'
 'if' 'bic' ':' 'v' '=' 'v' '.' 'lower' '(' ')' 'if' '(' 'wc' 'and'
 'fnmatch' '.' 'fnmatch' '(' 'v' ',' 'ss' ')' ')' 'or' 'v' '==' 'ss' ':'
 'found' '=' ""'yes'"" 'break' 'return' '{' ""'return'"" ':' '0' ',' ""'found'""
 ':' 'found' '}']","Input:  {
              dict            - dictionary 1
              (search_string) - search string
              (ignore_case)   - ignore case of letters
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              found        - if 'yes', string found
            }","['Input' ':' '{' 'dict' '-' 'dictionary' '1' '(' 'search_string' ')' '-'
 'search' 'string' '(' 'ignore_case' ')' '-' 'ignore' 'case' 'of'
 'letters' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8099-L8154
ctuning/ck,ck/kernel.py,search_string_filter,"def search_string_filter(i):
    """"""
    Input:  {
              repo_uoa             - repo UOA
              module_uoa           - module UOA
              data_uoa             - data UOA
              path                 - path  

              (search_string)      - search with expressions *?
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path'}]
            }

    """"""

    # To be fast, load directly
    p=i['path']

    skip='yes'

    ss=i.get('search_string','')
    if ss=='':
       skip='no'
    else:
       ic=i.get('ignore_case','')

       p1=os.path.join(p,cfg['subdir_ck_ext'],cfg['file_meta'])
       if not os.path.isfile(p1):
          p1=os.path.join(p,cfg['subdir_ck_ext'],cfg['file_meta_old'])
          if not os.path.isfile(p1):
             return {'return':0, 'skip':'yes'}

       r=load_json_file({'json_file':p1})
       if r['return']>0: return r
       d=r['dict']

       # Check directly
       rx=find_string_in_dict_or_list({'dict':d, 'search_string':ss, 'ignore_case':ic})
       if rx['return']>0: return rx
       found=rx['found']
       if found=='yes': skip='no'

    return {'return':0, 'skip':skip}",python,"def search_string_filter(i):
    """"""
    Input:  {
              repo_uoa             - repo UOA
              module_uoa           - module UOA
              data_uoa             - data UOA
              path                 - path  

              (search_string)      - search with expressions *?
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path'}]
            }

    """"""

    # To be fast, load directly
    p=i['path']

    skip='yes'

    ss=i.get('search_string','')
    if ss=='':
       skip='no'
    else:
       ic=i.get('ignore_case','')

       p1=os.path.join(p,cfg['subdir_ck_ext'],cfg['file_meta'])
       if not os.path.isfile(p1):
          p1=os.path.join(p,cfg['subdir_ck_ext'],cfg['file_meta_old'])
          if not os.path.isfile(p1):
             return {'return':0, 'skip':'yes'}

       r=load_json_file({'json_file':p1})
       if r['return']>0: return r
       d=r['dict']

       # Check directly
       rx=find_string_in_dict_or_list({'dict':d, 'search_string':ss, 'ignore_case':ic})
       if rx['return']>0: return rx
       found=rx['found']
       if found=='yes': skip='no'

    return {'return':0, 'skip':skip}","['def' 'search_string_filter' '(' 'i' ')' ':'
 '# To be fast, load directly' 'p' '=' 'i' '[' ""'path'"" ']' 'skip' '='
 ""'yes'"" 'ss' '=' 'i' '.' 'get' '(' ""'search_string'"" ',' ""''"" ')' 'if'
 'ss' '==' ""''"" ':' 'skip' '=' ""'no'"" 'else' ':' 'ic' '=' 'i' '.' 'get'
 '(' ""'ignore_case'"" ',' ""''"" ')' 'p1' '=' 'os' '.' 'path' '.' 'join' '('
 'p' ',' 'cfg' '[' ""'subdir_ck_ext'"" ']' ',' 'cfg' '[' ""'file_meta'"" ']'
 ')' 'if' 'not' 'os' '.' 'path' '.' 'isfile' '(' 'p1' ')' ':' 'p1' '='
 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'"" ']'
 ',' 'cfg' '[' ""'file_meta_old'"" ']' ')' 'if' 'not' 'os' '.' 'path' '.'
 'isfile' '(' 'p1' ')' ':' 'return' '{' ""'return'"" ':' '0' ',' ""'skip'""
 ':' ""'yes'"" '}' 'r' '=' 'load_json_file' '(' '{' ""'json_file'"" ':' 'p1'
 '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'd' '=' 'r'
 '[' ""'dict'"" ']' '# Check directly' 'rx' '='
 'find_string_in_dict_or_list' '(' '{' ""'dict'"" ':' 'd' ','
 ""'search_string'"" ':' 'ss' ',' ""'ignore_case'"" ':' 'ic' '}' ')' 'if' 'rx'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'found' '=' 'rx' '['
 ""'found'"" ']' 'if' 'found' '==' ""'yes'"" ':' 'skip' '=' ""'no'"" 'return'
 '{' ""'return'"" ':' '0' ',' ""'skip'"" ':' 'skip' '}']","Input:  {
              repo_uoa             - repo UOA
              module_uoa           - module UOA
              data_uoa             - data UOA
              path                 - path  

              (search_string)      - search with expressions *?
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              lst          - [{'repo_uoa', 'repo_uid',
                               'module_uoa', 'module_uid', 
                               'data_uoa','data_uid',
                               'path'}]
            }","['Input' ':' '{' 'repo_uoa' '-' 'repo' 'UOA' 'module_uoa' '-' 'module'
 'UOA' 'data_uoa' '-' 'data' 'UOA' 'path' '-' 'path']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8161-L8212
ctuning/ck,ck/kernel.py,access_index_server,"def access_index_server(i):
    """"""
    Input:  {
              request        - request type ('PUT', 'DELETE', 'TEST')
              (path)         - path  
              (dict)         - query as dict to send
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - returned dict
            }

    """"""

    request=i['request']

    # Prepare URL
    host=cfg.get('index_host','')
    if host=='':
       return {'return':1, 'error':'index host is not defined in configuration'}

    url=host
    port=cfg.get('index_port','')
    if port!='':
       url+=':'+port

    path=i.get('path','')
    url+=path

    dd=i.get('dict',{})
    ddo={}

    if cfg.get('index_use_curl','')=='yes':
       import tempfile

       fd1, fn1=tempfile.mkstemp(suffix='.tmp', prefix='ck-')
       os.close(fd1)
       os.remove(fn1)

       fd2, fn2=tempfile.mkstemp(suffix='.tmp', prefix='ck-')
       os.close(fd2)
       os.remove(fn2)

       r=save_json_to_file({'json_file':fn1, 'dict':dd})
       if r['return']>0: return r

       cmd='curl -X'+request+' '+url+' -d @'+fn1+' -s -o '+fn2
       os.system(cmd)

       # Read output
       if not os.path.isfile(fn2):
          return {'return':1, 'error':'problem accessing indexing server - maybe indexing server is down?'}

       r=load_json_file({'json_file':fn2})

       if os.path.isfile(fn1): os.remove(fn1)
       if os.path.isfile(fn2): os.remove(fn2)

       if r['return']>0: return r
       ddo=r['dict']
    else:
       try:
          import urllib.request as urllib2
       except:
          import urllib2

       try:
          from urllib.parse import urlencode
       except:
          from urllib import urlencode

       # Prepare post variables
       r=dumps_json({'dict':dd, 'skip_indent':'yes'})
       if r['return']>0: return r
       s=r['string'].encode('utf8')

       rq = urllib2.Request(url, s)
       if request=='DELETE':
          rq.get_method = lambda: request

       not_found=False
       try:
          f=urllib2.urlopen(rq)
       except urllib2.URLError as e:
          se=format(e)
          if request=='DELETE' and se.find('404')>0:
             not_found=True
          else:
             return {'return':1, 'error':'problem accessing indexing server ('+se+')'}

       if not not_found:
          try:
             s=f.read()
             f.close()
          except Exception as e:
             return {'return':1, 'error':'can\'t parse output during indexing ('+format(e)+')'}

          if sys.version_info[0]>2:
             s=s.decode('utf8')

          r=convert_json_str_to_dict({'str':s, 'skip_quote_replacement':'yes'})
          if r['return']>0: 
             return {'return':1, 'error':'can\'t parse output from index server ('+r['error']+')'}
          ddo=r['dict']

    return {'return':0, 'dict':ddo}",python,"def access_index_server(i):
    """"""
    Input:  {
              request        - request type ('PUT', 'DELETE', 'TEST')
              (path)         - path  
              (dict)         - query as dict to send
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - returned dict
            }

    """"""

    request=i['request']

    # Prepare URL
    host=cfg.get('index_host','')
    if host=='':
       return {'return':1, 'error':'index host is not defined in configuration'}

    url=host
    port=cfg.get('index_port','')
    if port!='':
       url+=':'+port

    path=i.get('path','')
    url+=path

    dd=i.get('dict',{})
    ddo={}

    if cfg.get('index_use_curl','')=='yes':
       import tempfile

       fd1, fn1=tempfile.mkstemp(suffix='.tmp', prefix='ck-')
       os.close(fd1)
       os.remove(fn1)

       fd2, fn2=tempfile.mkstemp(suffix='.tmp', prefix='ck-')
       os.close(fd2)
       os.remove(fn2)

       r=save_json_to_file({'json_file':fn1, 'dict':dd})
       if r['return']>0: return r

       cmd='curl -X'+request+' '+url+' -d @'+fn1+' -s -o '+fn2
       os.system(cmd)

       # Read output
       if not os.path.isfile(fn2):
          return {'return':1, 'error':'problem accessing indexing server - maybe indexing server is down?'}

       r=load_json_file({'json_file':fn2})

       if os.path.isfile(fn1): os.remove(fn1)
       if os.path.isfile(fn2): os.remove(fn2)

       if r['return']>0: return r
       ddo=r['dict']
    else:
       try:
          import urllib.request as urllib2
       except:
          import urllib2

       try:
          from urllib.parse import urlencode
       except:
          from urllib import urlencode

       # Prepare post variables
       r=dumps_json({'dict':dd, 'skip_indent':'yes'})
       if r['return']>0: return r
       s=r['string'].encode('utf8')

       rq = urllib2.Request(url, s)
       if request=='DELETE':
          rq.get_method = lambda: request

       not_found=False
       try:
          f=urllib2.urlopen(rq)
       except urllib2.URLError as e:
          se=format(e)
          if request=='DELETE' and se.find('404')>0:
             not_found=True
          else:
             return {'return':1, 'error':'problem accessing indexing server ('+se+')'}

       if not not_found:
          try:
             s=f.read()
             f.close()
          except Exception as e:
             return {'return':1, 'error':'can\'t parse output during indexing ('+format(e)+')'}

          if sys.version_info[0]>2:
             s=s.decode('utf8')

          r=convert_json_str_to_dict({'str':s, 'skip_quote_replacement':'yes'})
          if r['return']>0: 
             return {'return':1, 'error':'can\'t parse output from index server ('+r['error']+')'}
          ddo=r['dict']

    return {'return':0, 'dict':ddo}","['def' 'access_index_server' '(' 'i' ')' ':' 'request' '=' 'i' '['
 ""'request'"" ']' '# Prepare URL' 'host' '=' 'cfg' '.' 'get' '('
 ""'index_host'"" ',' ""''"" ')' 'if' 'host' '==' ""''"" ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'index host is not defined in configuration'"" '}' 'url' '=' 'host'
 'port' '=' 'cfg' '.' 'get' '(' ""'index_port'"" ',' ""''"" ')' 'if' 'port'
 '!=' ""''"" ':' 'url' '+=' ""':'"" '+' 'port' 'path' '=' 'i' '.' 'get' '('
 ""'path'"" ',' ""''"" ')' 'url' '+=' 'path' 'dd' '=' 'i' '.' 'get' '('
 ""'dict'"" ',' '{' '}' ')' 'ddo' '=' '{' '}' 'if' 'cfg' '.' 'get' '('
 ""'index_use_curl'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'import' 'tempfile'
 'fd1' ',' 'fn1' '=' 'tempfile' '.' 'mkstemp' '(' 'suffix' '=' ""'.tmp'""
 ',' 'prefix' '=' ""'ck-'"" ')' 'os' '.' 'close' '(' 'fd1' ')' 'os' '.'
 'remove' '(' 'fn1' ')' 'fd2' ',' 'fn2' '=' 'tempfile' '.' 'mkstemp' '('
 'suffix' '=' ""'.tmp'"" ',' 'prefix' '=' ""'ck-'"" ')' 'os' '.' 'close' '('
 'fd2' ')' 'os' '.' 'remove' '(' 'fn2' ')' 'r' '=' 'save_json_to_file' '('
 '{' ""'json_file'"" ':' 'fn1' ',' ""'dict'"" ':' 'dd' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'cmd' '=' ""'curl -X'"" '+'
 'request' '+' ""' '"" '+' 'url' '+' ""' -d @'"" '+' 'fn1' '+' ""' -s -o '"" '+'
 'fn2' 'os' '.' 'system' '(' 'cmd' ')' '# Read output' 'if' 'not' 'os' '.'
 'path' '.' 'isfile' '(' 'fn2' ')' ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':'
 ""'problem accessing indexing server - maybe indexing server is down?'""
 '}' 'r' '=' 'load_json_file' '(' '{' ""'json_file'"" ':' 'fn2' '}' ')' 'if'
 'os' '.' 'path' '.' 'isfile' '(' 'fn1' ')' ':' 'os' '.' 'remove' '('
 'fn1' ')' 'if' 'os' '.' 'path' '.' 'isfile' '(' 'fn2' ')' ':' 'os' '.'
 'remove' '(' 'fn2' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return'
 'r' 'ddo' '=' 'r' '[' ""'dict'"" ']' 'else' ':' 'try' ':' 'import' 'urllib'
 '.' 'request' 'as' 'urllib2' 'except' ':' 'import' 'urllib2' 'try' ':'
 'from' 'urllib' '.' 'parse' 'import' 'urlencode' 'except' ':' 'from'
 'urllib' 'import' 'urlencode' '# Prepare post variables' 'r' '='
 'dumps_json' '(' '{' ""'dict'"" ':' 'dd' ',' ""'skip_indent'"" ':' ""'yes'""
 '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 's' '=' 'r'
 '[' ""'string'"" ']' '.' 'encode' '(' ""'utf8'"" ')' 'rq' '=' 'urllib2' '.'
 'Request' '(' 'url' ',' 's' ')' 'if' 'request' '==' ""'DELETE'"" ':' 'rq'
 '.' 'get_method' '=' 'lambda' ':' 'request' 'not_found' '=' 'False' 'try'
 ':' 'f' '=' 'urllib2' '.' 'urlopen' '(' 'rq' ')' 'except' 'urllib2' '.'
 'URLError' 'as' 'e' ':' 'se' '=' 'format' '(' 'e' ')' 'if' 'request' '=='
 ""'DELETE'"" 'and' 'se' '.' 'find' '(' ""'404'"" ')' '>' '0' ':' 'not_found'
 '=' 'True' 'else' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'problem accessing indexing server ('"" '+' 'se' '+' ""')'"" '}' 'if' 'not'
 'not_found' ':' 'try' ':' 's' '=' 'f' '.' 'read' '(' ')' 'f' '.' 'close'
 '(' ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{' ""'return'"" ':' '1'
 ',' ""'error'"" ':' ""'can\\'t parse output during indexing ('"" '+' 'format'
 '(' 'e' ')' '+' ""')'"" '}' 'if' 'sys' '.' 'version_info' '[' '0' ']' '>'
 '2' ':' 's' '=' 's' '.' 'decode' '(' ""'utf8'"" ')' 'r' '='
 'convert_json_str_to_dict' '(' '{' ""'str'"" ':' 's' ','
 ""'skip_quote_replacement'"" ':' ""'yes'"" '}' ')' 'if' 'r' '[' ""'return'""
 ']' '>' '0' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'can\\'t parse output from index server ('"" '+' 'r' '[' ""'error'"" ']'
 '+' ""')'"" '}' 'ddo' '=' 'r' '[' ""'dict'"" ']' 'return' '{' ""'return'"" ':'
 '0' ',' ""'dict'"" ':' 'ddo' '}']","Input:  {
              request        - request type ('PUT', 'DELETE', 'TEST')
              (path)         - path  
              (dict)         - query as dict to send
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              dict         - returned dict
            }","['Input' ':' '{' 'request' '-' 'request' 'type' '(' 'PUT' 'DELETE' 'TEST'
 ')' '(' 'path' ')' '-' 'path' '(' 'dict' ')' '-' 'query' 'as' 'dict' 'to'
 'send' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8219-L8328
ctuning/ck,ck/kernel.py,add_action,"def add_action(i):
    """"""
    Input:  {
              (repo_uoa)                  - repo UOA
              module_uoa                  - normally should be 'module' already
              data_uoa                    - UOA of the module to be created

              func                        - action
              (desc)                      - desc
              (for_web)                   - if 'yes', can be used to output html

              (skip_appending_dummy_code) - if 'yes', do not append code
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

               Output of 'update' function
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    func=i.get('func','')
    desc=i.get('desc','')

    fweb=i.get('for_web','')

    if muoa=='':
       return {'return':1, 'error':'module UOA is not defined'}

    if duoa!='':
       muoa=duoa
       duoa=''

    # Find path to module
    ii={'module_uoa':cfg['module_name'],
        'data_uoa':muoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r

    pp=r['path']
    dd=r['dict']

    actions=dd.get('actions',{})

    # Check func and desc
    if o=='con':
       if func=='':
          r=inp({'text':'Add action function (or Enter to stop):    '})
          func=r['string']

       if func!='':
          if fweb=='':
             r1=inp({'text':'Support web (y/N):                         '})
             fweb=r1['string'].lower()
             if fweb=='y' or fweb=='yes': fweb='yes'
             else: fweb=''

          if desc=='':
             r1=inp({'text':'Add action description:                    '})
             desc=r1['string']

    # Check if empty
    if func=='':
       return {'return':1, 'error':'action (function) is not defined'}

    if func in actions:
       return {'return':1, 'error':'action (function) already exists in the module'}

    # Adding actions
    actions[func]={}
    if desc!='': actions[func]['desc']=desc
    if fweb!='': actions[func]['for_web']=fweb
    dd['actions']=actions

    if i.get('skip_appending_dummy_code','')!='yes':
       ii={'module_uoa':cfg['module_name'],
           'data_uoa':cfg['module_name']}
       r=load(ii)
       if r['return']>0: return r

       px=r['path']
       pd=r['dict']

       pma=os.path.join(px, pd['dummy_module_action'])

       # Load module action dummy
       r=load_text_file({'text_file':pma})
       if r['return']>0: return r
       spma=r['string']

       # Load current module
       pmx=os.path.join(pp, cfg['module_full_code_name'])
       r=load_text_file({'text_file':pmx})
       if r['return']>0: return r
       spm=r['string']

       # Update
       spm+='\n'+spma.replace('$#action#$', func).replace('$#desc#$',desc)

       # Write current module
       rx=save_text_file({'text_file':pmx, 'string':spm})
       if rx['return']>0: return rx

    # Update data entry
    if o=='con': out('')
    ii={'module_uoa':cfg['module_name'],
        'data_uoa':muoa,
        'dict':dd,
        'out':o,
        'sort_keys':'yes'}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=update(ii)
    if r['return']>0: return r

    return r",python,"def add_action(i):
    """"""
    Input:  {
              (repo_uoa)                  - repo UOA
              module_uoa                  - normally should be 'module' already
              data_uoa                    - UOA of the module to be created

              func                        - action
              (desc)                      - desc
              (for_web)                   - if 'yes', can be used to output html

              (skip_appending_dummy_code) - if 'yes', do not append code
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

               Output of 'update' function
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    func=i.get('func','')
    desc=i.get('desc','')

    fweb=i.get('for_web','')

    if muoa=='':
       return {'return':1, 'error':'module UOA is not defined'}

    if duoa!='':
       muoa=duoa
       duoa=''

    # Find path to module
    ii={'module_uoa':cfg['module_name'],
        'data_uoa':muoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r

    pp=r['path']
    dd=r['dict']

    actions=dd.get('actions',{})

    # Check func and desc
    if o=='con':
       if func=='':
          r=inp({'text':'Add action function (or Enter to stop):    '})
          func=r['string']

       if func!='':
          if fweb=='':
             r1=inp({'text':'Support web (y/N):                         '})
             fweb=r1['string'].lower()
             if fweb=='y' or fweb=='yes': fweb='yes'
             else: fweb=''

          if desc=='':
             r1=inp({'text':'Add action description:                    '})
             desc=r1['string']

    # Check if empty
    if func=='':
       return {'return':1, 'error':'action (function) is not defined'}

    if func in actions:
       return {'return':1, 'error':'action (function) already exists in the module'}

    # Adding actions
    actions[func]={}
    if desc!='': actions[func]['desc']=desc
    if fweb!='': actions[func]['for_web']=fweb
    dd['actions']=actions

    if i.get('skip_appending_dummy_code','')!='yes':
       ii={'module_uoa':cfg['module_name'],
           'data_uoa':cfg['module_name']}
       r=load(ii)
       if r['return']>0: return r

       px=r['path']
       pd=r['dict']

       pma=os.path.join(px, pd['dummy_module_action'])

       # Load module action dummy
       r=load_text_file({'text_file':pma})
       if r['return']>0: return r
       spma=r['string']

       # Load current module
       pmx=os.path.join(pp, cfg['module_full_code_name'])
       r=load_text_file({'text_file':pmx})
       if r['return']>0: return r
       spm=r['string']

       # Update
       spm+='\n'+spma.replace('$#action#$', func).replace('$#desc#$',desc)

       # Write current module
       rx=save_text_file({'text_file':pmx, 'string':spm})
       if rx['return']>0: return rx

    # Update data entry
    if o=='con': out('')
    ii={'module_uoa':cfg['module_name'],
        'data_uoa':muoa,
        'dict':dd,
        'out':o,
        'sort_keys':'yes'}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=update(ii)
    if r['return']>0: return r

    return r","['def' 'add_action' '(' 'i' ')' ':' '# Check if global writing is allowed'
 'r' '=' 'check_writing' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'r' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')'
 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'muoa' '=' 'i' '.'
 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.' 'get' '('
 ""'data_uoa'"" ',' ""''"" ')' 'func' '=' 'i' '.' 'get' '(' ""'func'"" ',' ""''""
 ')' 'desc' '=' 'i' '.' 'get' '(' ""'desc'"" ',' ""''"" ')' 'fweb' '=' 'i' '.'
 'get' '(' ""'for_web'"" ',' ""''"" ')' 'if' 'muoa' '==' ""''"" ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':' ""'module UOA is not defined'"" '}'
 'if' 'duoa' '!=' ""''"" ':' 'muoa' '=' 'duoa' 'duoa' '=' ""''""
 '# Find path to module' 'ii' '=' '{' ""'module_uoa'"" ':' 'cfg' '['
 ""'module_name'"" ']' ',' ""'data_uoa'"" ':' 'muoa' '}' 'if' 'ruoa' '!=' ""''""
 ':' 'ii' '[' ""'repo_uoa'"" ']' '=' 'ruoa' 'r' '=' 'load' '(' 'ii' ')' 'if'
 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'pp' '=' 'r' '[' ""'path'""
 ']' 'dd' '=' 'r' '[' ""'dict'"" ']' 'actions' '=' 'dd' '.' 'get' '('
 ""'actions'"" ',' '{' '}' ')' '# Check func and desc' 'if' 'o' '==' ""'con'""
 ':' 'if' 'func' '==' ""''"" ':' 'r' '=' 'inp' '(' '{' ""'text'"" ':'
 ""'Add action function (or Enter to stop):    '"" '}' ')' 'func' '=' 'r'
 '[' ""'string'"" ']' 'if' 'func' '!=' ""''"" ':' 'if' 'fweb' '==' ""''"" ':'
 'r1' '=' 'inp' '(' '{' ""'text'"" ':'
 ""'Support web (y/N):                         '"" '}' ')' 'fweb' '=' 'r1'
 '[' ""'string'"" ']' '.' 'lower' '(' ')' 'if' 'fweb' '==' ""'y'"" 'or' 'fweb'
 '==' ""'yes'"" ':' 'fweb' '=' ""'yes'"" 'else' ':' 'fweb' '=' ""''"" 'if'
 'desc' '==' ""''"" ':' 'r1' '=' 'inp' '(' '{' ""'text'"" ':'
 ""'Add action description:                    '"" '}' ')' 'desc' '=' 'r1'
 '[' ""'string'"" ']' '# Check if empty' 'if' 'func' '==' ""''"" ':' 'return'
 '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'action (function) is not defined'"" '}' 'if' 'func' 'in' 'actions' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'action (function) already exists in the module'"" '}' '# Adding actions'
 'actions' '[' 'func' ']' '=' '{' '}' 'if' 'desc' '!=' ""''"" ':' 'actions'
 '[' 'func' ']' '[' ""'desc'"" ']' '=' 'desc' 'if' 'fweb' '!=' ""''"" ':'
 'actions' '[' 'func' ']' '[' ""'for_web'"" ']' '=' 'fweb' 'dd' '['
 ""'actions'"" ']' '=' 'actions' 'if' 'i' '.' 'get' '('
 ""'skip_appending_dummy_code'"" ',' ""''"" ')' '!=' ""'yes'"" ':' 'ii' '=' '{'
 ""'module_uoa'"" ':' 'cfg' '[' ""'module_name'"" ']' ',' ""'data_uoa'"" ':'
 'cfg' '[' ""'module_name'"" ']' '}' 'r' '=' 'load' '(' 'ii' ')' 'if' 'r'
 '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'px' '=' 'r' '[' ""'path'"" ']'
 'pd' '=' 'r' '[' ""'dict'"" ']' 'pma' '=' 'os' '.' 'path' '.' 'join' '('
 'px' ',' 'pd' '[' ""'dummy_module_action'"" ']' ')'
 '# Load module action dummy' 'r' '=' 'load_text_file' '(' '{'
 ""'text_file'"" ':' 'pma' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'spma' '=' 'r' '[' ""'string'"" ']' '# Load current module'
 'pmx' '=' 'os' '.' 'path' '.' 'join' '(' 'pp' ',' 'cfg' '['
 ""'module_full_code_name'"" ']' ')' 'r' '=' 'load_text_file' '(' '{'
 ""'text_file'"" ':' 'pmx' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'spm' '=' 'r' '[' ""'string'"" ']' '# Update' 'spm' '+='
 ""'\\n'"" '+' 'spma' '.' 'replace' '(' ""'$#action#$'"" ',' 'func' ')' '.'
 'replace' '(' ""'$#desc#$'"" ',' 'desc' ')' '# Write current module' 'rx'
 '=' 'save_text_file' '(' '{' ""'text_file'"" ':' 'pmx' ',' ""'string'"" ':'
 'spm' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx'
 '# Update data entry' 'if' 'o' '==' ""'con'"" ':' 'out' '(' ""''"" ')' 'ii'
 '=' '{' ""'module_uoa'"" ':' 'cfg' '[' ""'module_name'"" ']' ',' ""'data_uoa'""
 ':' 'muoa' ',' ""'dict'"" ':' 'dd' ',' ""'out'"" ':' 'o' ',' ""'sort_keys'""
 ':' ""'yes'"" '}' 'if' 'ruoa' '!=' ""''"" ':' 'ii' '[' ""'repo_uoa'"" ']' '='
 'ruoa' 'r' '=' 'update' '(' 'ii' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' 'return' 'r']","Input:  {
              (repo_uoa)                  - repo UOA
              module_uoa                  - normally should be 'module' already
              data_uoa                    - UOA of the module to be created

              func                        - action
              (desc)                      - desc
              (for_web)                   - if 'yes', can be used to output html

              (skip_appending_dummy_code) - if 'yes', do not append code
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

               Output of 'update' function
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'normally' 'should' 'be' 'module' 'already' 'data_uoa' '-' 'UOA' 'of'
 'the' 'module' 'to' 'be' 'created']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8335-L8463
ctuning/ck,ck/kernel.py,remove_action,"def remove_action(i):
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - normally should be 'module' already
              data_uoa    - UOA of the module to be created

              func        - action
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

               Output of 'update' function
            }

    """"""
    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    func=i.get('func','')

    if muoa=='':
       return {'return':1, 'error':'module UOA is not defined'}

    if duoa!='':
       muoa=duoa
       duoa=''

    # Find path to module
    ii={'module_uoa':cfg['module_name'],
        'data_uoa':muoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r

    pp=r['path']
    dd=r['dict']

    actions=dd.get('actions',{})

    # Check func and desc
    if o=='con':
       if func=='':
          r=inp({'text':'Enter function to be removed (or Enter to quit) - note that we remove only reference to this function from the module meta: '})
          func=r['string']

    # Check if empty
    if func=='':
       return {'return':1, 'error':'action (function) is not defined'}

    if func not in actions:
       return {'return':1, 'error':'action (function) is not found in the module'}

    del (actions[func])

    dd['actions']=actions

    # Update data entry
    if o=='con': out('')
    ii={'module_uoa':cfg['module_name'],
        'data_uoa':muoa,
        'dict':dd,
        'substitute':'yes',
        'sort_keys':'yes',
        'out':o}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=update(ii)
    if r['return']>0: return r

    if o=='con':
       out('')
       out('Reference to the function ""'+func+'"" was removed from module meta. Function body was not removed from the python code')

    return r",python,"def remove_action(i):
    """"""
    Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - normally should be 'module' already
              data_uoa    - UOA of the module to be created

              func        - action
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

               Output of 'update' function
            }

    """"""
    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    func=i.get('func','')

    if muoa=='':
       return {'return':1, 'error':'module UOA is not defined'}

    if duoa!='':
       muoa=duoa
       duoa=''

    # Find path to module
    ii={'module_uoa':cfg['module_name'],
        'data_uoa':muoa}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=load(ii)
    if r['return']>0: return r

    pp=r['path']
    dd=r['dict']

    actions=dd.get('actions',{})

    # Check func and desc
    if o=='con':
       if func=='':
          r=inp({'text':'Enter function to be removed (or Enter to quit) - note that we remove only reference to this function from the module meta: '})
          func=r['string']

    # Check if empty
    if func=='':
       return {'return':1, 'error':'action (function) is not defined'}

    if func not in actions:
       return {'return':1, 'error':'action (function) is not found in the module'}

    del (actions[func])

    dd['actions']=actions

    # Update data entry
    if o=='con': out('')
    ii={'module_uoa':cfg['module_name'],
        'data_uoa':muoa,
        'dict':dd,
        'substitute':'yes',
        'sort_keys':'yes',
        'out':o}
    if ruoa!='': ii['repo_uoa']=ruoa
    r=update(ii)
    if r['return']>0: return r

    if o=='con':
       out('')
       out('Reference to the function ""'+func+'"" was removed from module meta. Function body was not removed from the python code')

    return r","['def' 'remove_action' '(' 'i' ')' ':'
 '# Check if global writing is allowed' 'r' '=' 'check_writing' '(' '{'
 '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'o' '=' 'i'
 '.' 'get' '(' ""'out'"" ',' ""''"" ')' 'ruoa' '=' 'i' '.' 'get' '('
 ""'repo_uoa'"" ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ','
 ""''"" ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'func'
 '=' 'i' '.' 'get' '(' ""'func'"" ',' ""''"" ')' 'if' 'muoa' '==' ""''"" ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'module UOA is not defined'"" '}' 'if' 'duoa' '!=' ""''"" ':' 'muoa' '='
 'duoa' 'duoa' '=' ""''"" '# Find path to module' 'ii' '=' '{'
 ""'module_uoa'"" ':' 'cfg' '[' ""'module_name'"" ']' ',' ""'data_uoa'"" ':'
 'muoa' '}' 'if' 'ruoa' '!=' ""''"" ':' 'ii' '[' ""'repo_uoa'"" ']' '=' 'ruoa'
 'r' '=' 'load' '(' 'ii' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'pp' '=' 'r' '[' ""'path'"" ']' 'dd' '=' 'r' '[' ""'dict'"" ']'
 'actions' '=' 'dd' '.' 'get' '(' ""'actions'"" ',' '{' '}' ')'
 '# Check func and desc' 'if' 'o' '==' ""'con'"" ':' 'if' 'func' '==' ""''""
 ':' 'r' '=' 'inp' '(' '{' ""'text'"" ':'
 ""'Enter function to be removed (or Enter to quit) - note that we remove only reference to this function from the module meta: '""
 '}' ')' 'func' '=' 'r' '[' ""'string'"" ']' '# Check if empty' 'if' 'func'
 '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'action (function) is not defined'"" '}' 'if' 'func' 'not' 'in' 'actions'
 ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'action (function) is not found in the module'"" '}' 'del' '(' 'actions'
 '[' 'func' ']' ')' 'dd' '[' ""'actions'"" ']' '=' 'actions'
 '# Update data entry' 'if' 'o' '==' ""'con'"" ':' 'out' '(' ""''"" ')' 'ii'
 '=' '{' ""'module_uoa'"" ':' 'cfg' '[' ""'module_name'"" ']' ',' ""'data_uoa'""
 ':' 'muoa' ',' ""'dict'"" ':' 'dd' ',' ""'substitute'"" ':' ""'yes'"" ','
 ""'sort_keys'"" ':' ""'yes'"" ',' ""'out'"" ':' 'o' '}' 'if' 'ruoa' '!=' ""''""
 ':' 'ii' '[' ""'repo_uoa'"" ']' '=' 'ruoa' 'r' '=' 'update' '(' 'ii' ')'
 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'if' 'o' '=='
 ""'con'"" ':' 'out' '(' ""''"" ')' 'out' '('
 '\'Reference to the function ""\'' '+' 'func' '+'
 '\'"" was removed from module meta. Function body was not removed from the python code\''
 ')' 'return' 'r']","Input:  {
              (repo_uoa)  - repo UOA
              module_uoa  - normally should be 'module' already
              data_uoa    - UOA of the module to be created

              func        - action
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

               Output of 'update' function
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'normally' 'should' 'be' 'module' 'already' 'data_uoa' '-' 'UOA' 'of'
 'the' 'module' 'to' 'be' 'created']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8470-L8553
ctuning/ck,ck/kernel.py,list_actions,"def list_actions(i):
    """"""
    Input:  {
              (repo_uoa)   - repo UOA
              (module_uoa) - module_uoa, if =="""", use kernel
              (data_uoa)  
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              actions      - list of actions
            }

    """"""

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if muoa!='':
       if duoa!='':
          muoa=duoa
          duoa=''

       # Find path to module 'module' to get dummies
       ii={'action':'load',
           'module_uoa':cfg['module_name'],
           'data_uoa':muoa,
           'common_func':'yes'}
       if ruoa!='': ii['repo_uoa']=ruoa

       r=access(ii)
       if r['return']>0: return r

       dd=r['dict']
   
       actions=dd.get('actions',{})
    else:
       actions=cfg['actions']

    # If console, print actions
    if o=='con':
       for q in sorted(actions.keys()):
           s=q

           desc=actions[q].get('desc','')
           if desc!='': s+=' - '+desc

           out(s)

    return {'return':0, 'actions':actions}",python,"def list_actions(i):
    """"""
    Input:  {
              (repo_uoa)   - repo UOA
              (module_uoa) - module_uoa, if =="""", use kernel
              (data_uoa)  
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              actions      - list of actions
            }

    """"""

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    if muoa!='':
       if duoa!='':
          muoa=duoa
          duoa=''

       # Find path to module 'module' to get dummies
       ii={'action':'load',
           'module_uoa':cfg['module_name'],
           'data_uoa':muoa,
           'common_func':'yes'}
       if ruoa!='': ii['repo_uoa']=ruoa

       r=access(ii)
       if r['return']>0: return r

       dd=r['dict']
   
       actions=dd.get('actions',{})
    else:
       actions=cfg['actions']

    # If console, print actions
    if o=='con':
       for q in sorted(actions.keys()):
           s=q

           desc=actions[q].get('desc','')
           if desc!='': s+=' - '+desc

           out(s)

    return {'return':0, 'actions':actions}","['def' 'list_actions' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'""
 ',' ""''"" ')' 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')'
 'muoa' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i'
 '.' 'get' '(' ""'data_uoa'"" ',' ""''"" ')' 'if' 'muoa' '!=' ""''"" ':' 'if'
 'duoa' '!=' ""''"" ':' 'muoa' '=' 'duoa' 'duoa' '=' ""''""
 ""# Find path to module 'module' to get dummies"" 'ii' '=' '{' ""'action'""
 ':' ""'load'"" ',' ""'module_uoa'"" ':' 'cfg' '[' ""'module_name'"" ']' ','
 ""'data_uoa'"" ':' 'muoa' ',' ""'common_func'"" ':' ""'yes'"" '}' 'if' 'ruoa'
 '!=' ""''"" ':' 'ii' '[' ""'repo_uoa'"" ']' '=' 'ruoa' 'r' '=' 'access' '('
 'ii' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':' 'return' 'r' 'dd' '='
 'r' '[' ""'dict'"" ']' 'actions' '=' 'dd' '.' 'get' '(' ""'actions'"" ',' '{'
 '}' ')' 'else' ':' 'actions' '=' 'cfg' '[' ""'actions'"" ']'
 '# If console, print actions' 'if' 'o' '==' ""'con'"" ':' 'for' 'q' 'in'
 'sorted' '(' 'actions' '.' 'keys' '(' ')' ')' ':' 's' '=' 'q' 'desc' '='
 'actions' '[' 'q' ']' '.' 'get' '(' ""'desc'"" ',' ""''"" ')' 'if' 'desc'
 '!=' ""''"" ':' 's' '+=' ""' - '"" '+' 'desc' 'out' '(' 's' ')' 'return' '{'
 ""'return'"" ':' '0' ',' ""'actions'"" ':' 'actions' '}']","Input:  {
              (repo_uoa)   - repo UOA
              (module_uoa) - module_uoa, if =="""", use kernel
              (data_uoa)  
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              actions      - list of actions
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' '(' 'module_uoa' ')'
 '-' 'module_uoa' 'if' '==' 'use' 'kernel' '(' 'data_uoa' ')' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8560-L8615
ctuning/ck,ck/kernel.py,pull,"def pull(i):
    """"""
    Input:  {
              (repo_uoa)      - repo UOA, if needed
              module_uoa      - module UOA 
              data_uoa        - data UOA

              (filename)      - filename (with path) (if empty, set archive to 'yes')
                  or
              (cid[0])
                                if empty, create an archive of the entry
              (archive)       - if 'yes' pull whole entry as zip archive using filename or ck_archive.zip
              (all)           - if 'yes' and archive, add even special directories (.cm, .svn, .git, etc)


              (out)           - if 'json' or 'json_file', encode file and return in r
              (skip_writing)  - if 'yes', do not write file (not archive) to current directory

              (pattern)       - return only files with this pattern
              (patterns)      - multiple patterns (useful to pack mutiple points in experiments)

              (encode_file)   - if 'yes', encode file

              (skip_tmp)      - if 'yes', skip tmp files and directories
            }

    Output: {
              return                - return code =  0, if successful
                                                  >  0, if error
              (error)               - error text if return > 0
              (file_content_base64) - if i['to_json']=='yes', encoded file
              (filename)            - filename to record locally
            }

    """"""

    o=i.get('out','')

    tj=False
    if o=='json' or o=='json_file' or i.get('encode_file','')=='yes':
       tj=True

    st=i.get('skip_tmp','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    pat=i.get('pattern','')
    pats=i.get('patterns',[])
    if pat!='':
       pats.append(pat)

    fn=i.get('filename','')
    if fn=='':
       x=i.get('cids',[])
       if len(x)>0:
          fn=x[0]

    # Attempt to load data (to find path, etc)
    r=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    p=r['path']
    muoa=r['module_uoa']
    duoa=r['data_uoa']
    dd=r['dict']

    # How output
    sw=i.get('skip_writing','')

    # Prepare output
    rr={'return':0}

    # Check what to pull
    pfn=''

    if fn=='': 
       i['archive']='yes'

    delete_file=''

    if i.get('archive','')!='yes':
       # Get file
       pfn=os.path.normpath(os.path.join(p,fn))

       # Check that file is not getting outside paths ...
       if not pfn.startswith(p):
          return {'return':1, 'error':'path of file is outside entry'}

       if not os.path.isfile(pfn):
          return {'return':1, 'error':'file not found'}

       if not tj and sw!='yes':
          # Copy file to current directory
          if os.path.isfile(fn):
             return {'return':1, 'error':'file already exists in the current directory'}

          # Copy file
          import shutil
          shutil.copyfile(pfn,fn)

       py=os.path.split(fn)
       rr['filename']=py[1]

    else:
       # Prepare archive name
       if fn!='': 
          # Check that file is not getting outside paths ...
          fn=os.path.normpath(os.path.join(os.getcwd(),fn))
          if not pfn.startswith(os.getcwd()):
             return {'return':1, 'error':'archive filename should not have path'}

       else:
          if tj:
             # Generate tmp file
             import tempfile
             fd, fn=tempfile.mkstemp(suffix='.tmp', prefix='ck-') # suffix is important - CK will delete such file!
             os.close(fd)
             os.remove(fn)
             delete_file=fn
          else:
             fn=cfg['default_archive_name']
       pfn=fn

       if os.path.isfile(pfn):
          return {'return':1, 'error':'archive file already exists in the current directory'}

       # Prepare archive
       import zipfile

       zip_method=zipfile.ZIP_DEFLATED

       gaf=i.get('all','')

       fl={}

       if len(pats)>0:
          for q in pats:
              r=list_all_files({'path':p, 'all':gaf, 'pattern':q})
              if r['return']>0: return r

              flx=r['list']

              for k in flx:
                  fl[k]=flx[k]
       else:
          r=list_all_files({'path':p, 'all':gaf})
          if r['return']>0: return r

          fl=r['list']

       # Write archive
       try:
          f=open(pfn, 'wb')
          z=zipfile.ZipFile(f, 'w', zip_method)
          for fn in fl:
              if st!='yes' or not fn.startswith('tmp'):
                 p1=os.path.join(p, fn)
                 z.write(p1, fn, zip_method)
          z.close()
          f.close()

       except Exception as e:
          return {'return':1, 'error':'failed to prepare archive ('+format(e)+')'}

    # If add to JSON
    if tj:
       r=convert_file_to_upload_string({'filename':pfn})
       if r['return']>0: return r

       rr['file_content_base64']=r['file_content_base64']

       if delete_file!='': os.remove(delete_file)

    return rr",python,"def pull(i):
    """"""
    Input:  {
              (repo_uoa)      - repo UOA, if needed
              module_uoa      - module UOA 
              data_uoa        - data UOA

              (filename)      - filename (with path) (if empty, set archive to 'yes')
                  or
              (cid[0])
                                if empty, create an archive of the entry
              (archive)       - if 'yes' pull whole entry as zip archive using filename or ck_archive.zip
              (all)           - if 'yes' and archive, add even special directories (.cm, .svn, .git, etc)


              (out)           - if 'json' or 'json_file', encode file and return in r
              (skip_writing)  - if 'yes', do not write file (not archive) to current directory

              (pattern)       - return only files with this pattern
              (patterns)      - multiple patterns (useful to pack mutiple points in experiments)

              (encode_file)   - if 'yes', encode file

              (skip_tmp)      - if 'yes', skip tmp files and directories
            }

    Output: {
              return                - return code =  0, if successful
                                                  >  0, if error
              (error)               - error text if return > 0
              (file_content_base64) - if i['to_json']=='yes', encoded file
              (filename)            - filename to record locally
            }

    """"""

    o=i.get('out','')

    tj=False
    if o=='json' or o=='json_file' or i.get('encode_file','')=='yes':
       tj=True

    st=i.get('skip_tmp','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    pat=i.get('pattern','')
    pats=i.get('patterns',[])
    if pat!='':
       pats.append(pat)

    fn=i.get('filename','')
    if fn=='':
       x=i.get('cids',[])
       if len(x)>0:
          fn=x[0]

    # Attempt to load data (to find path, etc)
    r=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    p=r['path']
    muoa=r['module_uoa']
    duoa=r['data_uoa']
    dd=r['dict']

    # How output
    sw=i.get('skip_writing','')

    # Prepare output
    rr={'return':0}

    # Check what to pull
    pfn=''

    if fn=='': 
       i['archive']='yes'

    delete_file=''

    if i.get('archive','')!='yes':
       # Get file
       pfn=os.path.normpath(os.path.join(p,fn))

       # Check that file is not getting outside paths ...
       if not pfn.startswith(p):
          return {'return':1, 'error':'path of file is outside entry'}

       if not os.path.isfile(pfn):
          return {'return':1, 'error':'file not found'}

       if not tj and sw!='yes':
          # Copy file to current directory
          if os.path.isfile(fn):
             return {'return':1, 'error':'file already exists in the current directory'}

          # Copy file
          import shutil
          shutil.copyfile(pfn,fn)

       py=os.path.split(fn)
       rr['filename']=py[1]

    else:
       # Prepare archive name
       if fn!='': 
          # Check that file is not getting outside paths ...
          fn=os.path.normpath(os.path.join(os.getcwd(),fn))
          if not pfn.startswith(os.getcwd()):
             return {'return':1, 'error':'archive filename should not have path'}

       else:
          if tj:
             # Generate tmp file
             import tempfile
             fd, fn=tempfile.mkstemp(suffix='.tmp', prefix='ck-') # suffix is important - CK will delete such file!
             os.close(fd)
             os.remove(fn)
             delete_file=fn
          else:
             fn=cfg['default_archive_name']
       pfn=fn

       if os.path.isfile(pfn):
          return {'return':1, 'error':'archive file already exists in the current directory'}

       # Prepare archive
       import zipfile

       zip_method=zipfile.ZIP_DEFLATED

       gaf=i.get('all','')

       fl={}

       if len(pats)>0:
          for q in pats:
              r=list_all_files({'path':p, 'all':gaf, 'pattern':q})
              if r['return']>0: return r

              flx=r['list']

              for k in flx:
                  fl[k]=flx[k]
       else:
          r=list_all_files({'path':p, 'all':gaf})
          if r['return']>0: return r

          fl=r['list']

       # Write archive
       try:
          f=open(pfn, 'wb')
          z=zipfile.ZipFile(f, 'w', zip_method)
          for fn in fl:
              if st!='yes' or not fn.startswith('tmp'):
                 p1=os.path.join(p, fn)
                 z.write(p1, fn, zip_method)
          z.close()
          f.close()

       except Exception as e:
          return {'return':1, 'error':'failed to prepare archive ('+format(e)+')'}

    # If add to JSON
    if tj:
       r=convert_file_to_upload_string({'filename':pfn})
       if r['return']>0: return r

       rr['file_content_base64']=r['file_content_base64']

       if delete_file!='': os.remove(delete_file)

    return rr","['def' 'pull' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'tj' '=' 'False' 'if' 'o' '==' ""'json'"" 'or' 'o' '==' ""'json_file'""
 'or' 'i' '.' 'get' '(' ""'encode_file'"" ',' ""''"" ')' '==' ""'yes'"" ':' 'tj'
 '=' 'True' 'st' '=' 'i' '.' 'get' '(' ""'skip_tmp'"" ',' ""''"" ')' 'ruoa'
 '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get'
 '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'""
 ',' ""''"" ')' 'pat' '=' 'i' '.' 'get' '(' ""'pattern'"" ',' ""''"" ')' 'pats'
 '=' 'i' '.' 'get' '(' ""'patterns'"" ',' '[' ']' ')' 'if' 'pat' '!=' ""''""
 ':' 'pats' '.' 'append' '(' 'pat' ')' 'fn' '=' 'i' '.' 'get' '('
 ""'filename'"" ',' ""''"" ')' 'if' 'fn' '==' ""''"" ':' 'x' '=' 'i' '.' 'get'
 '(' ""'cids'"" ',' '[' ']' ')' 'if' 'len' '(' 'x' ')' '>' '0' ':' 'fn' '='
 'x' '[' '0' ']' '# Attempt to load data (to find path, etc)' 'r' '='
 'load' '(' '{' ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ','
 ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'p' '=' 'r' '[' ""'path'"" ']' 'muoa' '=' 'r' '['
 ""'module_uoa'"" ']' 'duoa' '=' 'r' '[' ""'data_uoa'"" ']' 'dd' '=' 'r' '['
 ""'dict'"" ']' '# How output' 'sw' '=' 'i' '.' 'get' '(' ""'skip_writing'""
 ',' ""''"" ')' '# Prepare output' 'rr' '=' '{' ""'return'"" ':' '0' '}'
 '# Check what to pull' 'pfn' '=' ""''"" 'if' 'fn' '==' ""''"" ':' 'i' '['
 ""'archive'"" ']' '=' ""'yes'"" 'delete_file' '=' ""''"" 'if' 'i' '.' 'get' '('
 ""'archive'"" ',' ""''"" ')' '!=' ""'yes'"" ':' '# Get file' 'pfn' '=' 'os' '.'
 'path' '.' 'normpath' '(' 'os' '.' 'path' '.' 'join' '(' 'p' ',' 'fn' ')'
 ')' '# Check that file is not getting outside paths ...' 'if' 'not' 'pfn'
 '.' 'startswith' '(' 'p' ')' ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'path of file is outside entry'"" '}' 'if' 'not' 'os' '.'
 'path' '.' 'isfile' '(' 'pfn' ')' ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'file not found'"" '}' 'if' 'not' 'tj' 'and' 'sw' '!='
 ""'yes'"" ':' '# Copy file to current directory' 'if' 'os' '.' 'path' '.'
 'isfile' '(' 'fn' ')' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'""
 ':' ""'file already exists in the current directory'"" '}' '# Copy file'
 'import' 'shutil' 'shutil' '.' 'copyfile' '(' 'pfn' ',' 'fn' ')' 'py' '='
 'os' '.' 'path' '.' 'split' '(' 'fn' ')' 'rr' '[' ""'filename'"" ']' '='
 'py' '[' '1' ']' 'else' ':' '# Prepare archive name' 'if' 'fn' '!=' ""''""
 ':' '# Check that file is not getting outside paths ...' 'fn' '=' 'os'
 '.' 'path' '.' 'normpath' '(' 'os' '.' 'path' '.' 'join' '(' 'os' '.'
 'getcwd' '(' ')' ',' 'fn' ')' ')' 'if' 'not' 'pfn' '.' 'startswith' '('
 'os' '.' 'getcwd' '(' ')' ')' ':' 'return' '{' ""'return'"" ':' '1' ','
 ""'error'"" ':' ""'archive filename should not have path'"" '}' 'else' ':'
 'if' 'tj' ':' '# Generate tmp file' 'import' 'tempfile' 'fd' ',' 'fn' '='
 'tempfile' '.' 'mkstemp' '(' 'suffix' '=' ""'.tmp'"" ',' 'prefix' '='
 ""'ck-'"" ')' '# suffix is important - CK will delete such file!' 'os' '.'
 'close' '(' 'fd' ')' 'os' '.' 'remove' '(' 'fn' ')' 'delete_file' '='
 'fn' 'else' ':' 'fn' '=' 'cfg' '[' ""'default_archive_name'"" ']' 'pfn' '='
 'fn' 'if' 'os' '.' 'path' '.' 'isfile' '(' 'pfn' ')' ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'archive file already exists in the current directory'"" '}'
 '# Prepare archive' 'import' 'zipfile' 'zip_method' '=' 'zipfile' '.'
 'ZIP_DEFLATED' 'gaf' '=' 'i' '.' 'get' '(' ""'all'"" ',' ""''"" ')' 'fl' '='
 '{' '}' 'if' 'len' '(' 'pats' ')' '>' '0' ':' 'for' 'q' 'in' 'pats' ':'
 'r' '=' 'list_all_files' '(' '{' ""'path'"" ':' 'p' ',' ""'all'"" ':' 'gaf'
 ',' ""'pattern'"" ':' 'q' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'flx' '=' 'r' '[' ""'list'"" ']' 'for' 'k' 'in' 'flx' ':' 'fl'
 '[' 'k' ']' '=' 'flx' '[' 'k' ']' 'else' ':' 'r' '=' 'list_all_files' '('
 '{' ""'path'"" ':' 'p' ',' ""'all'"" ':' 'gaf' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'fl' '=' 'r' '[' ""'list'"" ']'
 '# Write archive' 'try' ':' 'f' '=' 'open' '(' 'pfn' ',' ""'wb'"" ')' 'z'
 '=' 'zipfile' '.' 'ZipFile' '(' 'f' ',' ""'w'"" ',' 'zip_method' ')' 'for'
 'fn' 'in' 'fl' ':' 'if' 'st' '!=' ""'yes'"" 'or' 'not' 'fn' '.'
 'startswith' '(' ""'tmp'"" ')' ':' 'p1' '=' 'os' '.' 'path' '.' 'join' '('
 'p' ',' 'fn' ')' 'z' '.' 'write' '(' 'p1' ',' 'fn' ',' 'zip_method' ')'
 'z' '.' 'close' '(' ')' 'f' '.' 'close' '(' ')' 'except' 'Exception' 'as'
 'e' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'failed to prepare archive ('"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}'
 '# If add to JSON' 'if' 'tj' ':' 'r' '=' 'convert_file_to_upload_string'
 '(' '{' ""'filename'"" ':' 'pfn' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>'
 '0' ':' 'return' 'r' 'rr' '[' ""'file_content_base64'"" ']' '=' 'r' '['
 ""'file_content_base64'"" ']' 'if' 'delete_file' '!=' ""''"" ':' 'os' '.'
 'remove' '(' 'delete_file' ')' 'return' 'rr']","Input:  {
              (repo_uoa)      - repo UOA, if needed
              module_uoa      - module UOA 
              data_uoa        - data UOA

              (filename)      - filename (with path) (if empty, set archive to 'yes')
                  or
              (cid[0])
                                if empty, create an archive of the entry
              (archive)       - if 'yes' pull whole entry as zip archive using filename or ck_archive.zip
              (all)           - if 'yes' and archive, add even special directories (.cm, .svn, .git, etc)


              (out)           - if 'json' or 'json_file', encode file and return in r
              (skip_writing)  - if 'yes', do not write file (not archive) to current directory

              (pattern)       - return only files with this pattern
              (patterns)      - multiple patterns (useful to pack mutiple points in experiments)

              (encode_file)   - if 'yes', encode file

              (skip_tmp)      - if 'yes', skip tmp files and directories
            }

    Output: {
              return                - return code =  0, if successful
                                                  >  0, if error
              (error)               - error text if return > 0
              (file_content_base64) - if i['to_json']=='yes', encoded file
              (filename)            - filename to record locally
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'if' 'needed'
 'module_uoa' '-' 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8622-L8797
ctuning/ck,ck/kernel.py,push,"def push(i):
    """"""
    Input:  {
              (repo_uoa)            - repo UOA, if needed
              module_uoa            - module UOA 
              data_uoa              - data UOA

              (filename)            - local filename 
                  or
              (cid[0])

              (extra_path)          - extra path inside entry (create if doesn't exist)

              (file_content_base64) - if !='', take its content and record into filename

              (archive)             - if 'yes' push to entry and unzip ...

              (overwrite)           - if 'yes', overwrite files
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    # Check file
    fn=i.get('filename','')
    if fn=='':
       x=i.get('cids',[])
       if len(x)>0:
          fn=x[0]

    if fn=='':
       return {'return':1, 'error':'filename is empty'}

    fcb=False
    if 'file_content_base64' in i:
       import base64

       bin=base64.urlsafe_b64decode(i['file_content_base64'].encode('utf8')) # convert from unicode to str since base64 works on strings
                                                                   # should be safe in Python 2.x and 3.x
       fcb=True
    else:
       if not os.path.isfile(fn):
          return {'return':1, 'error':'file '+fn+' not found'}

    # Attempt to load data (to find path, etc)
    rx=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if rx['return']>0: return rx

    p=rx['path']
    muoa=rx['module_uoa']
    duoa=rx['data_uoa']
    dd=rx['dict']

    px=os.path.normpath(os.path.join(p, cfg['subdir_ck_ext']))

    ruoa=rx['repo_uoa']
    ruid=rx['repo_uid']

    # Check repo/module writing
    ii={'module_uoa':muoa, 'repo_uoa':ruoa, 'repo_uid':ruid}
    r=check_writing(ii)
    if r['return']>0: return r
    rd=r.get('repo_dict',{})

    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    # Prepare path
    p1=i.get('extra_path','')
    if p1!='':
       p2=os.path.normpath(os.path.join(p,p1))
       if not p2.startswith(p):
          return {'return':1,'error':'extra path is outside entry'}

       p=p2

    # Create missing dirs
    if not os.path.isdir(p): os.makedirs(p)

    overwrite=i.get('overwrite','')

    # Copy or record file
    p3=os.path.normpath(os.path.join(p, fn))
    if not p3.startswith(p3):
       return {'return':1,'error':'extra path is outside entry'}

    if p3.startswith(px):
       return {'return':1, 'error':'path points to the special directory with meta info'}

    if os.path.isfile(p3) and overwrite!='yes':
       return {'return':1,'error':'file already exists in the entry'}

    if fcb:
       try:
         f=open(p3, 'wb')
         f.write(bin)
         f.close()
       except Exception as e:
          return {'return':1, 'error':'problem writing text file='+p3+' ('+format(e)+')'}
    else:
       import shutil
       shutil.copyfile(fn, p3)

    # Process if archive
    y=''
    if i.get('archive','')=='yes':
       rx=unzip_file({'archive_file':p3,
                      'path':p,
                      'overwrite':overwrite,
                      'delete_after_unzip':'yes'})
       if rx['return']>0: return rx
       y='and unziped '

    if rshared!='':
       ppp=os.getcwd()

       pp=os.path.split(p)
       pp0=pp[0]
       pp1=pp[1]

       os.chdir(pp0)

       ss=cfg['repo_types'][rshared]['add'].replace('$#files#$', pp1)
       rx=os.system(ss)

       os.chdir(ppp)

    if o=='con':
       out('File was pushed '+y+'successfully!')

    return {'return':0}",python,"def push(i):
    """"""
    Input:  {
              (repo_uoa)            - repo UOA, if needed
              module_uoa            - module UOA 
              data_uoa              - data UOA

              (filename)            - local filename 
                  or
              (cid[0])

              (extra_path)          - extra path inside entry (create if doesn't exist)

              (file_content_base64) - if !='', take its content and record into filename

              (archive)             - if 'yes' push to entry and unzip ...

              (overwrite)           - if 'yes', overwrite files
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    # Check if global writing is allowed
    r=check_writing({})
    if r['return']>0: return r

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    # Check file
    fn=i.get('filename','')
    if fn=='':
       x=i.get('cids',[])
       if len(x)>0:
          fn=x[0]

    if fn=='':
       return {'return':1, 'error':'filename is empty'}

    fcb=False
    if 'file_content_base64' in i:
       import base64

       bin=base64.urlsafe_b64decode(i['file_content_base64'].encode('utf8')) # convert from unicode to str since base64 works on strings
                                                                   # should be safe in Python 2.x and 3.x
       fcb=True
    else:
       if not os.path.isfile(fn):
          return {'return':1, 'error':'file '+fn+' not found'}

    # Attempt to load data (to find path, etc)
    rx=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if rx['return']>0: return rx

    p=rx['path']
    muoa=rx['module_uoa']
    duoa=rx['data_uoa']
    dd=rx['dict']

    px=os.path.normpath(os.path.join(p, cfg['subdir_ck_ext']))

    ruoa=rx['repo_uoa']
    ruid=rx['repo_uid']

    # Check repo/module writing
    ii={'module_uoa':muoa, 'repo_uoa':ruoa, 'repo_uid':ruid}
    r=check_writing(ii)
    if r['return']>0: return r
    rd=r.get('repo_dict',{})

    rshared=rd.get('shared','')
    rsync=rd.get('sync','')

    # Prepare path
    p1=i.get('extra_path','')
    if p1!='':
       p2=os.path.normpath(os.path.join(p,p1))
       if not p2.startswith(p):
          return {'return':1,'error':'extra path is outside entry'}

       p=p2

    # Create missing dirs
    if not os.path.isdir(p): os.makedirs(p)

    overwrite=i.get('overwrite','')

    # Copy or record file
    p3=os.path.normpath(os.path.join(p, fn))
    if not p3.startswith(p3):
       return {'return':1,'error':'extra path is outside entry'}

    if p3.startswith(px):
       return {'return':1, 'error':'path points to the special directory with meta info'}

    if os.path.isfile(p3) and overwrite!='yes':
       return {'return':1,'error':'file already exists in the entry'}

    if fcb:
       try:
         f=open(p3, 'wb')
         f.write(bin)
         f.close()
       except Exception as e:
          return {'return':1, 'error':'problem writing text file='+p3+' ('+format(e)+')'}
    else:
       import shutil
       shutil.copyfile(fn, p3)

    # Process if archive
    y=''
    if i.get('archive','')=='yes':
       rx=unzip_file({'archive_file':p3,
                      'path':p,
                      'overwrite':overwrite,
                      'delete_after_unzip':'yes'})
       if rx['return']>0: return rx
       y='and unziped '

    if rshared!='':
       ppp=os.getcwd()

       pp=os.path.split(p)
       pp0=pp[0]
       pp1=pp[1]

       os.chdir(pp0)

       ss=cfg['repo_types'][rshared]['add'].replace('$#files#$', pp1)
       rx=os.system(ss)

       os.chdir(ppp)

    if o=='con':
       out('File was pushed '+y+'successfully!')

    return {'return':0}","['def' 'push' '(' 'i' ')' ':' '# Check if global writing is allowed' 'r'
 '=' 'check_writing' '(' '{' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0'
 ':' 'return' 'r' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')' 'ruoa'
 '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'muoa' '=' 'i' '.' 'get'
 '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.' 'get' '(' ""'data_uoa'""
 ',' ""''"" ')' '# Check file' 'fn' '=' 'i' '.' 'get' '(' ""'filename'"" ','
 ""''"" ')' 'if' 'fn' '==' ""''"" ':' 'x' '=' 'i' '.' 'get' '(' ""'cids'"" ','
 '[' ']' ')' 'if' 'len' '(' 'x' ')' '>' '0' ':' 'fn' '=' 'x' '[' '0' ']'
 'if' 'fn' '==' ""''"" ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'filename is empty'"" '}' 'fcb' '=' 'False' 'if' ""'file_content_base64'""
 'in' 'i' ':' 'import' 'base64' 'bin' '=' 'base64' '.' 'urlsafe_b64decode'
 '(' 'i' '[' ""'file_content_base64'"" ']' '.' 'encode' '(' ""'utf8'"" ')' ')'
 '# convert from unicode to str since base64 works on strings'
 '# should be safe in Python 2.x and 3.x' 'fcb' '=' 'True' 'else' ':' 'if'
 'not' 'os' '.' 'path' '.' 'isfile' '(' 'fn' ')' ':' 'return' '{'
 ""'return'"" ':' '1' ',' ""'error'"" ':' ""'file '"" '+' 'fn' '+'
 ""' not found'"" '}' '# Attempt to load data (to find path, etc)' 'rx' '='
 'load' '(' '{' ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ','
 ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'rx' 'p' '=' 'rx' '[' ""'path'"" ']' 'muoa' '=' 'rx' '['
 ""'module_uoa'"" ']' 'duoa' '=' 'rx' '[' ""'data_uoa'"" ']' 'dd' '=' 'rx' '['
 ""'dict'"" ']' 'px' '=' 'os' '.' 'path' '.' 'normpath' '(' 'os' '.' 'path'
 '.' 'join' '(' 'p' ',' 'cfg' '[' ""'subdir_ck_ext'"" ']' ')' ')' 'ruoa' '='
 'rx' '[' ""'repo_uoa'"" ']' 'ruid' '=' 'rx' '[' ""'repo_uid'"" ']'
 '# Check repo/module writing' 'ii' '=' '{' ""'module_uoa'"" ':' 'muoa' ','
 ""'repo_uoa'"" ':' 'ruoa' ',' ""'repo_uid'"" ':' 'ruid' '}' 'r' '='
 'check_writing' '(' 'ii' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'rd' '=' 'r' '.' 'get' '(' ""'repo_dict'"" ',' '{' '}' ')'
 'rshared' '=' 'rd' '.' 'get' '(' ""'shared'"" ',' ""''"" ')' 'rsync' '=' 'rd'
 '.' 'get' '(' ""'sync'"" ',' ""''"" ')' '# Prepare path' 'p1' '=' 'i' '.'
 'get' '(' ""'extra_path'"" ',' ""''"" ')' 'if' 'p1' '!=' ""''"" ':' 'p2' '='
 'os' '.' 'path' '.' 'normpath' '(' 'os' '.' 'path' '.' 'join' '(' 'p' ','
 'p1' ')' ')' 'if' 'not' 'p2' '.' 'startswith' '(' 'p' ')' ':' 'return'
 '{' ""'return'"" ':' '1' ',' ""'error'"" ':' ""'extra path is outside entry'""
 '}' 'p' '=' 'p2' '# Create missing dirs' 'if' 'not' 'os' '.' 'path' '.'
 'isdir' '(' 'p' ')' ':' 'os' '.' 'makedirs' '(' 'p' ')' 'overwrite' '='
 'i' '.' 'get' '(' ""'overwrite'"" ',' ""''"" ')' '# Copy or record file' 'p3'
 '=' 'os' '.' 'path' '.' 'normpath' '(' 'os' '.' 'path' '.' 'join' '(' 'p'
 ',' 'fn' ')' ')' 'if' 'not' 'p3' '.' 'startswith' '(' 'p3' ')' ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'extra path is outside entry'"" '}' 'if' 'p3' '.' 'startswith' '(' 'px'
 ')' ':' 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'path points to the special directory with meta info'"" '}' 'if' 'os' '.'
 'path' '.' 'isfile' '(' 'p3' ')' 'and' 'overwrite' '!=' ""'yes'"" ':'
 'return' '{' ""'return'"" ':' '1' ',' ""'error'"" ':'
 ""'file already exists in the entry'"" '}' 'if' 'fcb' ':' 'try' ':' 'f' '='
 'open' '(' 'p3' ',' ""'wb'"" ')' 'f' '.' 'write' '(' 'bin' ')' 'f' '.'
 'close' '(' ')' 'except' 'Exception' 'as' 'e' ':' 'return' '{' ""'return'""
 ':' '1' ',' ""'error'"" ':' ""'problem writing text file='"" '+' 'p3' '+'
 ""' ('"" '+' 'format' '(' 'e' ')' '+' ""')'"" '}' 'else' ':' 'import'
 'shutil' 'shutil' '.' 'copyfile' '(' 'fn' ',' 'p3' ')'
 '# Process if archive' 'y' '=' ""''"" 'if' 'i' '.' 'get' '(' ""'archive'""
 ',' ""''"" ')' '==' ""'yes'"" ':' 'rx' '=' 'unzip_file' '(' '{'
 ""'archive_file'"" ':' 'p3' ',' ""'path'"" ':' 'p' ',' ""'overwrite'"" ':'
 'overwrite' ',' ""'delete_after_unzip'"" ':' ""'yes'"" '}' ')' 'if' 'rx' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'y' '=' ""'and unziped '"" 'if'
 'rshared' '!=' ""''"" ':' 'ppp' '=' 'os' '.' 'getcwd' '(' ')' 'pp' '=' 'os'
 '.' 'path' '.' 'split' '(' 'p' ')' 'pp0' '=' 'pp' '[' '0' ']' 'pp1' '='
 'pp' '[' '1' ']' 'os' '.' 'chdir' '(' 'pp0' ')' 'ss' '=' 'cfg' '['
 ""'repo_types'"" ']' '[' 'rshared' ']' '[' ""'add'"" ']' '.' 'replace' '('
 ""'$#files#$'"" ',' 'pp1' ')' 'rx' '=' 'os' '.' 'system' '(' 'ss' ')' 'os'
 '.' 'chdir' '(' 'ppp' ')' 'if' 'o' '==' ""'con'"" ':' 'out' '('
 ""'File was pushed '"" '+' 'y' '+' ""'successfully!'"" ')' 'return' '{'
 ""'return'"" ':' '0' '}']","Input:  {
              (repo_uoa)            - repo UOA, if needed
              module_uoa            - module UOA 
              data_uoa              - data UOA

              (filename)            - local filename 
                  or
              (cid[0])

              (extra_path)          - extra path inside entry (create if doesn't exist)

              (file_content_base64) - if !='', take its content and record into filename

              (archive)             - if 'yes' push to entry and unzip ...

              (overwrite)           - if 'yes', overwrite files
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'if' 'needed'
 'module_uoa' '-' 'module' 'UOA' 'data_uoa' '-' 'data' 'UOA']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8804-L8949
ctuning/ck,ck/kernel.py,unzip_file,"def unzip_file(i):
    """"""
    Input:  {
              archive_file         - full path to zip file  
              (path)               - path where unzip (current if empty)
              (overwrite)          - if 'yes', overwrite
              (delete_after_unzip) - if 'yes', delete original zip file after unzipping
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              skipped       - list of files which was not overwritten
           }

    """"""

    import zipfile

    p=i.get('path','')
    if p=='':
       p=os.getcwd()

    p3=i['archive_file']

    overwrite=i.get('overwrite','')

    dau=i.get('delete_after_unzip','')

    s=[]

    f=open(p3,'rb')
    z=zipfile.ZipFile(f)
    for d in z.namelist():
        if not d.startswith('.') and not d.startswith('/') and not d.startswith('\\'):
           pp=os.path.join(p,d)
           if d.endswith('/'): 
              # create directory 
              if not os.path.exists(pp): os.makedirs(pp)
           else:
              ppd=os.path.dirname(pp)
              if not os.path.exists(ppd): os.makedirs(ppd)

              # extract file
              if os.path.isfile(pp) and overwrite!='yes':
                 s.append(d)
              else:
                 fo=open(pp, 'wb')
                 fo.write(z.read(d))
                 fo.close()
    f.close()

    if dau=='yes':
       os.remove(p3)

    return {'return':0, 'skipped':s}",python,"def unzip_file(i):
    """"""
    Input:  {
              archive_file         - full path to zip file  
              (path)               - path where unzip (current if empty)
              (overwrite)          - if 'yes', overwrite
              (delete_after_unzip) - if 'yes', delete original zip file after unzipping
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              skipped       - list of files which was not overwritten
           }

    """"""

    import zipfile

    p=i.get('path','')
    if p=='':
       p=os.getcwd()

    p3=i['archive_file']

    overwrite=i.get('overwrite','')

    dau=i.get('delete_after_unzip','')

    s=[]

    f=open(p3,'rb')
    z=zipfile.ZipFile(f)
    for d in z.namelist():
        if not d.startswith('.') and not d.startswith('/') and not d.startswith('\\'):
           pp=os.path.join(p,d)
           if d.endswith('/'): 
              # create directory 
              if not os.path.exists(pp): os.makedirs(pp)
           else:
              ppd=os.path.dirname(pp)
              if not os.path.exists(ppd): os.makedirs(ppd)

              # extract file
              if os.path.isfile(pp) and overwrite!='yes':
                 s.append(d)
              else:
                 fo=open(pp, 'wb')
                 fo.write(z.read(d))
                 fo.close()
    f.close()

    if dau=='yes':
       os.remove(p3)

    return {'return':0, 'skipped':s}","['def' 'unzip_file' '(' 'i' ')' ':' 'import' 'zipfile' 'p' '=' 'i' '.'
 'get' '(' ""'path'"" ',' ""''"" ')' 'if' 'p' '==' ""''"" ':' 'p' '=' 'os' '.'
 'getcwd' '(' ')' 'p3' '=' 'i' '[' ""'archive_file'"" ']' 'overwrite' '='
 'i' '.' 'get' '(' ""'overwrite'"" ',' ""''"" ')' 'dau' '=' 'i' '.' 'get' '('
 ""'delete_after_unzip'"" ',' ""''"" ')' 's' '=' '[' ']' 'f' '=' 'open' '('
 'p3' ',' ""'rb'"" ')' 'z' '=' 'zipfile' '.' 'ZipFile' '(' 'f' ')' 'for' 'd'
 'in' 'z' '.' 'namelist' '(' ')' ':' 'if' 'not' 'd' '.' 'startswith' '('
 ""'.'"" ')' 'and' 'not' 'd' '.' 'startswith' '(' ""'/'"" ')' 'and' 'not' 'd'
 '.' 'startswith' '(' ""'\\\\'"" ')' ':' 'pp' '=' 'os' '.' 'path' '.' 'join'
 '(' 'p' ',' 'd' ')' 'if' 'd' '.' 'endswith' '(' ""'/'"" ')' ':'
 '# create directory ' 'if' 'not' 'os' '.' 'path' '.' 'exists' '(' 'pp'
 ')' ':' 'os' '.' 'makedirs' '(' 'pp' ')' 'else' ':' 'ppd' '=' 'os' '.'
 'path' '.' 'dirname' '(' 'pp' ')' 'if' 'not' 'os' '.' 'path' '.' 'exists'
 '(' 'ppd' ')' ':' 'os' '.' 'makedirs' '(' 'ppd' ')' '# extract file' 'if'
 'os' '.' 'path' '.' 'isfile' '(' 'pp' ')' 'and' 'overwrite' '!=' ""'yes'""
 ':' 's' '.' 'append' '(' 'd' ')' 'else' ':' 'fo' '=' 'open' '(' 'pp' ','
 ""'wb'"" ')' 'fo' '.' 'write' '(' 'z' '.' 'read' '(' 'd' ')' ')' 'fo' '.'
 'close' '(' ')' 'f' '.' 'close' '(' ')' 'if' 'dau' '==' ""'yes'"" ':' 'os'
 '.' 'remove' '(' 'p3' ')' 'return' '{' ""'return'"" ':' '0' ',' ""'skipped'""
 ':' 's' '}']","Input:  {
              archive_file         - full path to zip file  
              (path)               - path where unzip (current if empty)
              (overwrite)          - if 'yes', overwrite
              (delete_after_unzip) - if 'yes', delete original zip file after unzipping
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              skipped       - list of files which was not overwritten
           }","['Input' ':' '{' 'archive_file' '-' 'full' 'path' 'to' 'zip' 'file' '('
 'path' ')' '-' 'path' 'where' 'unzip' '(' 'current' 'if' 'empty' ')' '('
 'overwrite' ')' '-' 'if' 'yes' 'overwrite' '(' 'delete_after_unzip' ')'
 '-' 'if' 'yes' 'delete' 'original' 'zip' 'file' 'after' 'unzipping' '}']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L8956-L9013
ctuning/ck,ck/kernel.py,list_files,"def list_files(i):
    """"""
    Input:  {
              (repo_uoa)   
              (module_uoa) 
              (data_uoa)  

              parameters for function 'list_all_files'
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of list all files
            }

    """"""

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    # Get info about entry
    r=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    p=r['path']

    # Get files
    ii={'path':p}
    if i.get('limit','')!='': ii['limit']=i['limit']
    if i.get('number','')!='': ii['number']=i['number']
    if i.get('all','')!='': ii['all']=i['all']

    r=list_all_files(ii)
    if r['return']>0: return r

    if o=='con':
       for q in r.get('list',[]):
           out(q)

    return r",python,"def list_files(i):
    """"""
    Input:  {
              (repo_uoa)   
              (module_uoa) 
              (data_uoa)  

              parameters for function 'list_all_files'
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of list all files
            }

    """"""

    o=i.get('out','')

    ruoa=i.get('repo_uoa','')
    muoa=i.get('module_uoa','')
    duoa=i.get('data_uoa','')

    # Get info about entry
    r=load({'repo_uoa':ruoa, 'module_uoa':muoa, 'data_uoa':duoa})
    if r['return']>0: return r

    p=r['path']

    # Get files
    ii={'path':p}
    if i.get('limit','')!='': ii['limit']=i['limit']
    if i.get('number','')!='': ii['number']=i['number']
    if i.get('all','')!='': ii['all']=i['all']

    r=list_all_files(ii)
    if r['return']>0: return r

    if o=='con':
       for q in r.get('list',[]):
           out(q)

    return r","['def' 'list_files' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ','
 ""''"" ')' 'ruoa' '=' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' 'muoa'
 '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''"" ')' 'duoa' '=' 'i' '.'
 'get' '(' ""'data_uoa'"" ',' ""''"" ')' '# Get info about entry' 'r' '='
 'load' '(' '{' ""'repo_uoa'"" ':' 'ruoa' ',' ""'module_uoa'"" ':' 'muoa' ','
 ""'data_uoa'"" ':' 'duoa' '}' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'p' '=' 'r' '[' ""'path'"" ']' '# Get files' 'ii' '=' '{'
 ""'path'"" ':' 'p' '}' 'if' 'i' '.' 'get' '(' ""'limit'"" ',' ""''"" ')' '!='
 ""''"" ':' 'ii' '[' ""'limit'"" ']' '=' 'i' '[' ""'limit'"" ']' 'if' 'i' '.'
 'get' '(' ""'number'"" ',' ""''"" ')' '!=' ""''"" ':' 'ii' '[' ""'number'"" ']'
 '=' 'i' '[' ""'number'"" ']' 'if' 'i' '.' 'get' '(' ""'all'"" ',' ""''"" ')'
 '!=' ""''"" ':' 'ii' '[' ""'all'"" ']' '=' 'i' '[' ""'all'"" ']' 'r' '='
 'list_all_files' '(' 'ii' ')' 'if' 'r' '[' ""'return'"" ']' '>' '0' ':'
 'return' 'r' 'if' 'o' '==' ""'con'"" ':' 'for' 'q' 'in' 'r' '.' 'get' '('
 ""'list'"" ',' '[' ']' ')' ':' 'out' '(' 'q' ')' 'return' 'r']","Input:  {
              (repo_uoa)   
              (module_uoa) 
              (data_uoa)  

              parameters for function 'list_all_files'
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of list all files
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '(' 'module_uoa' ')' '(' 'data_uoa'
 ')']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L9020-L9065
ctuning/ck,ck/kernel.py,access,"def access(i):

    """"""
    Input:  Can be dictionary or string (string will be converted to dictionary)

            {
               action

               module_uoa or CID -> converted to cid
                 or
               (cid1)            -  if doesn't have = and doesn't start from -- or - or @ -> appended to cids[]
               (cid2)            -  if doesn't have = and doesn't start from -- or - or @ -> appended to cids[]
               (cid3)            -  if doesn't have = and doesn't start from -- or - or @ -> appended to cids[]
                 or
               (repo_uoa)
               (module_uoa)
               (data_uoa)

               (out=type)     Module output
                              == ''              - none
                              == 'con'           - console interaction (if from CMD, default)
                              == 'json'          - return dict as json to console
                              == 'json_with_sep' - separation line and return dict as json to console
                              == 'json_file'     - return dict as json to file

               (out_file)     Output file if out=='json_file'

               (con_encoding) - force encoding for IO
               (ck_profile)   - if 'yes', profile CK

               INPUT TO A GIVEN FUNCTION


               NOTE: If INPUT is a string and it will be converted to INPUT dictionary as follows (the same as CK command line):

                     ck key1=value1    -> converted to {key1:value1}

                        -key10         -> converted to {key10:""yes""}
                        -key11=value11 -> converted to {key11:value11}

                        --key12         -> converted to {key12:""yes""}
                        --key13=value13 -> converted to {key13:value13}


                     @file_json         -> JSON from this file will be merged with INPUT
                     @@                 -> CK will ask user ot enter manually JSON from console and merge with INPUT
                     @@key              -> Enter JSON manually from console and merge with INPUT under this key

                     @@@cmd_json        -> convert string to JSON (special format) and merge with INPUT

                     -- xyz             -> add everything after -- to ""unparsed_cmd"" key in INPUT

                     When string is converted to INPUT dictionary, ""cmd"" variable is set to True
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              OUTPUT FROM A GIVEN FUNCTION
            }

    """"""

    global con_encoding

#    # Set fresh configuration for each access - very costly
#    if cfg.get('loading_config','') == '':
#        cfg['loading_config'] = 'yes'
#        r=access({'action':'load',
#                  'repo_uoa':cfg['repo_name_default'],
#                  'module_uoa':cfg['subdir_kernel'],
#                  'data_uoa':cfg['subdir_kernel_default']})
#        if r['return']==0:
#           cfg.update(r['dict'])
#
#        r=access({'action':'load',
#                  'repo_uoa':cfg['repo_name_local'],
#                  'module_uoa':cfg['subdir_kernel'],
#                  'data_uoa':cfg['subdir_kernel_default']})
#        if r['return']==0:
#           cfg.update(r['dict'])
#        cfg['loading_config'] = ''

    rr={'return':0}
    ii={}
    cmd=False
    o=''

    ### If input is string, split into list and process in the next condition
    if type(i)==str:
       cmd=True
       x=i.split(' ')
       i=x 

    ### If input is a list
    if type(i)==list:
       if len(i)==1 and i[0].strip()=='test_install':
          return rr # installation test

       cmd=True
       rr=convert_ck_list_to_dict(i)
       if rr['return']==0:
          i=rr.get('ck_dict',{})

          if i.get('out','')=='': i['out']='con' # Default output is console 
                                                 # if called from CMD or with string

    o=''
    if rr['return']==0:
       # Check output mode
       o=i.get('out','')

       ### If profile
       cp=i.get('ck_profile','')
       if cp=='yes':
          import time
          start_time = time.time()

       ### Process request ######################################

       if i.get('con_encoding','')!='': con_encoding=i['con_encoding']

       ### Process action ###################################
       rr=init({})
       if rr['return']==0:
          # Run module with a given action
          rr=perform_action(i)
          if rr.get('out','')!='': o=rr['out']

       if cp=='yes':
          elapsed_time=time.time()-start_time
          rr['ck_profile_time']=elapsed_time
          if o=='con':
             out('CK profile time: '+str(elapsed_time)+' sec.')

    # Finalize call (check output) ####################################
    if o=='json' or o=='json_with_sep':
       if o=='json_with_sep': out(cfg['json_sep'])

       rr1=dumps_json({'dict':rr})
       if rr1['return']==0:
          s=rr1['string']
          out(s)

    elif o=='json_file':
       fn=i.get('out_file','')
       if fn=='':
          rr['return']=1
          rr['error']='out==json_file but out_file is not defined in kernel access function'
       else:
          rr1=save_json_to_file({'json_file':fn, 'dict':rr})
          if rr1['return']>0:
             rr['return']=1
             rr['error']=rr1['error']

    # If error and CMD, output error to console
    if cmd:
       if rr['return']>0:
          x=''
          if type(i)==dict:
             x=i.get('module_uoa','')
             if x!='':
                x='['+x+'] '
          out(cfg['error']+x+rr['error']+'!')

    return rr",python,"def access(i):

    """"""
    Input:  Can be dictionary or string (string will be converted to dictionary)

            {
               action

               module_uoa or CID -> converted to cid
                 or
               (cid1)            -  if doesn't have = and doesn't start from -- or - or @ -> appended to cids[]
               (cid2)            -  if doesn't have = and doesn't start from -- or - or @ -> appended to cids[]
               (cid3)            -  if doesn't have = and doesn't start from -- or - or @ -> appended to cids[]
                 or
               (repo_uoa)
               (module_uoa)
               (data_uoa)

               (out=type)     Module output
                              == ''              - none
                              == 'con'           - console interaction (if from CMD, default)
                              == 'json'          - return dict as json to console
                              == 'json_with_sep' - separation line and return dict as json to console
                              == 'json_file'     - return dict as json to file

               (out_file)     Output file if out=='json_file'

               (con_encoding) - force encoding for IO
               (ck_profile)   - if 'yes', profile CK

               INPUT TO A GIVEN FUNCTION


               NOTE: If INPUT is a string and it will be converted to INPUT dictionary as follows (the same as CK command line):

                     ck key1=value1    -> converted to {key1:value1}

                        -key10         -> converted to {key10:""yes""}
                        -key11=value11 -> converted to {key11:value11}

                        --key12         -> converted to {key12:""yes""}
                        --key13=value13 -> converted to {key13:value13}


                     @file_json         -> JSON from this file will be merged with INPUT
                     @@                 -> CK will ask user ot enter manually JSON from console and merge with INPUT
                     @@key              -> Enter JSON manually from console and merge with INPUT under this key

                     @@@cmd_json        -> convert string to JSON (special format) and merge with INPUT

                     -- xyz             -> add everything after -- to ""unparsed_cmd"" key in INPUT

                     When string is converted to INPUT dictionary, ""cmd"" variable is set to True
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              OUTPUT FROM A GIVEN FUNCTION
            }

    """"""

    global con_encoding

#    # Set fresh configuration for each access - very costly
#    if cfg.get('loading_config','') == '':
#        cfg['loading_config'] = 'yes'
#        r=access({'action':'load',
#                  'repo_uoa':cfg['repo_name_default'],
#                  'module_uoa':cfg['subdir_kernel'],
#                  'data_uoa':cfg['subdir_kernel_default']})
#        if r['return']==0:
#           cfg.update(r['dict'])
#
#        r=access({'action':'load',
#                  'repo_uoa':cfg['repo_name_local'],
#                  'module_uoa':cfg['subdir_kernel'],
#                  'data_uoa':cfg['subdir_kernel_default']})
#        if r['return']==0:
#           cfg.update(r['dict'])
#        cfg['loading_config'] = ''

    rr={'return':0}
    ii={}
    cmd=False
    o=''

    ### If input is string, split into list and process in the next condition
    if type(i)==str:
       cmd=True
       x=i.split(' ')
       i=x 

    ### If input is a list
    if type(i)==list:
       if len(i)==1 and i[0].strip()=='test_install':
          return rr # installation test

       cmd=True
       rr=convert_ck_list_to_dict(i)
       if rr['return']==0:
          i=rr.get('ck_dict',{})

          if i.get('out','')=='': i['out']='con' # Default output is console 
                                                 # if called from CMD or with string

    o=''
    if rr['return']==0:
       # Check output mode
       o=i.get('out','')

       ### If profile
       cp=i.get('ck_profile','')
       if cp=='yes':
          import time
          start_time = time.time()

       ### Process request ######################################

       if i.get('con_encoding','')!='': con_encoding=i['con_encoding']

       ### Process action ###################################
       rr=init({})
       if rr['return']==0:
          # Run module with a given action
          rr=perform_action(i)
          if rr.get('out','')!='': o=rr['out']

       if cp=='yes':
          elapsed_time=time.time()-start_time
          rr['ck_profile_time']=elapsed_time
          if o=='con':
             out('CK profile time: '+str(elapsed_time)+' sec.')

    # Finalize call (check output) ####################################
    if o=='json' or o=='json_with_sep':
       if o=='json_with_sep': out(cfg['json_sep'])

       rr1=dumps_json({'dict':rr})
       if rr1['return']==0:
          s=rr1['string']
          out(s)

    elif o=='json_file':
       fn=i.get('out_file','')
       if fn=='':
          rr['return']=1
          rr['error']='out==json_file but out_file is not defined in kernel access function'
       else:
          rr1=save_json_to_file({'json_file':fn, 'dict':rr})
          if rr1['return']>0:
             rr['return']=1
             rr['error']=rr1['error']

    # If error and CMD, output error to console
    if cmd:
       if rr['return']>0:
          x=''
          if type(i)==dict:
             x=i.get('module_uoa','')
             if x!='':
                x='['+x+'] '
          out(cfg['error']+x+rr['error']+'!')

    return rr","['def' 'access' '(' 'i' ')' ':' 'global' 'con_encoding'
 '#    # Set fresh configuration for each access - very costly'
 ""#    if cfg.get('loading_config','') == '':""
 ""#        cfg['loading_config'] = 'yes'""
 ""#        r=access({'action':'load',""
 ""#                  'repo_uoa':cfg['repo_name_default'],""
 ""#                  'module_uoa':cfg['subdir_kernel'],""
 ""#                  'data_uoa':cfg['subdir_kernel_default']})""
 ""#        if r['return']==0:"" ""#           cfg.update(r['dict'])"" '#'
 ""#        r=access({'action':'load',""
 ""#                  'repo_uoa':cfg['repo_name_local'],""
 ""#                  'module_uoa':cfg['subdir_kernel'],""
 ""#                  'data_uoa':cfg['subdir_kernel_default']})""
 ""#        if r['return']==0:"" ""#           cfg.update(r['dict'])""
 ""#        cfg['loading_config'] = ''"" 'rr' '=' '{' ""'return'"" ':' '0' '}'
 'ii' '=' '{' '}' 'cmd' '=' 'False' 'o' '=' ""''""
 '### If input is string, split into list and process in the next condition'
 'if' 'type' '(' 'i' ')' '==' 'str' ':' 'cmd' '=' 'True' 'x' '=' 'i' '.'
 'split' '(' ""' '"" ')' 'i' '=' 'x' '### If input is a list' 'if' 'type'
 '(' 'i' ')' '==' 'list' ':' 'if' 'len' '(' 'i' ')' '==' '1' 'and' 'i' '['
 '0' ']' '.' 'strip' '(' ')' '==' ""'test_install'"" ':' 'return' 'rr'
 '# installation test' 'cmd' '=' 'True' 'rr' '=' 'convert_ck_list_to_dict'
 '(' 'i' ')' 'if' 'rr' '[' ""'return'"" ']' '==' '0' ':' 'i' '=' 'rr' '.'
 'get' '(' ""'ck_dict'"" ',' '{' '}' ')' 'if' 'i' '.' 'get' '(' ""'out'"" ','
 ""''"" ')' '==' ""''"" ':' 'i' '[' ""'out'"" ']' '=' ""'con'""
 '# Default output is console ' '# if called from CMD or with string' 'o'
 '=' ""''"" 'if' 'rr' '[' ""'return'"" ']' '==' '0' ':' '# Check output mode'
 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''"" ')' '### If profile' 'cp' '='
 'i' '.' 'get' '(' ""'ck_profile'"" ',' ""''"" ')' 'if' 'cp' '==' ""'yes'"" ':'
 'import' 'time' 'start_time' '=' 'time' '.' 'time' '(' ')'
 '### Process request ######################################' 'if' 'i' '.'
 'get' '(' ""'con_encoding'"" ',' ""''"" ')' '!=' ""''"" ':' 'con_encoding' '='
 'i' '[' ""'con_encoding'"" ']'
 '### Process action ###################################' 'rr' '=' 'init'
 '(' '{' '}' ')' 'if' 'rr' '[' ""'return'"" ']' '==' '0' ':'
 '# Run module with a given action' 'rr' '=' 'perform_action' '(' 'i' ')'
 'if' 'rr' '.' 'get' '(' ""'out'"" ',' ""''"" ')' '!=' ""''"" ':' 'o' '=' 'rr'
 '[' ""'out'"" ']' 'if' 'cp' '==' ""'yes'"" ':' 'elapsed_time' '=' 'time' '.'
 'time' '(' ')' '-' 'start_time' 'rr' '[' ""'ck_profile_time'"" ']' '='
 'elapsed_time' 'if' 'o' '==' ""'con'"" ':' 'out' '(' ""'CK profile time: '""
 '+' 'str' '(' 'elapsed_time' ')' '+' ""' sec.'"" ')'
 '# Finalize call (check output) ####################################'
 'if' 'o' '==' ""'json'"" 'or' 'o' '==' ""'json_with_sep'"" ':' 'if' 'o' '=='
 ""'json_with_sep'"" ':' 'out' '(' 'cfg' '[' ""'json_sep'"" ']' ')' 'rr1' '='
 'dumps_json' '(' '{' ""'dict'"" ':' 'rr' '}' ')' 'if' 'rr1' '[' ""'return'""
 ']' '==' '0' ':' 's' '=' 'rr1' '[' ""'string'"" ']' 'out' '(' 's' ')'
 'elif' 'o' '==' ""'json_file'"" ':' 'fn' '=' 'i' '.' 'get' '(' ""'out_file'""
 ',' ""''"" ')' 'if' 'fn' '==' ""''"" ':' 'rr' '[' ""'return'"" ']' '=' '1' 'rr'
 '[' ""'error'"" ']' '='
 ""'out==json_file but out_file is not defined in kernel access function'""
 'else' ':' 'rr1' '=' 'save_json_to_file' '(' '{' ""'json_file'"" ':' 'fn'
 ',' ""'dict'"" ':' 'rr' '}' ')' 'if' 'rr1' '[' ""'return'"" ']' '>' '0' ':'
 'rr' '[' ""'return'"" ']' '=' '1' 'rr' '[' ""'error'"" ']' '=' 'rr1' '['
 ""'error'"" ']' '# If error and CMD, output error to console' 'if' 'cmd'
 ':' 'if' 'rr' '[' ""'return'"" ']' '>' '0' ':' 'x' '=' ""''"" 'if' 'type' '('
 'i' ')' '==' 'dict' ':' 'x' '=' 'i' '.' 'get' '(' ""'module_uoa'"" ',' ""''""
 ')' 'if' 'x' '!=' ""''"" ':' 'x' '=' ""'['"" '+' 'x' '+' ""'] '"" 'out' '('
 'cfg' '[' ""'error'"" ']' '+' 'x' '+' 'rr' '[' ""'error'"" ']' '+' ""'!'"" ')'
 'return' 'rr']","Input:  Can be dictionary or string (string will be converted to dictionary)

            {
               action

               module_uoa or CID -> converted to cid
                 or
               (cid1)            -  if doesn't have = and doesn't start from -- or - or @ -> appended to cids[]
               (cid2)            -  if doesn't have = and doesn't start from -- or - or @ -> appended to cids[]
               (cid3)            -  if doesn't have = and doesn't start from -- or - or @ -> appended to cids[]
                 or
               (repo_uoa)
               (module_uoa)
               (data_uoa)

               (out=type)     Module output
                              == ''              - none
                              == 'con'           - console interaction (if from CMD, default)
                              == 'json'          - return dict as json to console
                              == 'json_with_sep' - separation line and return dict as json to console
                              == 'json_file'     - return dict as json to file

               (out_file)     Output file if out=='json_file'

               (con_encoding) - force encoding for IO
               (ck_profile)   - if 'yes', profile CK

               INPUT TO A GIVEN FUNCTION


               NOTE: If INPUT is a string and it will be converted to INPUT dictionary as follows (the same as CK command line):

                     ck key1=value1    -> converted to {key1:value1}

                        -key10         -> converted to {key10:""yes""}
                        -key11=value11 -> converted to {key11:value11}

                        --key12         -> converted to {key12:""yes""}
                        --key13=value13 -> converted to {key13:value13}


                     @file_json         -> JSON from this file will be merged with INPUT
                     @@                 -> CK will ask user ot enter manually JSON from console and merge with INPUT
                     @@key              -> Enter JSON manually from console and merge with INPUT under this key

                     @@@cmd_json        -> convert string to JSON (special format) and merge with INPUT

                     -- xyz             -> add everything after -- to ""unparsed_cmd"" key in INPUT

                     When string is converted to INPUT dictionary, ""cmd"" variable is set to True
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              OUTPUT FROM A GIVEN FUNCTION
            }","['Input' ':' 'Can' 'be' 'dictionary' 'or' 'string' '(' 'string' 'will'
 'be' 'converted' 'to' 'dictionary' ')']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/kernel.py#L9468-L9635
ctuning/ck,ck/repo/module/module/module.py,add,"def add(i):
    """"""
    Input:  {
              (repo_uoa)          - repo UOA
              module_uoa          - normally should be 'module' already
              data_uoa            - UOA of the module to be created

              (desc)              - module description
              (license)           - module license
              (copyright)         - module copyright
              (developer)         - module developer
              (developer_email)   - module developer
              (developer_webpage) - module developer
              (actions)           - dict with actions {""func1"":{}, ""func2"":{} ...}
              (dict)              - other meta description to add to entry

              (quiet)             - minimal interaction
              (func)              - just add one dummy action
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of the 'add' kernel function
            }

    """"""

    # Check if global writing is allowed
    r=ck.check_writing({'module_uoa':work['self_module_uoa']})
    if r['return']>0: return r

    o=i.get('out','')

    # Find path to module 'module' to get dummies
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':work['self_module_uoa'],
                 'common_func':'yes'})
    if r['return']>0: return r
    p=r['path']

    pm=os.path.join(p,cfg['dummy_module'])
    pma=os.path.join(p,cfg['dummy_module_action'])

    # Load module dummy
    r=ck.load_text_file({'text_file':pm})
    if r['return']>0: return r
    spm=r['string']

    # Load module action dummy
    r=ck.load_text_file({'text_file':pma})
    if r['return']>0: return r
    spma=r['string']

    # Prepare meta description
    desc=i.get('desc','')
    license=i.get('license','')
    copyright=i.get('copyright','')
    developer=i.get('developer','')
    developer_email=i.get('developer_email','')
    developer_webpage=i.get('developer_webpage','')
    actions=i.get('actions',{})

    func=i.get('func','')
    if func!='':
       actions[func]={}

    quiet=i.get('quiet','')

    # If console mode, ask some questions
    if quiet!='yes' and o=='con':
       if desc=='':
          ck.out('')
          r=ck.inp({'text':'Add brief module description: '})
          desc=r['string']

       if license=='' and ck.cfg.get('default_license','')!='':
          ck.out('')
          r=ck.inp({'text':'Add brief module license (or Enter to use ""'+ck.cfg['default_license']+'""): '})
          license=r['string']
          if license=='': license=ck.cfg['default_license']

       if copyright=='' and ck.cfg.get('default_copyright','')!='':
          ck.out('')
          r=ck.inp({'text':'Add brief module copyright (or Enter to use ""'+ck.cfg['default_copyright']+'""): '})
          copyright=r['string']
          if copyright=='': copyright=ck.cfg['default_copyright']

       if developer=='' and ck.cfg.get('default_developer','')!='':
          ck.out('')
          r=ck.inp({'text':'Add module\'s developer (or Enter to use ""'+ck.cfg['default_developer']+'""): '})
          developer=r['string']
          if developer=='': developer=ck.cfg['default_developer']

       if developer_email=='' and ck.cfg.get('default_developer_email','')!='':
          ck.out('')
          r=ck.inp({'text':'Add module\'s developer email (or Enter to use ""'+ck.cfg['default_developer_email']+'""): '})
          developer_email=r['string']
          if developer_email=='': developer_email=ck.cfg['default_developer_email']

       if developer_webpage==''  and ck.cfg.get('default_developer_webpage','')!='':
          ck.out('')
          r=ck.inp({'text':'Add module\'s developer webpage (or Enter to use ""'+ck.cfg['default_developer_webpage']+'""): '})
          developer_webpage=r['string']
          if developer_webpage=='': developer_webpage=ck.cfg['default_developer_webpage']

       if len(actions)==0:
          act='*'
          while act!='':
             ck.out('')

             r=ck.inp({'text':'Add action function (or Enter to stop): '})
             act=r['string']
             if act!='': 
                actions[act]={}

                r1=ck.inp({'text':'Support web (y/N): '})
                x=r1['string'].lower()
                if x=='yes' or x=='y': 
                   fweb='yes'
                   actions[act]['for_web']=fweb

                r1=ck.inp({'text':'Add action description: '})
                adesc=r1['string']
                if adesc!='': 
                   actions[act]['desc']=adesc

    ck.out('')

    # Prepare meta description
    dd={}
    if desc!='': 
       dd['desc']=desc
    spm=spm.replace('$#desc#$', desc)

    if license!='': 
       dd['license']=license
    spm=spm.replace('$#license#$', license)

    if copyright!='': 
       dd['copyright']=copyright
    spm=spm.replace('$#copyright#$', copyright)

    dev=''
    if developer!='': 
       dev=developer
       dd['developer']=developer

    if developer_email!='': 
       if dev!='': dev+=', '
       dev+=developer_email
       dd['developer_email']=developer_email

    if developer_webpage!='': 
       if dev!='': dev+=', '
       dev+=developer_webpage
       dd['developer_webpage']=developer_webpage

    spm=spm.replace('$#developer#$', dev)

    dd['actions']=actions

    # Substitute actions
    for act in actions:
        adesc=actions[act].get('desc','TBD: action description')
        spm+='\n'+spma.replace('$#action#$', act).replace('$#desc#$',adesc)

    dx=i.get('dict',{})

    r=ck.merge_dicts({'dict1':dx, 'dict2':dd})
    if r['return']>0: return r

    # Add entry (it will ask further questions about alias and user-friendly name)
    i['common_func']='yes'
    i['dict']=dx
    i['sort_keys']='yes'
    r=ck.access(i)
    if r['return']>0: return r

    # Add module code
    p=r['path']
    pf=os.path.join(p, ck.cfg['module_full_code_name'])
   
    if o=='con':
       ck.out('')
       ck.out('Creating module code '+pf+' ...')

    # Write module code
    rx=ck.save_text_file({'text_file':pf, 'string':spm})
    if rx['return']>0: return rx

    return r",python,"def add(i):
    """"""
    Input:  {
              (repo_uoa)          - repo UOA
              module_uoa          - normally should be 'module' already
              data_uoa            - UOA of the module to be created

              (desc)              - module description
              (license)           - module license
              (copyright)         - module copyright
              (developer)         - module developer
              (developer_email)   - module developer
              (developer_webpage) - module developer
              (actions)           - dict with actions {""func1"":{}, ""func2"":{} ...}
              (dict)              - other meta description to add to entry

              (quiet)             - minimal interaction
              (func)              - just add one dummy action
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of the 'add' kernel function
            }

    """"""

    # Check if global writing is allowed
    r=ck.check_writing({'module_uoa':work['self_module_uoa']})
    if r['return']>0: return r

    o=i.get('out','')

    # Find path to module 'module' to get dummies
    r=ck.access({'action':'load',
                 'module_uoa':work['self_module_uoa'],
                 'data_uoa':work['self_module_uoa'],
                 'common_func':'yes'})
    if r['return']>0: return r
    p=r['path']

    pm=os.path.join(p,cfg['dummy_module'])
    pma=os.path.join(p,cfg['dummy_module_action'])

    # Load module dummy
    r=ck.load_text_file({'text_file':pm})
    if r['return']>0: return r
    spm=r['string']

    # Load module action dummy
    r=ck.load_text_file({'text_file':pma})
    if r['return']>0: return r
    spma=r['string']

    # Prepare meta description
    desc=i.get('desc','')
    license=i.get('license','')
    copyright=i.get('copyright','')
    developer=i.get('developer','')
    developer_email=i.get('developer_email','')
    developer_webpage=i.get('developer_webpage','')
    actions=i.get('actions',{})

    func=i.get('func','')
    if func!='':
       actions[func]={}

    quiet=i.get('quiet','')

    # If console mode, ask some questions
    if quiet!='yes' and o=='con':
       if desc=='':
          ck.out('')
          r=ck.inp({'text':'Add brief module description: '})
          desc=r['string']

       if license=='' and ck.cfg.get('default_license','')!='':
          ck.out('')
          r=ck.inp({'text':'Add brief module license (or Enter to use ""'+ck.cfg['default_license']+'""): '})
          license=r['string']
          if license=='': license=ck.cfg['default_license']

       if copyright=='' and ck.cfg.get('default_copyright','')!='':
          ck.out('')
          r=ck.inp({'text':'Add brief module copyright (or Enter to use ""'+ck.cfg['default_copyright']+'""): '})
          copyright=r['string']
          if copyright=='': copyright=ck.cfg['default_copyright']

       if developer=='' and ck.cfg.get('default_developer','')!='':
          ck.out('')
          r=ck.inp({'text':'Add module\'s developer (or Enter to use ""'+ck.cfg['default_developer']+'""): '})
          developer=r['string']
          if developer=='': developer=ck.cfg['default_developer']

       if developer_email=='' and ck.cfg.get('default_developer_email','')!='':
          ck.out('')
          r=ck.inp({'text':'Add module\'s developer email (or Enter to use ""'+ck.cfg['default_developer_email']+'""): '})
          developer_email=r['string']
          if developer_email=='': developer_email=ck.cfg['default_developer_email']

       if developer_webpage==''  and ck.cfg.get('default_developer_webpage','')!='':
          ck.out('')
          r=ck.inp({'text':'Add module\'s developer webpage (or Enter to use ""'+ck.cfg['default_developer_webpage']+'""): '})
          developer_webpage=r['string']
          if developer_webpage=='': developer_webpage=ck.cfg['default_developer_webpage']

       if len(actions)==0:
          act='*'
          while act!='':
             ck.out('')

             r=ck.inp({'text':'Add action function (or Enter to stop): '})
             act=r['string']
             if act!='': 
                actions[act]={}

                r1=ck.inp({'text':'Support web (y/N): '})
                x=r1['string'].lower()
                if x=='yes' or x=='y': 
                   fweb='yes'
                   actions[act]['for_web']=fweb

                r1=ck.inp({'text':'Add action description: '})
                adesc=r1['string']
                if adesc!='': 
                   actions[act]['desc']=adesc

    ck.out('')

    # Prepare meta description
    dd={}
    if desc!='': 
       dd['desc']=desc
    spm=spm.replace('$#desc#$', desc)

    if license!='': 
       dd['license']=license
    spm=spm.replace('$#license#$', license)

    if copyright!='': 
       dd['copyright']=copyright
    spm=spm.replace('$#copyright#$', copyright)

    dev=''
    if developer!='': 
       dev=developer
       dd['developer']=developer

    if developer_email!='': 
       if dev!='': dev+=', '
       dev+=developer_email
       dd['developer_email']=developer_email

    if developer_webpage!='': 
       if dev!='': dev+=', '
       dev+=developer_webpage
       dd['developer_webpage']=developer_webpage

    spm=spm.replace('$#developer#$', dev)

    dd['actions']=actions

    # Substitute actions
    for act in actions:
        adesc=actions[act].get('desc','TBD: action description')
        spm+='\n'+spma.replace('$#action#$', act).replace('$#desc#$',adesc)

    dx=i.get('dict',{})

    r=ck.merge_dicts({'dict1':dx, 'dict2':dd})
    if r['return']>0: return r

    # Add entry (it will ask further questions about alias and user-friendly name)
    i['common_func']='yes'
    i['dict']=dx
    i['sort_keys']='yes'
    r=ck.access(i)
    if r['return']>0: return r

    # Add module code
    p=r['path']
    pf=os.path.join(p, ck.cfg['module_full_code_name'])
   
    if o=='con':
       ck.out('')
       ck.out('Creating module code '+pf+' ...')

    # Write module code
    rx=ck.save_text_file({'text_file':pf, 'string':spm})
    if rx['return']>0: return rx

    return r",['def' 'add' '(' ... 'rx' 'return' 'r'],"Input:  {
              (repo_uoa)          - repo UOA
              module_uoa          - normally should be 'module' already
              data_uoa            - UOA of the module to be created

              (desc)              - module description
              (license)           - module license
              (copyright)         - module copyright
              (developer)         - module developer
              (developer_email)   - module developer
              (developer_webpage) - module developer
              (actions)           - dict with actions {""func1"":{}, ""func2"":{} ...}
              (dict)              - other meta description to add to entry

              (quiet)             - minimal interaction
              (func)              - just add one dummy action
            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0

              Output of the 'add' kernel function
            }","['Input' ':' '{' '(' 'repo_uoa' ')' '-' 'repo' 'UOA' 'module_uoa' '-'
 'normally' 'should' 'be' 'module' 'already' 'data_uoa' '-' 'UOA' 'of'
 'the' 'module' 'to' 'be' 'created']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/module/module.py#L37-L231
ctuning/ck,ck/repo/module/module/module.py,show,"def show(i):
    """"""
    Input:  {
               (the same as list; can use wildcards)


            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    of=i.get('out_file','')
    if of!='':
       xof=os.path.splitext(of)

    html=False
    if o=='html' or i.get('web','')=='yes':
       html=True

    h=''

    unique_repo=False
    if i.get('repo_uoa','')!='': unique_repo=True

    import copy
    ii=copy.deepcopy(i)

    ii['out']=''
    ii['action']='list'
    ii['add_meta']='yes'

    rx=ck.access(ii)
    if rx['return']>0: return rx

    ll=sorted(rx['lst'], key=lambda k: k['data_uoa'])

    if html:
       h+='You can install and reuse CK modules as follows:\n'
       h+='<pre>\n'
       h+=' ck pull repo:{Repo UOA - see below}\n'
       h+=' ck help {module UOA - see below}\n'
       h+='</pre>\n'

       h+='You can check a JSON API of a given action of a given module as follows:\n'
       h+='<pre>\n'
       h+=' ck {module action - see below} {module UOA} --help\n'
       h+='</pre>\n'

       h+='You can add your own dummy CK module as follows:\n'
       h+='<pre>\n'
       h+=' ck add module:{my module alias}\n'
       h+='</pre>\n'

       h+='You can add a new action to the CK module as follows:\n'
       h+='<pre>\n'
       h+=' ck add_action module:{my module alias}\n'
       h+='</pre>\n'

       h+='See <a href=""https://github.com/ctuning/ck/wiki"">CK documentation</a>\n'
       h+=' and the latest <a href=""http://cKnowledge.org/rpi-crowd-tuning"">CK paper</a> for further details.\n'

       h+='<p>\n'
       h+='<table cellpadding=""4"" border=""1"" style=""border-collapse: collapse; border: 1px solid black;"">\n'

       h+=' <tr>\n'
       h+='  <td nowrap><b>#</b></td>\n'
       h+='  <td nowrap><b>Module&nbsp;UOA with JSON API<br>(Python module/wrapper/plugin)</b></td>\n'
       h+='  <td nowrap><b>Repo UOA</b></td>\n'
       h+='  <td><b>Description and actions</b></td>\n'
       h+=' </tr>\n'

    repo_url={}
    repo_private={}

    private=''
    num=0
    for l in ll:
        ln=l['data_uoa']
        lr=l['repo_uoa']

        lr_uid=l['repo_uid']
        url=''
        if lr=='default':
           url='https://github.com/ctuning/ck/tree/master/ck/repo'
        elif lr_uid in repo_url:
           url=repo_url[lr_uid]
        else:
           rx=ck.load_repo_info_from_cache({'repo_uoa':lr_uid})
           if rx['return']>0: return rx
           url=rx.get('dict',{}).get('url','')
           repo_private[lr_uid]=rx.get('dict',{}).get('private','')
           repo_url[lr_uid]=url

        private=repo_private.get(lr_uid,'')

#        if lr not in cfg.get('skip_repos',[]) and private!='yes' and url!='':
        if lr not in cfg.get('skip_repos',[]) and private!='yes' and url!='':
           num+=1

           lm=l['meta']
           ld=lm.get('desc','')

           actions=lm.get('actions',{})

           if lr=='default':
              to_get=''
           elif url.find('github.com/ctuning/')>0:
              to_get='ck pull repo:'+lr
           else:
              to_get='ck pull repo --url='+url

           ###############################################################
           if html:
              h+=' <tr>\n'

              x1=''
              x2=''
              z1=''
              z11=''
              if url!='':
                 x1='<a href=""'+url+'"">'
                 x2='</a>'

                 url2=url

                 if url2.endswith('.git'):
                    url2=url2[:-4]

                 if '/tree/master/' not in url2:
                    url2+='/tree/master/module/'
                 else:
                    url2+='/module/'

                 z1='<a href=""'+url2+ln+'/module.py"">'
                 z11='<a href=""'+url2+ln+'/.cm/meta.json"">'

              h+='  <td nowrap valign=""top""><a name=""'+ln+'"">'+str(num)+'</b></td>\n'

              h+='  <td nowrap valign=""top"">'+z1+ln+x2+'</b> <i>('+z11+'CK meta'+x2+')</i></td>\n'

              h+='  <td nowrap valign=""top""><b>'+x1+lr+x2+'</b></td>\n'

              h+='  <td valign=""top"">'+ld+'\n'

              if len(actions)>0:
                 h+='<ul>\n'
                 for q in sorted(actions):
                     qq=actions[q]
                     qd=qq.get('desc','')
                     h+='<li>""ck <i>'+q+'</i> '+ln+'""'
                     if qd!='':
                        h+=' - '+qd
                 h+='</ul>\n'

              h+='</td>\n'

              h+=' </tr>\n'

           ###############################################################
           elif o=='mediawiki':
              x=lr
              if url!='':
                 x='['+url+' '+lr+']'
              ck.out('')
              ck.out('=== '+ln+' ('+lr+') ===')
              ck.out('')
              ck.out('Desc: '+ld)
              ck.out('<br>CK Repo URL: '+x)
              if to_get!='':
                 ck.out('<br>How to get: <i>'+to_get+'</i>')
              ck.out('')
              if len(actions)>0:

                 ck.out('Actions (functions):')
                 ck.out('')

                 for q in sorted(actions):
                     qq=actions[q]
                     qd=qq.get('desc','')
                     ck.out('* \'\''+q+'\'\' - '+qd)

           ###############################################################
           elif o=='con' or o=='txt':
              if unique_repo:
                 ck.out('')
                 s=ln+' - '+ld

              else:
                 ss=''
                 if len(ln)<35: ss=' '*(35-len(ln))

                 ss1=''
                 if len(lr)<30: ss1=' '*(30-len(lr))

                 s=ln+ss+'  ('+lr+')'
                 if ld!='': s+=ss1+'  '+ld

              ck.out(s)

              if len(actions)>0:
                 ck.out('')
                 for q in sorted(actions):
                     qq=actions[q]
                     qd=qq.get('desc','')
                     ck.out('  * '+q+' - '+qd)


    if html:
       h+='</table>\n'

       if of!='':
          r=ck.save_text_file({'text_file':of, 'string':h})
          if r['return']>0: return r

    return {'return':0, 'html':h}",python,"def show(i):
    """"""
    Input:  {
               (the same as list; can use wildcards)


            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }

    """"""

    o=i.get('out','')

    of=i.get('out_file','')
    if of!='':
       xof=os.path.splitext(of)

    html=False
    if o=='html' or i.get('web','')=='yes':
       html=True

    h=''

    unique_repo=False
    if i.get('repo_uoa','')!='': unique_repo=True

    import copy
    ii=copy.deepcopy(i)

    ii['out']=''
    ii['action']='list'
    ii['add_meta']='yes'

    rx=ck.access(ii)
    if rx['return']>0: return rx

    ll=sorted(rx['lst'], key=lambda k: k['data_uoa'])

    if html:
       h+='You can install and reuse CK modules as follows:\n'
       h+='<pre>\n'
       h+=' ck pull repo:{Repo UOA - see below}\n'
       h+=' ck help {module UOA - see below}\n'
       h+='</pre>\n'

       h+='You can check a JSON API of a given action of a given module as follows:\n'
       h+='<pre>\n'
       h+=' ck {module action - see below} {module UOA} --help\n'
       h+='</pre>\n'

       h+='You can add your own dummy CK module as follows:\n'
       h+='<pre>\n'
       h+=' ck add module:{my module alias}\n'
       h+='</pre>\n'

       h+='You can add a new action to the CK module as follows:\n'
       h+='<pre>\n'
       h+=' ck add_action module:{my module alias}\n'
       h+='</pre>\n'

       h+='See <a href=""https://github.com/ctuning/ck/wiki"">CK documentation</a>\n'
       h+=' and the latest <a href=""http://cKnowledge.org/rpi-crowd-tuning"">CK paper</a> for further details.\n'

       h+='<p>\n'
       h+='<table cellpadding=""4"" border=""1"" style=""border-collapse: collapse; border: 1px solid black;"">\n'

       h+=' <tr>\n'
       h+='  <td nowrap><b>#</b></td>\n'
       h+='  <td nowrap><b>Module&nbsp;UOA with JSON API<br>(Python module/wrapper/plugin)</b></td>\n'
       h+='  <td nowrap><b>Repo UOA</b></td>\n'
       h+='  <td><b>Description and actions</b></td>\n'
       h+=' </tr>\n'

    repo_url={}
    repo_private={}

    private=''
    num=0
    for l in ll:
        ln=l['data_uoa']
        lr=l['repo_uoa']

        lr_uid=l['repo_uid']
        url=''
        if lr=='default':
           url='https://github.com/ctuning/ck/tree/master/ck/repo'
        elif lr_uid in repo_url:
           url=repo_url[lr_uid]
        else:
           rx=ck.load_repo_info_from_cache({'repo_uoa':lr_uid})
           if rx['return']>0: return rx
           url=rx.get('dict',{}).get('url','')
           repo_private[lr_uid]=rx.get('dict',{}).get('private','')
           repo_url[lr_uid]=url

        private=repo_private.get(lr_uid,'')

#        if lr not in cfg.get('skip_repos',[]) and private!='yes' and url!='':
        if lr not in cfg.get('skip_repos',[]) and private!='yes' and url!='':
           num+=1

           lm=l['meta']
           ld=lm.get('desc','')

           actions=lm.get('actions',{})

           if lr=='default':
              to_get=''
           elif url.find('github.com/ctuning/')>0:
              to_get='ck pull repo:'+lr
           else:
              to_get='ck pull repo --url='+url

           ###############################################################
           if html:
              h+=' <tr>\n'

              x1=''
              x2=''
              z1=''
              z11=''
              if url!='':
                 x1='<a href=""'+url+'"">'
                 x2='</a>'

                 url2=url

                 if url2.endswith('.git'):
                    url2=url2[:-4]

                 if '/tree/master/' not in url2:
                    url2+='/tree/master/module/'
                 else:
                    url2+='/module/'

                 z1='<a href=""'+url2+ln+'/module.py"">'
                 z11='<a href=""'+url2+ln+'/.cm/meta.json"">'

              h+='  <td nowrap valign=""top""><a name=""'+ln+'"">'+str(num)+'</b></td>\n'

              h+='  <td nowrap valign=""top"">'+z1+ln+x2+'</b> <i>('+z11+'CK meta'+x2+')</i></td>\n'

              h+='  <td nowrap valign=""top""><b>'+x1+lr+x2+'</b></td>\n'

              h+='  <td valign=""top"">'+ld+'\n'

              if len(actions)>0:
                 h+='<ul>\n'
                 for q in sorted(actions):
                     qq=actions[q]
                     qd=qq.get('desc','')
                     h+='<li>""ck <i>'+q+'</i> '+ln+'""'
                     if qd!='':
                        h+=' - '+qd
                 h+='</ul>\n'

              h+='</td>\n'

              h+=' </tr>\n'

           ###############################################################
           elif o=='mediawiki':
              x=lr
              if url!='':
                 x='['+url+' '+lr+']'
              ck.out('')
              ck.out('=== '+ln+' ('+lr+') ===')
              ck.out('')
              ck.out('Desc: '+ld)
              ck.out('<br>CK Repo URL: '+x)
              if to_get!='':
                 ck.out('<br>How to get: <i>'+to_get+'</i>')
              ck.out('')
              if len(actions)>0:

                 ck.out('Actions (functions):')
                 ck.out('')

                 for q in sorted(actions):
                     qq=actions[q]
                     qd=qq.get('desc','')
                     ck.out('* \'\''+q+'\'\' - '+qd)

           ###############################################################
           elif o=='con' or o=='txt':
              if unique_repo:
                 ck.out('')
                 s=ln+' - '+ld

              else:
                 ss=''
                 if len(ln)<35: ss=' '*(35-len(ln))

                 ss1=''
                 if len(lr)<30: ss1=' '*(30-len(lr))

                 s=ln+ss+'  ('+lr+')'
                 if ld!='': s+=ss1+'  '+ld

              ck.out(s)

              if len(actions)>0:
                 ck.out('')
                 for q in sorted(actions):
                     qq=actions[q]
                     qd=qq.get('desc','')
                     ck.out('  * '+q+' - '+qd)


    if html:
       h+='</table>\n'

       if of!='':
          r=ck.save_text_file({'text_file':of, 'string':h})
          if r['return']>0: return r

    return {'return':0, 'html':h}","['def' 'show' '(' 'i' ')' ':' 'o' '=' 'i' '.' 'get' '(' ""'out'"" ',' ""''""
 ')' 'of' '=' 'i' '.' 'get' '(' ""'out_file'"" ',' ""''"" ')' 'if' 'of' '!='
 ""''"" ':' 'xof' '=' 'os' '.' 'path' '.' 'splitext' '(' 'of' ')' 'html' '='
 'False' 'if' 'o' '==' ""'html'"" 'or' 'i' '.' 'get' '(' ""'web'"" ',' ""''""
 ')' '==' ""'yes'"" ':' 'html' '=' 'True' 'h' '=' ""''"" 'unique_repo' '='
 'False' 'if' 'i' '.' 'get' '(' ""'repo_uoa'"" ',' ""''"" ')' '!=' ""''"" ':'
 'unique_repo' '=' 'True' 'import' 'copy' 'ii' '=' 'copy' '.' 'deepcopy'
 '(' 'i' ')' 'ii' '[' ""'out'"" ']' '=' ""''"" 'ii' '[' ""'action'"" ']' '='
 ""'list'"" 'ii' '[' ""'add_meta'"" ']' '=' ""'yes'"" 'rx' '=' 'ck' '.' 'access'
 '(' 'ii' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx' 'll'
 '=' 'sorted' '(' 'rx' '[' ""'lst'"" ']' ',' 'key' '=' 'lambda' 'k' ':' 'k'
 '[' ""'data_uoa'"" ']' ')' 'if' 'html' ':' 'h' '+='
 ""'You can install and reuse CK modules as follows:\\n'"" 'h' '+='
 ""'<pre>\\n'"" 'h' '+=' ""' ck pull repo:{Repo UOA - see below}\\n'"" 'h'
 '+=' ""' ck help {module UOA - see below}\\n'"" 'h' '+=' ""'</pre>\\n'"" 'h'
 '+='
 ""'You can check a JSON API of a given action of a given module as follows:\\n'""
 'h' '+=' ""'<pre>\\n'"" 'h' '+='
 ""' ck {module action - see below} {module UOA} --help\\n'"" 'h' '+='
 ""'</pre>\\n'"" 'h' '+='
 ""'You can add your own dummy CK module as follows:\\n'"" 'h' '+='
 ""'<pre>\\n'"" 'h' '+=' ""' ck add module:{my module alias}\\n'"" 'h' '+='
 ""'</pre>\\n'"" 'h' '+='
 ""'You can add a new action to the CK module as follows:\\n'"" 'h' '+='
 ""'<pre>\\n'"" 'h' '+=' ""' ck add_action module:{my module alias}\\n'"" 'h'
 '+=' ""'</pre>\\n'"" 'h' '+='
 '\'See <a href=""https://github.com/ctuning/ck/wiki"">CK documentation</a>\\n\''
 'h' '+='
 '\' and the latest <a href=""http://cKnowledge.org/rpi-crowd-tuning"">CK paper</a> for further details.\\n\''
 'h' '+=' ""'<p>\\n'"" 'h' '+='
 '\'<table cellpadding=""4"" border=""1"" style=""border-collapse: collapse; border: 1px solid black;"">\\n\''
 'h' '+=' ""' <tr>\\n'"" 'h' '+=' ""'  <td nowrap><b>#</b></td>\\n'"" 'h' '+='
 ""'  <td nowrap><b>Module&nbsp;UOA with JSON API<br>(Python module/wrapper/plugin)</b></td>\\n'""
 'h' '+=' ""'  <td nowrap><b>Repo UOA</b></td>\\n'"" 'h' '+='
 ""'  <td><b>Description and actions</b></td>\\n'"" 'h' '+=' ""' </tr>\\n'""
 'repo_url' '=' '{' '}' 'repo_private' '=' '{' '}' 'private' '=' ""''""
 'num' '=' '0' 'for' 'l' 'in' 'll' ':' 'ln' '=' 'l' '[' ""'data_uoa'"" ']'
 'lr' '=' 'l' '[' ""'repo_uoa'"" ']' 'lr_uid' '=' 'l' '[' ""'repo_uid'"" ']'
 'url' '=' ""''"" 'if' 'lr' '==' ""'default'"" ':' 'url' '='
 ""'https://github.com/ctuning/ck/tree/master/ck/repo'"" 'elif' 'lr_uid'
 'in' 'repo_url' ':' 'url' '=' 'repo_url' '[' 'lr_uid' ']' 'else' ':' 'rx'
 '=' 'ck' '.' 'load_repo_info_from_cache' '(' '{' ""'repo_uoa'"" ':'
 'lr_uid' '}' ')' 'if' 'rx' '[' ""'return'"" ']' '>' '0' ':' 'return' 'rx'
 'url' '=' 'rx' '.' 'get' '(' ""'dict'"" ',' '{' '}' ')' '.' 'get' '('
 ""'url'"" ',' ""''"" ')' 'repo_private' '[' 'lr_uid' ']' '=' 'rx' '.' 'get'
 '(' ""'dict'"" ',' '{' '}' ')' '.' 'get' '(' ""'private'"" ',' ""''"" ')'
 'repo_url' '[' 'lr_uid' ']' '=' 'url' 'private' '=' 'repo_private' '.'
 'get' '(' 'lr_uid' ',' ""''"" ')'
 ""#        if lr not in cfg.get('skip_repos',[]) and private!='yes' and url!='':""
 'if' 'lr' 'not' 'in' 'cfg' '.' 'get' '(' ""'skip_repos'"" ',' '[' ']' ')'
 'and' 'private' '!=' ""'yes'"" 'and' 'url' '!=' ""''"" ':' 'num' '+=' '1'
 'lm' '=' 'l' '[' ""'meta'"" ']' 'ld' '=' 'lm' '.' 'get' '(' ""'desc'"" ','
 ""''"" ')' 'actions' '=' 'lm' '.' 'get' '(' ""'actions'"" ',' '{' '}' ')'
 'if' 'lr' '==' ""'default'"" ':' 'to_get' '=' ""''"" 'elif' 'url' '.' 'find'
 '(' ""'github.com/ctuning/'"" ')' '>' '0' ':' 'to_get' '='
 ""'ck pull repo:'"" '+' 'lr' 'else' ':' 'to_get' '='
 ""'ck pull repo --url='"" '+' 'url'
 '###############################################################' 'if'
 'html' ':' 'h' '+=' ""' <tr>\\n'"" 'x1' '=' ""''"" 'x2' '=' ""''"" 'z1' '='
 ""''"" 'z11' '=' ""''"" 'if' 'url' '!=' ""''"" ':' 'x1' '=' '\'<a href=""\'' '+'
 'url' '+' '\'"">\'' 'x2' '=' ""'</a>'"" 'url2' '=' 'url' 'if' 'url2' '.'
 'endswith' '(' ""'.git'"" ')' ':' 'url2' '=' 'url2' '[' ':' '-' '4' ']'
 'if' ""'/tree/master/'"" 'not' 'in' 'url2' ':' 'url2' '+='
 ""'/tree/master/module/'"" 'else' ':' 'url2' '+=' ""'/module/'"" 'z1' '='
 '\'<a href=""\'' '+' 'url2' '+' 'ln' '+' '\'/module.py"">\'' 'z11' '='
 '\'<a href=""\'' '+' 'url2' '+' 'ln' '+' '\'/.cm/meta.json"">\'' 'h' '+='
 '\'  <td nowrap valign=""top""><a name=""\'' '+' 'ln' '+' '\'"">\'' '+' 'str'
 '(' 'num' ')' '+' ""'</b></td>\\n'"" 'h' '+='
 '\'  <td nowrap valign=""top"">\'' '+' 'z1' '+' 'ln' '+' 'x2' '+'
 ""'</b> <i>('"" '+' 'z11' '+' ""'CK meta'"" '+' 'x2' '+' ""')</i></td>\\n'""
 'h' '+=' '\'  <td nowrap valign=""top""><b>\'' '+' 'x1' '+' 'lr' '+' 'x2'
 '+' ""'</b></td>\\n'"" 'h' '+=' '\'  <td valign=""top"">\'' '+' 'ld' '+'
 ""'\\n'"" 'if' 'len' '(' 'actions' ')' '>' '0' ':' 'h' '+=' ""'<ul>\\n'""
 'for' 'q' 'in' 'sorted' '(' 'actions' ')' ':' 'qq' '=' 'actions' '[' 'q'
 ']' 'qd' '=' 'qq' '.' 'get' '(' ""'desc'"" ',' ""''"" ')' 'h' '+='
 '\'<li>""ck <i>\'' '+' 'q' '+' ""'</i> '"" '+' 'ln' '+' '\'""\'' 'if' 'qd'
 '!=' ""''"" ':' 'h' '+=' ""' - '"" '+' 'qd' 'h' '+=' ""'</ul>\\n'"" 'h' '+='
 ""'</td>\\n'"" 'h' '+=' ""' </tr>\\n'""
 '###############################################################' 'elif'
 'o' '==' ""'mediawiki'"" ':' 'x' '=' 'lr' 'if' 'url' '!=' ""''"" ':' 'x' '='
 ""'['"" '+' 'url' '+' ""' '"" '+' 'lr' '+' ""']'"" 'ck' '.' 'out' '(' ""''"" ')'
 'ck' '.' 'out' '(' ""'=== '"" '+' 'ln' '+' ""' ('"" '+' 'lr' '+' ""') ==='""
 ')' 'ck' '.' 'out' '(' ""''"" ')' 'ck' '.' 'out' '(' ""'Desc: '"" '+' 'ld'
 ')' 'ck' '.' 'out' '(' ""'<br>CK Repo URL: '"" '+' 'x' ')' 'if' 'to_get'
 '!=' ""''"" ':' 'ck' '.' 'out' '(' ""'<br>How to get: <i>'"" '+' 'to_get' '+'
 ""'</i>'"" ')' 'ck' '.' 'out' '(' ""''"" ')' 'if' 'len' '(' 'actions' ')' '>'
 '0' ':' 'ck' '.' 'out' '(' ""'Actions (functions):'"" ')' 'ck' '.' 'out'
 '(' ""''"" ')' 'for' 'q' 'in' 'sorted' '(' 'actions' ')' ':' 'qq' '='
 'actions' '[' 'q' ']' 'qd' '=' 'qq' '.' 'get' '(' ""'desc'"" ',' ""''"" ')'
 'ck' '.' 'out' '(' ""'* \\'\\''"" '+' 'q' '+' ""'\\'\\' - '"" '+' 'qd' ')'
 '###############################################################' 'elif'
 'o' '==' ""'con'"" 'or' 'o' '==' ""'txt'"" ':' 'if' 'unique_repo' ':' 'ck'
 '.' 'out' '(' ""''"" ')' 's' '=' 'ln' '+' ""' - '"" '+' 'ld' 'else' ':' 'ss'
 '=' ""''"" 'if' 'len' '(' 'ln' ')' '<' '35' ':' 'ss' '=' ""' '"" '*' '(' '35'
 '-' 'len' '(' 'ln' ')' ')' 'ss1' '=' ""''"" 'if' 'len' '(' 'lr' ')' '<'
 '30' ':' 'ss1' '=' ""' '"" '*' '(' '30' '-' 'len' '(' 'lr' ')' ')' 's' '='
 'ln' '+' 'ss' '+' ""'  ('"" '+' 'lr' '+' ""')'"" 'if' 'ld' '!=' ""''"" ':' 's'
 '+=' 'ss1' '+' ""'  '"" '+' 'ld' 'ck' '.' 'out' '(' 's' ')' 'if' 'len' '('
 'actions' ')' '>' '0' ':' 'ck' '.' 'out' '(' ""''"" ')' 'for' 'q' 'in'
 'sorted' '(' 'actions' ')' ':' 'qq' '=' 'actions' '[' 'q' ']' 'qd' '='
 'qq' '.' 'get' '(' ""'desc'"" ',' ""''"" ')' 'ck' '.' 'out' '(' ""'  * '"" '+'
 'q' '+' ""' - '"" '+' 'qd' ')' 'if' 'html' ':' 'h' '+=' ""'</table>\\n'""
 'if' 'of' '!=' ""''"" ':' 'r' '=' 'ck' '.' 'save_text_file' '(' '{'
 ""'text_file'"" ':' 'of' ',' ""'string'"" ':' 'h' '}' ')' 'if' 'r' '['
 ""'return'"" ']' '>' '0' ':' 'return' 'r' 'return' '{' ""'return'"" ':' '0'
 ',' ""'html'"" ':' 'h' '}']","Input:  {
               (the same as list; can use wildcards)


            }

    Output: {
              return       - return code =  0, if successful
                                         >  0, if error
              (error)      - error text if return > 0
            }","['Input' ':' '{' '(' 'the' 'same' 'as' 'list' ';' 'can' 'use' 'wildcards'
 ')']",train,https://github.com/ctuning/ck/blob/7e009814e975f8742790d3106340088a46223714/ck/repo/module/module/module.py#L237-L458
